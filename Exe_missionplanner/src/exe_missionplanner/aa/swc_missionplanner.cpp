///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_missionplanner.cpp
/// SOFTWARE COMPONENT NAME           : Swc_missionplanner
/// GENERATED DATE                    : 2025-12-02 18:57:11
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_missionplanner/aa/swc_missionplanner.h"
#include "mission_planner_runner.hpp"
#include "ros2/ros_autosar_adapter.hpp"

#include <chrono>
#include <thread>

namespace exe_missionplanner
{
    namespace aa
    {

        Swc_missionplanner::Swc_missionplanner()
            : m_logger(ara::log::CreateLogger("MSPL", "SWC", ara::log::LogLevel::kVerbose)), m_running{false}, m_workers(23)
        {
            unsigned hc = std::thread::hardware_concurrency();
            m_ros_thread_count = 1;
        }

        Swc_missionplanner::~Swc_missionplanner()
        {
        }

        bool Swc_missionplanner::Initialize()
        {
            m_logger.LogInfo() << "Swc_missionplanner::Initialize";

            bool init = true;

            m_PPort_MP2BPP = std::make_unique<exe_missionplanner::aa::port::PPort_MP2BPP>();
            m_PPort_MP2SCr = std::make_unique<exe_missionplanner::aa::port::PPort_MP2SCr>();
            m_PPort_MP2SS = std::make_unique<exe_missionplanner::aa::port::PPort_MP2SS>();
            m_RPort_BPP2MP = std::make_unique<exe_missionplanner::aa::port::RPort_BPP2MP>();
            m_RPort_SCr2MP = std::make_unique<exe_missionplanner::aa::port::RPort_SCr2MP>();

            // Register callback for odometry (localization_kinematicstate) events -> update start_pose
            m_RPort_SCr2MP->RegistEventHandlerlocalization_kinematicstate(
                [this](const oss::srv::SCr2MP::proxy::events::localization_kinematicstate::SampleType &odometry) {
                    std::lock_guard<std::mutex> lock(m_pose_mutex);
                    if (m_route_sent) return; // Already sent, ignore further updates
                    
                    // Convert AUTOSAR Odometry.pose.pose (PoseWithCovariance.pose) to ROS2 Pose
                    m_start_pose = ros_autosar_adapter::FromOssPose(odometry.pose.pose);
                    m_start_pose_received = true;
                    m_logger.LogInfo() << "Swc_missionplanner::Received start_pose from odometry";
                    
                    // If both poses are ready, trigger route calculation
                    if (m_start_pose_received && m_goal_pose_received && !m_route_sent)
                    {
                        m_logger.LogInfo() << "Swc_missionplanner::Both poses ready, triggering route calculation";
                        // Signal to calculate route (will be done in separate thread)
                    }
                });

            return init;
        }

        void Swc_missionplanner::Start()
        {
            m_logger.LogInfo() << "Swc_missionplanner::Start";

            m_PPort_MP2BPP->Start();
            m_PPort_MP2SCr->Start();
            m_PPort_MP2SS->Start();
            m_RPort_BPP2MP->Start();
            m_RPort_SCr2MP->Start();

            // Register callback for setwaypointroute requests -> update goal_pose
            // Must be done after Start() because skeleton is created in Start()
            m_PPort_MP2SCr->RegistSetWaypointRouteCallback(
                [this](const oss::type::tier4_planning_msgs::srv::SetWaypointRoute_Request &req) {
                    std::lock_guard<std::mutex> lock(m_pose_mutex);
                    if (m_route_sent) return; // Already sent, ignore further updates
                    
                    // Convert AUTOSAR Pose to ROS2 Pose
                    m_goal_pose = ros_autosar_adapter::FromOssPose(req.goal_pose);
                    m_goal_pose_received = true;
                    m_logger.LogInfo() << "Swc_missionplanner::Received goal_pose from setwaypointroute request";
                    
                    // If both poses are ready, trigger route calculation
                    if (m_start_pose_received && m_goal_pose_received && !m_route_sent)
                    {
                        m_logger.LogInfo() << "Swc_missionplanner::Both poses ready, triggering route calculation";
                        // Signal to calculate route (will be done in separate thread)
                    }
                });

            // Start mission planner runner thread (one-shot execution when both poses are ready)
            m_ros_running.store(true);
            // Allow override of OSM path via environment variable MISSION_PLANNER_OSM_PATH
            const char *env_p = std::getenv("MISSION_PLANNER_OSM_PATH");
#ifdef MISSION_PLANNER_OSM_DEFAULT
            std::string osm_path = env_p ? std::string(env_p) : std::string(MISSION_PLANNER_OSM_DEFAULT);
#else
            std::string osm_path = env_p ? std::string(env_p) : std::string("../sample-map-planning/lanelet2_map.osm");
#endif

            // Single thread that waits for both poses and calculates route once
            m_ros_threads.emplace_back([this, osm_path]()
                                       {
                m_logger.LogInfo() << "Swc_missionplanner::Route calculation thread started";
                
                // Wait for both start_pose and goal_pose to be received
                while (m_ros_running.load())
                {
                    bool ready = false;
                    autoware::mission_planner_universe::Pose start_copy, goal_copy;
                    
                    {
                        std::lock_guard<std::mutex> lock(m_pose_mutex);
                        if (m_route_sent) {
                            m_logger.LogInfo() << "Swc_missionplanner::Route already sent, thread exiting";
                            break;
                        }
                        
                        if (m_start_pose_received && m_goal_pose_received) {
                            ready = true;
                            start_copy = m_start_pose;
                            goal_copy = m_goal_pose;
                            m_logger.LogInfo() << "Swc_missionplanner::Both poses received, calculating route...";
                        }
                    }
                    
                    if (ready)
                    {
                        // Calculate route
                        auto maybe_route = mission_planner_runner::run_once(osm_path, start_copy, goal_copy);
                        
                        if (maybe_route)
                        {
                            m_logger.LogInfo() << "Swc_missionplanner::Route calculated successfully, sending to MP2BPP";
                            auto oss_route = ros_autosar_adapter::ToOssLaneletRoute(*maybe_route);
                            
                            // Send route to BehaviorPathPlanner via MP2BPP
                            if (m_PPort_MP2BPP)
                            {
                                m_PPort_MP2BPP->SendEventplanning_missionplanning_routeTriggered(oss_route);
                                m_logger.LogInfo() << "Swc_missionplanner::Route sent successfully to BehaviorPathPlanner";
                            }
                            
                            {
                                std::lock_guard<std::mutex> lock(m_pose_mutex);
                                m_route_sent = true;
                            }
                            
                            break; // Exit thread after sending once
                        }
                        else
                        {
                            m_logger.LogError() << "Swc_missionplanner::Failed to calculate route";
                            break;
                        }
                    }
                    
                    // Wait before checking again
                    std::this_thread::sleep_for(std::chrono::milliseconds(100));
                }
                
                m_logger.LogInfo() << "Swc_missionplanner::Route calculation thread finished";
            });
        }

        void Swc_missionplanner::Terminate()
        {
            m_logger.LogVerbose() << "Swc_missionplanner::Terminate";

            // stop running
            m_running = false;

            // stop ros runner threads
            m_ros_running.store(false);
            for (auto &t : m_ros_threads)
            {
                if (t.joinable())
                    t.join();
            }
            m_ros_threads.clear();

            m_PPort_MP2BPP->Terminate();
            m_PPort_MP2SCr->Terminate();
            m_PPort_MP2SS->Terminate();
            m_RPort_BPP2MP->Terminate();
            m_RPort_SCr2MP->Terminate();
        }

        void Swc_missionplanner::Run()
        {
            m_logger.LogInfo() << "Swc_missionplanner::Run";

            // start running
            m_running = true;

            m_workers.Async([this]
                            { m_RPort_SCr2MP->ReceiveEventlocalization_kinematicstateCyclic(); });
            m_workers.Wait();
        }

    } /// namespace aa
} /// namespace exe_missionplanner
