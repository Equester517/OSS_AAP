///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : ocp_si_motionvelocityplanner_proxy.h
/// SERVICE INTERFACE NAME            : OCP_SI_motionvelocityplanner
/// GENERATED DATE                    : 2025-12-08 15:30:26
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_OSS_SRV_MVP2OCP_SERVICE_INTERFACE_OCP_SI_MOTIONVELOCITYPLANNER_PROXY_H
#define PARA_COM_GEN_OSS_SRV_MVP2OCP_SERVICE_INTERFACE_OCP_SI_MOTIONVELOCITYPLANNER_PROXY_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "ocp_si_motionvelocityplanner_common.h"
#include "para/com/proxy/proxy_interface.h"
/// @uptrace{SWS_CM_01005}
namespace oss
{
namespace srv
{
namespace MVP2OCP
{
/// @uptrace{SWS_CM_01007}
namespace proxy
{
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_dynamicobstaclestop
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_dynamicobstaclestop(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_dynamicobstaclestop() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_dynamicobstaclestop(const planning_planningfactors_dynamicobstaclestop& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_dynamicobstaclestop& operator=(const planning_planningfactors_dynamicobstaclestop& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_dynamicobstaclestop(planning_planningfactors_dynamicobstaclestop&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_dynamicobstaclestop& operator=(planning_planningfactors_dynamicobstaclestop&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_dynamicobstaclestop"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_outoflane
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_outoflane(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_outoflane() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_outoflane(const planning_planningfactors_outoflane& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_outoflane& operator=(const planning_planningfactors_outoflane& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_outoflane(planning_planningfactors_outoflane&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_outoflane& operator=(planning_planningfactors_outoflane&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_outoflane"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::diagnostic_msgs::msg::DiagnosticStatus;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::diagnostic_msgs::msg::DiagnosticStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::diagnostic_msgs::msg::DiagnosticStatus;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::diagnostic_msgs::msg::DiagnosticStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::diagnostic_msgs::msg::DiagnosticStatus;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::diagnostic_msgs::msg::DiagnosticStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::Float64StampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Float64Stamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::diagnostic_msgs::msg::DiagnosticStatus;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::DiagnosticStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::diagnostic_msgs::msg::DiagnosticStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_metric_msgs::msg::MetricArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MetricArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MetricArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_metric_msgs::msg::MetricArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Trajectory;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::MVP2OCP::TrajectoryEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::MVP2OCP::TrajectoryEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Trajectory_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_01015}
namespace methods
{
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::logging_demo::srv::ConfigLogger_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger_In _in_args_;
                _in_args_.req() = oss::type::logging_demo::srv::ConfigLogger_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output _out_args_;
            _out_args_.res = oss::type::logging_demo::srv::ConfigLogger_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::DescribeParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::DescribeParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::DescribeParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameterTypes_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameterTypes_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameterTypes_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::ListParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::ListParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::ListParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::autoware_motion_velocity_planner_node_universe::srv::LoadPlugin_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::autoware_motion_velocity_planner_node_universe::srv::LoadPlugin_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin_In _in_args_;
                _in_args_.req() = oss::type::autoware_motion_velocity_planner_node_universe::srv::LoadPlugin_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output _out_args_;
            _out_args_.res = oss::type::autoware_motion_velocity_planner_node_universe::srv::LoadPlugin_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::autoware_motion_velocity_planner_node_universe::srv::UnLoadPlugin_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::autoware_motion_velocity_planner_node_universe::srv::UnLoadPlugin_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin_In _in_args_;
                _in_args_.req() = oss::type::autoware_motion_velocity_planner_node_universe::srv::UnLoadPlugin_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output _out_args_;
            _out_args_.res = oss::type::autoware_motion_velocity_planner_node_universe::srv::UnLoadPlugin_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically& other) = delete;
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically& operator=(const planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically& operator=(planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParametersAtomically_Request_ConvertToDdsType(req);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(_in_args_, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically_Hash);
                dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParametersAtomically_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically"};
};
} /// namespace methods
/// @uptrace{SWS_CM_00004}
class OCP_SI_motionvelocityplannerProxy
{
public: 
    /// @uptrace{SWS_CM_00312}
    class HandleType
    {
    public:
        HandleType() = default;
        HandleType(ara::core::InstanceSpecifier instanceSpecifier, para::com::ServiceHandle service)
            : mInstanceSpecifier(std::move(instanceSpecifier))
            , mServiceHandle(service)
        {
        }
        ~HandleType() = default;
        /// @uptrace{SWS_CM_00317}
        HandleType(const HandleType& other) = default;
        HandleType& operator=(const HandleType& other) = default;
        /// @uptrace{SWS_CM_00318}
        HandleType(HandleType&& other) = default;
        HandleType& operator=(HandleType&& other) = default;
        /// @brief Return instance specifier
        ara::core::InstanceSpecifier GetInstanceSpecifier()
        {
            return mInstanceSpecifier;
        }
        /// @brief Return handle for bound service
        para::com::ServiceHandle GetServiceHandle()
        {
            return mServiceHandle;
        }
        /// @brief Is equal to operator
        inline bool operator==(const HandleType& other) const
        {
            return mInstanceSpecifier == other.mInstanceSpecifier && mServiceHandle == other.mServiceHandle;
        }
        /// @brief Less than operator
        inline bool operator<(const HandleType& other) const
        {
            return mServiceHandle.version < other.mServiceHandle.version;
        }
        
    private:
        ara::core::InstanceSpecifier mInstanceSpecifier{"undefined"};
        para::com::ServiceHandle mServiceHandle;
    };
    /// @brief Requests "FindService" message to Communication Management with callback
    /// @uptrace{SWS_CM_00623}
    static ara::core::Result<ara::com::FindServiceHandle> StartFindService(ara::com::FindServiceHandler<OCP_SI_motionvelocityplannerProxy::HandleType> handler, ara::core::InstanceSpecifier instanceSpec)
    {
        switch (para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyDdsInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyDdsInterface::StartFindService(instanceSpec, findCallback);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::FindServiceHandle>::FromError(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Send "FindService" message to Communication Management at once
    /// @uptrace{SWS_CM_00622}
    static ara::core::Result<ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType>> FindService(ara::core::InstanceSpecifier instanceSpec)
    {
        switch(para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto result = para::com::ProxyDdsInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::ServiceHandleContainer<OCP_SI_motionvelocityplannerProxy::HandleType>>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Constructor
    /// @note This function shall be called after processing of FindService/StartFindService was completed
    /// @uptrace{SWS_CM_00004, SWS_CM_00131}
    explicit OCP_SI_motionvelocityplannerProxy(HandleType& handle)
        : mHandle(handle)
        , mInterface(std::make_unique<para::com::ProxyInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , mDdsInterface(std::make_unique<para::com::ProxyDdsInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , planning_planningfactors_dynamicobstaclestop(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_outoflane(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
    {
        #ifdef PARA_DDS_IMPLEMENTATION
        if (mHandle.GetServiceHandle().protocol == para::com::ServiceProtocol::kDds)
        {
            mDdsInterface->CreateMethods<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Request, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Reply>();
            auto methodReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetMethodPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerMethod_planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically();
                                planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetMethodReturnHandler(methodReplyHandler);
            mDdsInterface->CreateFields<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerField_Request, dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerField_Reply>();
            auto fieldReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerField_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::MVP2OCP::OCP_SI_motionvelocityplannerField_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetFieldPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetFieldReturnHandler(fieldReplyHandler);
        }
        #endif /// PARA_DDS_IMPLEMENTATION
    }
    /// @brief Destructor
    /// @uptrace{SWS_CM_10446}
    ~OCP_SI_motionvelocityplannerProxy() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00136}
    OCP_SI_motionvelocityplannerProxy(OCP_SI_motionvelocityplannerProxy& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00136}
    OCP_SI_motionvelocityplannerProxy& operator=(const OCP_SI_motionvelocityplannerProxy& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00137}
    OCP_SI_motionvelocityplannerProxy(OCP_SI_motionvelocityplannerProxy&& other) noexcept
        : mHandle(std::move(other.mHandle))
        , mInterface(std::move(other.mInterface))
        , mDdsInterface(std::move(other.mDdsInterface))
        , planning_planningfactors_dynamicobstaclestop(std::move(other.planning_planningfactors_dynamicobstaclestop))
        , planning_planningfactors_outoflane(std::move(other.planning_planningfactors_outoflane))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters))
        , planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically(std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically))
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00137}
    OCP_SI_motionvelocityplannerProxy& operator=(OCP_SI_motionvelocityplannerProxy&& other) noexcept
    {
        mHandle = std::move(other.mHandle);
        mInterface = std::move(other.mInterface);
        mDdsInterface = std::move(other.mDdsInterface);
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        planning_planningfactors_dynamicobstaclestop = std::move(other.planning_planningfactors_dynamicobstaclestop);
        planning_planningfactors_outoflane = std::move(other.planning_planningfactors_outoflane);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters);
        planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically = std::move(other.planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically);
        other.mInterface.reset();
        other.mDdsInterface.reset();
        return *this;
    }
    /// @brief Stop the running StartFindService
    /// @uptrace{SWS_CM_00125}
    void StopFindService(ara::com::FindServiceHandle /*handle*/)
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return handle that is connected with service provider currently
    /// @uptrace{SWS_CM_10383}
    HandleType GetHandle() const
    {
        return mHandle;
    }
    
private:
    HandleType mHandle;
    std::unique_ptr<para::com::ProxyInterface> mInterface;
    std::unique_ptr<para::com::ProxyDdsInterface> mDdsInterface;
    
public:
    /// @brief - event, planning_planningfactors_dynamicobstaclestop
    events::planning_planningfactors_dynamicobstaclestop planning_planningfactors_dynamicobstaclestop;
    /// @brief - event, planning_planningfactors_outoflane
    events::planning_planningfactors_outoflane planning_planningfactors_outoflane;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstms;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiag;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markers;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstms;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiag;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimems;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiag;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimems;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiag;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkers;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwalls;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metrics;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkers;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwalls;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkers;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwalls;
    /// @brief - event, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory
    events::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectory;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_configlogger;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_describeparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_getparametertypes;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_listparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_loadplugin;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_service_unloadplugin;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically
    methods::planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically planning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_setparametersatomically;
};
} /// namespace proxy
} /// namespace MVP2OCP
} /// namespace srv
} /// namespace oss
#endif /// PARA_COM_GEN_oss_srv_MVP2OCP_SERVICE_INTERFACE_OCP_SI_MOTIONVELOCITYPLANNER_PROXY_H