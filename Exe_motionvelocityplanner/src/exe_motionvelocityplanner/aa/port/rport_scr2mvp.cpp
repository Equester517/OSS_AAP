///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : rport_scr2mvp.cpp
/// SOFTWARE COMPONENT NAME           : RPort_SCr2MVP
/// GENERATED DATE                    : 2025-12-08 15:30:48
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_motionvelocityplanner/aa/port/rport_scr2mvp.h"
 
namespace exe_motionvelocityplanner
{
namespace aa
{
namespace port
{
 
RPort_SCr2MVP::RPort_SCr2MVP()
    : m_logger(ara::log::CreateLogger("MVCL", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_found{false}
    , m_receiverclock{nullptr}
    , m_receiverlocalization_acceleration{nullptr}
    , m_receiverlocalization_kinematicstate{nullptr}
    , m_receivermap_vectormap{nullptr}
    , m_receiverperception_objectrecognition_objects{nullptr}
    , m_receiverperception_obstaclesegmentation_pointcloud{nullptr}
    , m_receiverperception_occupancygridmap_map{nullptr}
    , m_receiverperception_trafficlightrecognition_trafficsignals{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset{nullptr}
    , m_receiverplanning_scenarioplanning_maxvelocitydefault{nullptr}
    , m_receiversystem_operationmode_state{nullptr}
{
}
 
RPort_SCr2MVP::~RPort_SCr2MVP()
{
}
 
void RPort_SCr2MVP::Start()
{
    m_logger.LogVerbose() << "RPort_SCr2MVP::Start";
    
    // regist callback
    ara::core::InstanceSpecifier specifier{"Exe_motionvelocityplanner/AA/RPort_SCr2MVP"};
    auto handler = [this](ara::com::ServiceHandleContainer<oss::srv::SCr2MVP::proxy::MVP_SI_ServiceCreatorProxy::HandleType> handles,
                          ara::com::FindServiceHandle findHandle) {
        this->Find(handles, findHandle);
    };
    
    // find service
    auto find = oss::srv::SCr2MVP::proxy::MVP_SI_ServiceCreatorProxy::StartFindService(handler, specifier);
    if (find.HasValue())
    {
        m_logger.LogVerbose() << "RPort_SCr2MVP::Start::StartFindService";
    }
    else
    {
        m_logger.LogError() << "RPort_SCr2MVP::Start::StartFindService::" << find.Error().Message();
    }
    
    // run port
    m_running = true;
}
 
void RPort_SCr2MVP::Terminate()
{
    m_logger.LogVerbose() << "RPort_SCr2MVP::Terminate";
    
    // stop port
    m_running = false;
    
    // clear service proxy
    if (m_interface)
    {
        // stop subscribe
        StopSubscribeclock();
        StopSubscribelocalization_acceleration();
        StopSubscribelocalization_kinematicstate();
        StopSubscribemap_vectormap();
        StopSubscribeperception_objectrecognition_objects();
        StopSubscribeperception_obstaclesegmentation_pointcloud();
        StopSubscribeperception_occupancygridmap_map();
        StopSubscribeperception_trafficlightrecognition_trafficsignals();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset();
        StopSubscribeplanning_scenarioplanning_maxvelocitydefault();
        StopSubscribesystem_operationmode_state();
        
        // stop find service
        m_interface->StopFindService(*m_findHandle);
        m_found = false;
        
        m_logger.LogVerbose() << "RPort_SCr2MVP::Terminate::StopFindService";
    }
}
 
void RPort_SCr2MVP::Find(ara::com::ServiceHandleContainer<oss::srv::SCr2MVP::proxy::MVP_SI_ServiceCreatorProxy::HandleType> handles, ara::com::FindServiceHandle findHandle)
{
    // check finding handles
    if (handles.empty())
    {
        m_logger.LogVerbose() << "RPort_SCr2MVP::Find::Service Instances not found";
        return;
    }
    else
    {
        for (auto& handle : handles)
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Find::Searched Instance::ServiceId =" << 
                                     handle.GetServiceHandle().serviceId << 
                                     ", InstanceId =" << 
                                     handle.GetServiceHandle().instanceId;
        }
    }
    
    // create proxy
    if (m_interface)
    {
        m_logger.LogVerbose() << "RPort_SCr2MVP::Find::Proxy is already running";
    }
    else
    {
        m_logger.LogVerbose() << "RPort_SCr2MVP::Find::Using Instance::ServiceId =" << 
                                 handles[0].GetServiceHandle().serviceId << 
                                 ", InstanceId =" << 
                                 handles[0].GetServiceHandle().instanceId;
        m_interface = std::make_unique<oss::srv::SCr2MVP::proxy::MVP_SI_ServiceCreatorProxy>(handles[0]);
        m_findHandle = std::make_unique<ara::com::FindServiceHandle>(findHandle);
        m_found = true;
        
        // subscribe events
        Subscribeclock();
        Subscribelocalization_acceleration();
        Subscribelocalization_kinematicstate();
        Subscribemap_vectormap();
        Subscribeperception_objectrecognition_objects();
        Subscribeperception_obstaclesegmentation_pointcloud();
        Subscribeperception_occupancygridmap_map();
        Subscribeperception_trafficlightrecognition_trafficsignals();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset();
        Subscribeplanning_scenarioplanning_maxvelocitydefault();
        Subscribesystem_operationmode_state();
    }
}
 
void RPort_SCr2MVP::Subscribeclock()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverclock();
        
        // request subscribe
        auto subscribe = m_interface->clock.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeclock::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeclock::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeclock()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->clock.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeclock::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverclock()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventclockTriggered();
        };
        
        // regist callback
        auto callback = m_interface->clock.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverclock::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverclock::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventclockTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->clock.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->clock.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataclock(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventclock::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventclock::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventclockCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->clock.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->clock.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataclock(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventclock::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventclock::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataclock(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::clock::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverclock)
    {
        m_receiverclock(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerclock(std::function<void(const oss::srv::SCr2MVP::proxy::events::clock::SampleType&)> handler)
{
    m_receiverclock = handler;
}
 
void RPort_SCr2MVP::Subscribelocalization_acceleration()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverlocalization_acceleration();
        
        // request subscribe
        auto subscribe = m_interface->localization_acceleration.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribelocalization_acceleration::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribelocalization_acceleration::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribelocalization_acceleration()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->localization_acceleration.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribelocalization_acceleration::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverlocalization_acceleration()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventlocalization_accelerationTriggered();
        };
        
        // regist callback
        auto callback = m_interface->localization_acceleration.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverlocalization_acceleration::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverlocalization_acceleration::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventlocalization_accelerationTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->localization_acceleration.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->localization_acceleration.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDatalocalization_acceleration(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventlocalization_acceleration::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventlocalization_acceleration::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventlocalization_accelerationCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->localization_acceleration.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->localization_acceleration.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDatalocalization_acceleration(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventlocalization_acceleration::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventlocalization_acceleration::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDatalocalization_acceleration(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::localization_acceleration::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverlocalization_acceleration)
    {
        m_receiverlocalization_acceleration(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerlocalization_acceleration(std::function<void(const oss::srv::SCr2MVP::proxy::events::localization_acceleration::SampleType&)> handler)
{
    m_receiverlocalization_acceleration = handler;
}
 
void RPort_SCr2MVP::Subscribelocalization_kinematicstate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverlocalization_kinematicstate();
        
        // request subscribe
        auto subscribe = m_interface->localization_kinematicstate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribelocalization_kinematicstate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribelocalization_kinematicstate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribelocalization_kinematicstate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->localization_kinematicstate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribelocalization_kinematicstate::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverlocalization_kinematicstate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventlocalization_kinematicstateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->localization_kinematicstate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverlocalization_kinematicstate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverlocalization_kinematicstate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventlocalization_kinematicstateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->localization_kinematicstate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->localization_kinematicstate.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDatalocalization_kinematicstate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventlocalization_kinematicstate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventlocalization_kinematicstate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventlocalization_kinematicstateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->localization_kinematicstate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->localization_kinematicstate.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDatalocalization_kinematicstate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventlocalization_kinematicstate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventlocalization_kinematicstate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDatalocalization_kinematicstate(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::localization_kinematicstate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverlocalization_kinematicstate)
    {
        m_receiverlocalization_kinematicstate(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerlocalization_kinematicstate(std::function<void(const oss::srv::SCr2MVP::proxy::events::localization_kinematicstate::SampleType&)> handler)
{
    m_receiverlocalization_kinematicstate = handler;
}
 
void RPort_SCr2MVP::Subscribemap_vectormap()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceivermap_vectormap();
        
        // request subscribe
        auto subscribe = m_interface->map_vectormap.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribemap_vectormap::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribemap_vectormap::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribemap_vectormap()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->map_vectormap.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribemap_vectormap::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceivermap_vectormap()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventmap_vectormapTriggered();
        };
        
        // regist callback
        auto callback = m_interface->map_vectormap.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceivermap_vectormap::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceivermap_vectormap::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventmap_vectormapTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->map_vectormap.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->map_vectormap.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDatamap_vectormap(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventmap_vectormap::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventmap_vectormap::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventmap_vectormapCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->map_vectormap.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->map_vectormap.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDatamap_vectormap(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventmap_vectormap::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventmap_vectormap::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDatamap_vectormap(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::map_vectormap::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receivermap_vectormap)
    {
        m_receivermap_vectormap(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlermap_vectormap(std::function<void(const oss::srv::SCr2MVP::proxy::events::map_vectormap::SampleType&)> handler)
{
    m_receivermap_vectormap = handler;
}
 
void RPort_SCr2MVP::Subscribeperception_objectrecognition_objects()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverperception_objectrecognition_objects();
        
        // request subscribe
        auto subscribe = m_interface->perception_objectrecognition_objects.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeperception_objectrecognition_objects::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeperception_objectrecognition_objects::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeperception_objectrecognition_objects()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->perception_objectrecognition_objects.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeperception_objectrecognition_objects::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverperception_objectrecognition_objects()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventperception_objectrecognition_objectsTriggered();
        };
        
        // regist callback
        auto callback = m_interface->perception_objectrecognition_objects.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverperception_objectrecognition_objects::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverperception_objectrecognition_objects::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objectsTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->perception_objectrecognition_objects.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_objectrecognition_objects.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataperception_objectrecognition_objects(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objects::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objects::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objectsCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->perception_objectrecognition_objects.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_objectrecognition_objects.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataperception_objectrecognition_objects(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objects::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_objectrecognition_objects::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataperception_objectrecognition_objects(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::perception_objectrecognition_objects::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverperception_objectrecognition_objects)
    {
        m_receiverperception_objectrecognition_objects(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerperception_objectrecognition_objects(std::function<void(const oss::srv::SCr2MVP::proxy::events::perception_objectrecognition_objects::SampleType&)> handler)
{
    m_receiverperception_objectrecognition_objects = handler;
}
 
void RPort_SCr2MVP::Subscribeperception_obstaclesegmentation_pointcloud()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverperception_obstaclesegmentation_pointcloud();
        
        // request subscribe
        auto subscribe = m_interface->perception_obstaclesegmentation_pointcloud.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeperception_obstaclesegmentation_pointcloud::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeperception_obstaclesegmentation_pointcloud::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeperception_obstaclesegmentation_pointcloud()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->perception_obstaclesegmentation_pointcloud.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeperception_obstaclesegmentation_pointcloud::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverperception_obstaclesegmentation_pointcloud()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventperception_obstaclesegmentation_pointcloudTriggered();
        };
        
        // regist callback
        auto callback = m_interface->perception_obstaclesegmentation_pointcloud.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverperception_obstaclesegmentation_pointcloud::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverperception_obstaclesegmentation_pointcloud::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloudTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->perception_obstaclesegmentation_pointcloud.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_obstaclesegmentation_pointcloud.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataperception_obstaclesegmentation_pointcloud(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloud::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloud::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloudCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->perception_obstaclesegmentation_pointcloud.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_obstaclesegmentation_pointcloud.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataperception_obstaclesegmentation_pointcloud(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloud::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_obstaclesegmentation_pointcloud::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataperception_obstaclesegmentation_pointcloud(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::perception_obstaclesegmentation_pointcloud::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverperception_obstaclesegmentation_pointcloud)
    {
        m_receiverperception_obstaclesegmentation_pointcloud(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerperception_obstaclesegmentation_pointcloud(std::function<void(const oss::srv::SCr2MVP::proxy::events::perception_obstaclesegmentation_pointcloud::SampleType&)> handler)
{
    m_receiverperception_obstaclesegmentation_pointcloud = handler;
}
 
void RPort_SCr2MVP::Subscribeperception_occupancygridmap_map()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverperception_occupancygridmap_map();
        
        // request subscribe
        auto subscribe = m_interface->perception_occupancygridmap_map.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeperception_occupancygridmap_map::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeperception_occupancygridmap_map::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeperception_occupancygridmap_map()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->perception_occupancygridmap_map.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeperception_occupancygridmap_map::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverperception_occupancygridmap_map()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventperception_occupancygridmap_mapTriggered();
        };
        
        // regist callback
        auto callback = m_interface->perception_occupancygridmap_map.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverperception_occupancygridmap_map::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverperception_occupancygridmap_map::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_mapTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->perception_occupancygridmap_map.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_occupancygridmap_map.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataperception_occupancygridmap_map(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_map::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_map::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_mapCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->perception_occupancygridmap_map.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_occupancygridmap_map.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataperception_occupancygridmap_map(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_map::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_occupancygridmap_map::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataperception_occupancygridmap_map(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::perception_occupancygridmap_map::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverperception_occupancygridmap_map)
    {
        m_receiverperception_occupancygridmap_map(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerperception_occupancygridmap_map(std::function<void(const oss::srv::SCr2MVP::proxy::events::perception_occupancygridmap_map::SampleType&)> handler)
{
    m_receiverperception_occupancygridmap_map = handler;
}
 
void RPort_SCr2MVP::Subscribeperception_trafficlightrecognition_trafficsignals()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverperception_trafficlightrecognition_trafficsignals();
        
        // request subscribe
        auto subscribe = m_interface->perception_trafficlightrecognition_trafficsignals.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeperception_trafficlightrecognition_trafficsignals::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeperception_trafficlightrecognition_trafficsignals::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeperception_trafficlightrecognition_trafficsignals()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->perception_trafficlightrecognition_trafficsignals.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeperception_trafficlightrecognition_trafficsignals::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverperception_trafficlightrecognition_trafficsignals()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventperception_trafficlightrecognition_trafficsignalsTriggered();
        };
        
        // regist callback
        auto callback = m_interface->perception_trafficlightrecognition_trafficsignals.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverperception_trafficlightrecognition_trafficsignals::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverperception_trafficlightrecognition_trafficsignals::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignalsTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->perception_trafficlightrecognition_trafficsignals.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_trafficlightrecognition_trafficsignals.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataperception_trafficlightrecognition_trafficsignals(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignals::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignals::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignalsCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->perception_trafficlightrecognition_trafficsignals.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->perception_trafficlightrecognition_trafficsignals.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataperception_trafficlightrecognition_trafficsignals(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignals::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventperception_trafficlightrecognition_trafficsignals::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataperception_trafficlightrecognition_trafficsignals(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::perception_trafficlightrecognition_trafficsignals::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverperception_trafficlightrecognition_trafficsignals)
    {
        m_receiverperception_trafficlightrecognition_trafficsignals(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerperception_trafficlightrecognition_trafficsignals(std::function<void(const oss::srv::SCr2MVP::proxy::events::perception_trafficlightrecognition_trafficsignals::SampleType&)> handler)
{
    m_receiverperception_trafficlightrecognition_trafficsignals = handler;
}
 
void RPort_SCr2MVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset(std::function<void(const oss::srv::SCr2MVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffset = handler;
}
 
void RPort_SCr2MVP::Subscribeplanning_scenarioplanning_maxvelocitydefault()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_maxvelocitydefault();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_maxvelocitydefault.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribeplanning_scenarioplanning_maxvelocitydefault::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribeplanning_scenarioplanning_maxvelocitydefault::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribeplanning_scenarioplanning_maxvelocitydefault()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_maxvelocitydefault.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribeplanning_scenarioplanning_maxvelocitydefault::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_maxvelocitydefault()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_maxvelocitydefaultTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_maxvelocitydefault.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_maxvelocitydefault::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiverplanning_scenarioplanning_maxvelocitydefault::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefaultTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_maxvelocitydefault.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_maxvelocitydefault.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDataplanning_scenarioplanning_maxvelocitydefault(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefault::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefault::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefaultCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_maxvelocitydefault.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_maxvelocitydefault.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDataplanning_scenarioplanning_maxvelocitydefault(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefault::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventplanning_scenarioplanning_maxvelocitydefault::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDataplanning_scenarioplanning_maxvelocitydefault(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::planning_scenarioplanning_maxvelocitydefault::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_maxvelocitydefault)
    {
        m_receiverplanning_scenarioplanning_maxvelocitydefault(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlerplanning_scenarioplanning_maxvelocitydefault(std::function<void(const oss::srv::SCr2MVP::proxy::events::planning_scenarioplanning_maxvelocitydefault::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_maxvelocitydefault = handler;
}
 
void RPort_SCr2MVP::Subscribesystem_operationmode_state()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiversystem_operationmode_state();
        
        // request subscribe
        auto subscribe = m_interface->system_operationmode_state.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::Subscribesystem_operationmode_state::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::Subscribesystem_operationmode_state::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::StopSubscribesystem_operationmode_state()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->system_operationmode_state.Unsubscribe();
        m_logger.LogVerbose() << "RPort_SCr2MVP::StopSubscribesystem_operationmode_state::Unsubscribed";
    }
}
 
void RPort_SCr2MVP::RegistReceiversystem_operationmode_state()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventsystem_operationmode_stateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->system_operationmode_state.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_SCr2MVP::RegistReceiversystem_operationmode_state::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_SCr2MVP::RegistReceiversystem_operationmode_state::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventsystem_operationmode_stateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->system_operationmode_state.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->system_operationmode_state.GetNewSamples([&](auto samplePtr) {
                RPort_SCr2MVP::ReadDatasystem_operationmode_state(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventsystem_operationmode_state::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventsystem_operationmode_state::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_SCr2MVP::ReceiveEventsystem_operationmode_stateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->system_operationmode_state.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->system_operationmode_state.GetNewSamples([&](auto samplePtr) {
                    RPort_SCr2MVP::ReadDatasystem_operationmode_state(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_SCr2MVP::ReceiveEventsystem_operationmode_state::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_SCr2MVP::ReceiveEventsystem_operationmode_state::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_SCr2MVP::ReadDatasystem_operationmode_state(ara::com::SamplePtr<oss::srv::SCr2MVP::proxy::events::system_operationmode_state::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiversystem_operationmode_state)
    {
        m_receiversystem_operationmode_state(data);
    }
}
 
void RPort_SCr2MVP::RegistEventHandlersystem_operationmode_state(std::function<void(const oss::srv::SCr2MVP::proxy::events::system_operationmode_state::SampleType&)> handler)
{
    m_receiversystem_operationmode_state = handler;
}
 
} /// namespace port
} /// namespace aa
} /// namespace exe_motionvelocityplanner
 
/// EOF