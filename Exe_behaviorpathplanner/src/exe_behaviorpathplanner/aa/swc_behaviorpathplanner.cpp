///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_behaviorpathplanner.cpp
/// SOFTWARE COMPONENT NAME           : Swc_behaviorpathplanner
/// GENERATED DATE                    : 2025-12-08 15:30:47
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_behaviorpathplanner/aa/swc_behaviorpathplanner.h"
#include "behavior_path_planner_runner.hpp"
#include "ros2/ros_autosar_adapter.hpp"

#include <chrono>
#include <filesystem>
#include <thread>
#include <vector>
 
namespace exe_behaviorpathplanner
{
namespace aa
{
 
Swc_behaviorpathplanner::Swc_behaviorpathplanner()
    : m_logger(ara::log::CreateLogger("BHPP", "SWC", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_workers(117)
{
}
 
Swc_behaviorpathplanner::~Swc_behaviorpathplanner()
{
}
 
bool Swc_behaviorpathplanner::Initialize()
{
    m_logger.LogVerbose() << "Swc_behaviorpathplanner::Initialize";
    
    bool init = true;
    
    m_PPort_BPP2BVP = std::make_unique<exe_behaviorpathplanner::aa::port::PPort_BPP2BVP>();
    m_PPort_BPP2MP = std::make_unique<exe_behaviorpathplanner::aa::port::PPort_BPP2MP>();
    m_RPort_MP2BPP = std::make_unique<exe_behaviorpathplanner::aa::port::RPort_MP2BPP>();
    m_RPort_SCr2BPP = std::make_unique<exe_behaviorpathplanner::aa::port::RPort_SCr2BPP>();
    
    // Register callback for route from MissionPlanner
    m_RPort_MP2BPP->RegistEventHandlerplanning_missionplanning_route(
        [this](const oss::srv::MP2BPP::proxy::events::planning_missionplanning_route::SampleType& route) {
            auto converted_route = ros_autosar_adapter::FromOssLaneletRoute(route);
            std::lock_guard<std::mutex> lock(m_state_mutex);
            m_route = std::move(converted_route);
            m_route_received.store(true);
            m_logger.LogInfo() << "Swc_behaviorpathplanner::Received route from MissionPlanner with " << route.segments.size() << " segments";
        });
    
    // Register callback for odometry from ServiceCreator
    m_RPort_SCr2BPP->RegistEventHandlerlocalization_kinematicstate(
        [this](const oss::srv::SCr2BPP::proxy::events::localization_kinematicstate::SampleType& odom) {
            auto converted_odom = ros_autosar_adapter::FromOssOdometry(odom);
            std::lock_guard<std::mutex> lock(m_state_mutex);
            m_odometry = std::move(converted_odom);
            m_odometry_received.store(true);
        });
    
    return init;
}
 
void Swc_behaviorpathplanner::Start()
{
    m_logger.LogVerbose() << "Swc_behaviorpathplanner::Start";
    
    m_PPort_BPP2BVP->Start();
    m_PPort_BPP2MP->Start();
    m_RPort_MP2BPP->Start();
    m_RPort_SCr2BPP->Start();
    
    // Start BehaviorPathPlanner runner thread
    m_bpp_running.store(true);
    
    // Resolve OSM path with environment override and multiple fallbacks
    namespace fs = std::filesystem;
    const char* env_osm = std::getenv("BPP_OSM_PATH");

    const std::string repo_default = "Exe_behaviorpathplanner/OSS_BPP/sample-map-planning/lanelet2_map.osm";

    std::vector<std::string> osm_candidates;
    if (env_osm && *env_osm) {
        osm_candidates.emplace_back(env_osm);
    }
#ifdef BPP_OSM_DEFAULT
    osm_candidates.emplace_back(BPP_OSM_DEFAULT);
#endif
    osm_candidates.emplace_back(repo_default);
    osm_candidates.emplace_back("../" + repo_default); // common when running from build/install/bin
    osm_candidates.emplace_back("/home/katech/AAP/OSS_AAP/" + repo_default); // absolute repo root
    osm_candidates.emplace_back("/home/katech/AAP/Exe_behaviorpathplanner/OSS_BPP/sample-map-planning/lanelet2_map.osm"); // legacy absolute path

    std::string osm_path;
    for (const auto& candidate : osm_candidates) {
        if (fs::exists(candidate)) {
            osm_path = candidate;
            break;
        }
    }

    if (osm_path.empty()) {
        osm_path = repo_default; // fallback to something deterministic
        m_logger.LogInfo() << "Swc_behaviorpathplanner::OSM file not found in candidates; using default path (may fail): " << osm_path.c_str();
    } else {
        m_logger.LogInfo() << "Swc_behaviorpathplanner::Using OSM map: " << osm_path.c_str();
    }
    
    m_bpp_threads.emplace_back([this, osm_path]() {
        m_logger.LogInfo() << "Swc_behaviorpathplanner::BPP runner thread started";
        
        while (m_bpp_running.load()) {
            // Wait for both route and odometry to be received
            if (!m_route_received.load() || !m_odometry_received.load()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }
            
            // Copy shared state
            autoware::common_types::LaneletRoute route_copy;
            autoware::common_types::Odometry odom_copy;
            {
                std::lock_guard<std::mutex> lock(m_state_mutex);
                route_copy = m_route;
                odom_copy = m_odometry;
            }   
            
            m_logger.LogInfo() << "Swc_behaviorpathplanner::Running BPP with route and odometry";
            
            // Run BehaviorPathPlanner
            auto maybe_path = behavior_path_planner_runner::run_once(osm_path, route_copy, odom_copy);
                    
            if (maybe_path) {
                m_logger.LogInfo() << "Swc_behaviorpathplanner::Path generated with " << maybe_path->points.size() << " points";
                
                // Send path to BehaviorVelocityPlanner
                if (m_PPort_BPP2BVP) {
                    const auto path_msg = ros_autosar_adapter::ToOssPathWithLaneId(*maybe_path);
                    m_PPort_BPP2BVP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneidTriggered(path_msg);
                    m_logger.LogInfo() << "Swc_behaviorpathplanner::Path sent to BehaviorVelocityPlanner";
                }
            } else {
                m_logger.LogError() << "Swc_behaviorpathplanner::Failed to generate path";
            }
            
            // Wait before next iteration
            std::this_thread::sleep_for(std::chrono::milliseconds(5000));
        }
        
        m_logger.LogInfo() << "Swc_behaviorpathplanner::BPP runner thread finished";
    });
}
 
void Swc_behaviorpathplanner::Terminate()
{
    m_logger.LogVerbose() << "Swc_behaviorpathplanner::Terminate";
    
    // stop running
    m_running = false;
    
    // Stop BPP runner thread
    m_bpp_running.store(false);
    for (auto& t : m_bpp_threads) {
        if (t.joinable()) {
            t.join();
        }
    }
    m_bpp_threads.clear();
    
    m_PPort_BPP2BVP->Terminate();
    m_PPort_BPP2MP->Terminate();
    m_RPort_MP2BPP->Terminate();
    m_RPort_SCr2BPP->Terminate();
}
 
void Swc_behaviorpathplanner::Run()
{
    m_logger.LogVerbose() << "Swc_behaviorpathplanner::Run";
    
    // start running
    m_running = true;
    
    // m_workers.Async([this] { m_PPort_BPP2BVP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneidCyclic(); });
    // Note: route uses triggered callback, not cyclic polling
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventclockCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventlocalization_accelerationCyclic(); });
    // Note: kinematic_state uses triggered callback, not cyclic polling
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_RPort_SCr2BPP->ReceiveEventsystem_operationmode_stateCyclic(); });

    // Sleep loop: repeat 1 second sleep
    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
    }

    m_workers.Wait();
}
 
} /// namespace aa
} /// namespace exe_behaviorpathplanner
