///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_pathoptimizer.cpp
/// SOFTWARE COMPONENT NAME           : Swc_pathoptimizer
/// GENERATED DATE                    : 2025-12-05 12:02:34
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_pathoptimizer/aa/swc_pathoptimizer.h"
#include "ros2/ros_autosar_adapter.hpp"
#include "path_optimizer/path_optimizer_runner.hpp"
#include <chrono>
#include <mutex>
#include <thread>

namespace exe_pathoptimizer
{
namespace aa
{

namespace detail {
    // Convert PathWithLaneId (ROS2 format) to path_optimizer::PathPoint vector
    std::vector<autoware::path_optimizer::PathPoint> convertToPathPoints(
            const autoware::common_types::PathWithLaneId& path_with_lane_id)
  {
    std::vector<autoware::path_optimizer::PathPoint> points;
    for (const auto& pt : path_with_lane_id.points) {
      autoware::path_optimizer::PathPoint opt_point;
            opt_point.pose.position.x = pt.point.pose.position.x;
            opt_point.pose.position.y = pt.point.pose.position.y;
            opt_point.pose.position.z = pt.point.pose.position.z;
            opt_point.pose.orientation.x = pt.point.pose.orientation.x;
            opt_point.pose.orientation.y = pt.point.pose.orientation.y;
            opt_point.pose.orientation.z = pt.point.pose.orientation.z;
            opt_point.pose.orientation.w = pt.point.pose.orientation.w;
            opt_point.longitudinal_velocity_mps = pt.point.longitudinal_velocity_mps;
            opt_point.lateral_velocity_mps = pt.point.lateral_velocity_mps;
            opt_point.heading_rate_rps = pt.point.heading_rate_rps;
      points.push_back(opt_point);
    }
    return points;
  }

  // Convert Odometry to Pose and extract velocity
  autoware::path_optimizer::Pose extractPose(const autoware::common_types::Odometry&
     odom)
  {
    autoware::path_optimizer::Pose pose;
    pose.position.x = odom.pose.pose.position.x;
    pose.position.y = odom.pose.pose.position.y;
    pose.position.z = odom.pose.pose.position.z;
    pose.orientation.x = odom.pose.pose.orientation.x;
    pose.orientation.y = odom.pose.pose.orientation.y;
    pose.orientation.z = odom.pose.pose.orientation.z;
    pose.orientation.w = odom.pose.pose.orientation.w;
    return pose;
  }

    double extractVelocity(const autoware::common_types::Odometry& odom)
    {
        return odom.twist.linear.x;
    }
}

Swc_pathoptimizer::Swc_pathoptimizer()
    : m_logger(ara::log::CreateLogger("PTOP", "SWC", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_workers(29)
{
    unsigned hc = std::thread::hardware_concurrency();
    m_path_opt_thread_count = (hc == 0 ? 1u : hc);
}

Swc_pathoptimizer::~Swc_pathoptimizer()
{
}

bool Swc_pathoptimizer::Initialize()
{
    m_logger.LogVerbose() << "Swc_pathoptimizer::Initialize";
    
    bool init = true;
    
    // m_PPort_PO2MVP = std::make_unique<exe_pathoptimizer::aa::port::PPort_PO2MVP>();
    // m_PPort_PO2PE = std::make_unique<exe_pathoptimizer::aa::port::PPort_PO2PE>();
    m_RPort_EBS2PO = std::make_unique<exe_pathoptimizer::aa::port::RPort_EBS2PO>();
    m_RPort_SCr2PO = std::make_unique<exe_pathoptimizer::aa::port::RPort_SCr2PO>();
    
    // Register callback for path from ElasticBandSmoother
    m_RPort_EBS2PO->RegistEventHandlerplanning_scenarioplanning_lanedriving_motionplanning_pathsmoother_path(
        [this](const oss::srv::EBS2PO::proxy::events::planning_scenarioplanning_lanedriving_motionplanning_pathsmoother_path::SampleType& path) {
            std::lock_guard<std::mutex> lock(m_state_mutex);
            m_path_points = ros_autosar_adapter::FromOssPath(path);
            m_path_received = true;
            m_logger.LogInfo() << "Swc_pathoptimizer::Received path from EBS with " << m_path_points.points.size() << " points";
        });
    
    // Register callback for odometry from ServiceCreator
    m_RPort_SCr2PO->RegistEventHandlerlocalization_kinematicstate(
        [this](const oss::srv::SCr2PO::proxy::events::localization_kinematicstate::SampleType& odom) {
            std::lock_guard<std::mutex> lock(m_state_mutex);
            m_odometry = ros_autosar_adapter::FromOssOdometry(odom);
            m_odometry_received = true;
            // m_logger.LogInfo() << "Swc_pathoptimizer::Received odometry from ServiceCreator";
        });
    
    return init;
}

void Swc_pathoptimizer::Start()
{
    m_logger.LogVerbose() << "Swc_pathoptimizer::Start";
    
    // m_PPort_PO2MVP->Start();
    // m_PPort_PO2PE->Start();
    m_RPort_EBS2PO->Start();
    m_RPort_SCr2PO->Start();

    // Start path optimizer runner threads
    m_path_opt_running.store(true);
    for (unsigned i = 0; i < m_path_opt_thread_count; ++i)
    {
        m_path_opt_threads.emplace_back([this]() {
            while (m_path_opt_running.load())
            {
                // Check if both path and odometry are received
                bool path_ready = false;
                autoware::common_types::PathWithLaneId path_copy;
                autoware::common_types::Odometry odom_copy;
                
                {
                    std::lock_guard<std::mutex> lock(m_state_mutex);
                    if (m_path_received && m_odometry_received) {
                        path_ready = true;
                        path_copy = m_path_points;
                        odom_copy = m_odometry;
                    }
                }
                
                if (path_ready) {
                    // Convert to optimizer format and run
                    auto path_points = detail::convertToPathPoints(path_copy);
                    auto ego_pose = detail::extractPose(odom_copy);
                    double ego_velocity = detail::extractVelocity(odom_copy);
                    
                    // Convert bounds from common_types::PointXYZ to path_optimizer::Point
                    std::vector<autoware::path_optimizer::Point> left_bound, right_bound;
                    for (const auto& pt : path_copy.left_bound) {
                        autoware::path_optimizer::Point p;
                        p.x = pt.x; p.y = pt.y; p.z = pt.z;
                        left_bound.push_back(p);
                    }
                    for (const auto& pt : path_copy.right_bound) {
                        autoware::path_optimizer::Point p;
                        p.x = pt.x; p.y = pt.y; p.z = pt.z;
                        right_bound.push_back(p);
                    }
                    
                    // m_logger.LogInfo() << "Swc_pathoptimizer::Running path optimizer with " << path_points.size() 
                    //                   << " points, vel=" << ego_velocity << " m/s, bounds=(" 
                    //                   << left_bound.size() << "," << right_bound.size() << ")";
                    
                    path_optimizer_runner::run_once(
                        path_points,
                        ego_pose,
                        ego_velocity,
                        left_bound,
                        right_bound
                    );
                } else {
                    std::this_thread::sleep_for(std::chrono::seconds(5));
                }
            }
        });
    }
}

void Swc_pathoptimizer::Terminate()
{
    m_logger.LogVerbose() << "Swc_pathoptimizer::Terminate";
    
    // stop running
    m_running = false;

    // stop path optimizer runner threads
    m_path_opt_running.store(false);
    for (auto &t : m_path_opt_threads)
    {
        if (t.joinable())
            t.join();
    }
    m_path_opt_threads.clear();
    
    // m_PPort_PO2MVP->Terminate();
    // m_PPort_PO2PE->Terminate();
    m_RPort_EBS2PO->Terminate();
    m_RPort_SCr2PO->Terminate();
}

void Swc_pathoptimizer::Run()
{
    m_logger.LogVerbose() << "Swc_pathoptimizer::Run";
    
    // start running
    m_running = true;
    
    m_workers.Async([this] { m_RPort_EBS2PO->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_pathsmoother_pathCyclic(); });
    m_workers.Async([this] { m_RPort_SCr2PO->ReceiveEventlocalization_kinematicstateCyclic(); });
    
    m_workers.Wait();
}

} /// namespace aa
} /// namespace exe_pathoptimizer
