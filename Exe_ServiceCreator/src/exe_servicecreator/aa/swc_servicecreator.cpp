///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_servicecreator.cpp
/// SOFTWARE COMPONENT NAME           : Swc_ServiceCreator
/// GENERATED DATE                    : 2025-12-05 12:02:33
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_servicecreator/aa/swc_servicecreator.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>
#include <thread>
#include <chrono>
#include <string>
#include <unordered_map>
 
// Forward declaration for strict-order JSONL serialization
static std::string SerializeTrajectoryJsonLine(const nlohmann::ordered_json &message, std::int64_t timestamp_ns);

// Definition for strict-order JSONL serialization (global scope)
static std::string SerializeTrajectoryJsonLine(const nlohmann::ordered_json &message, std::int64_t timestamp_ns)
{
    std::string line;
    line.reserve(256 + message.dump().size());
    line += "{\"topic\":\"/planning/scenario_planning/trajectory\",";
    line += "\"timestamp\":";
    line += std::to_string(timestamp_ns);
    line += ",\"message\":";
    line += message.dump();
    line += "}";
    return line;
}

namespace exe_servicecreator
{
namespace aa
{
 
Swc_ServiceCreator::Swc_ServiceCreator()
    : m_logger(ara::log::CreateLogger("SECR", "SWC", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_workers(177)
    , m_socket_fd{-1}
    , m_socket_running{false}
    , m_socket_connected{false}
    , m_scenario_active{false}
{
}
 
Swc_ServiceCreator::~Swc_ServiceCreator()
{
}
 
bool Swc_ServiceCreator::Initialize()
{
    m_logger.LogVerbose() << "Swc_ServiceCreator::Initialize";
    
    bool init = true;
    
    m_PPort_SCr2EBS = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2EBS>();
    m_PPort_SCr2MP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2MP>();
    m_PPort_SCr2PO = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2PO>();
    m_RPort_MP2SCr = std::make_unique<exe_servicecreator::aa::port::RPort_MP2SCr>();
    m_PPort_SCr2BPP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2BPP>();
    m_PPort_SCr2OCP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2OCP>();
    // RPort to receive from OCP (scenario, trajectory)
    m_RPort_OCP2SCr = std::make_unique<exe_servicecreator::aa::port::RPort_OCP2SCr>();

    // m_PPort_SCr2BVP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2BVP>();
    // m_PPort_SCr2CG = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2CG>();
    // m_PPort_SCr2EVLS = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2EVLS>();
    // m_PPort_SCr2FP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2FP>();
    // m_PPort_SCr2GPV = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2GPV>();
    // m_PPort_SCr2MVP = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2MVP>();
    // m_PPort_SCr2PE = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2PE>();
    // m_PPort_SCr2PV = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2PV>();
    // m_PPort_SCr2RS = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2RS>();
    // m_PPort_SCr2SS = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2SS>();
    // m_PPort_SCr2VS = std::make_unique<exe_servicecreator::aa::port::PPort_SCr2VS>();
    // m_RPort_PV2SCr = std::make_unique<exe_servicecreator::aa::port::RPort_PV2SCr>();
    
    // put your code for initialization
    
    return init;
}
 
void Swc_ServiceCreator::Start()
{
    m_logger.LogVerbose() << "Swc_ServiceCreator::Start";
    
    m_PPort_SCr2EBS->Start();
    m_PPort_SCr2MP->Start();
    m_PPort_SCr2PO->Start();
    m_RPort_MP2SCr->Start();
    m_PPort_SCr2BPP->Start();
    m_PPort_SCr2OCP->Start();
    m_RPort_OCP2SCr->Start();

    // Subscribe handlers to receive scenario and trajectory from OCP
    m_RPort_OCP2SCr->RegistEventHandlerscenario([this](const std::uint8_t& scenario_id){
        m_logger.LogInfo() << "Swc_ServiceCreator::Received scenario ID from OCP: " << static_cast<int>(scenario_id);
        {
            std::lock_guard<std::mutex> lock(m_jsonl_mutex);
            if (m_scenario_active && scenario_id == m_current_scenario_id) {
                // Treat as completion signal
                if (m_jsonl_output_file && m_jsonl_output_file->is_open()) {
                    m_jsonl_output_file->close();
                }
                m_scenario_active = false;
                std::string msg = "Scenario #" + std::to_string(scenario_id) + " Completed";
                SendSocketMessage(msg);
                m_logger.LogInfo() << "Swc_ServiceCreator::Sent completion message: " << msg.c_str();
            } else {
                // New scenario start (or different scenario while one active)
                m_current_scenario_id = scenario_id;
                auto &count = m_scenario_counts[scenario_id];
                count += 1;
                // Close previous file if open
                if (m_jsonl_output_file && m_jsonl_output_file->is_open()) {
                    m_jsonl_output_file->close();
                }
                // Open new JSONL file with sequence suffix
                std::string output_path = "../../../../../output/Scenario_" + std::to_string(scenario_id)
                                          + "_" + std::to_string(count) + ".jsonl";
                m_jsonl_output_file = std::make_unique<std::ofstream>(output_path, std::ios::app);
                if (m_jsonl_output_file->is_open()) {
                    m_scenario_active = true;
                    m_logger.LogInfo() << "Swc_ServiceCreator::Opened output JSONL file: " << output_path.c_str();
                } else {
                    m_logger.LogError() << "Swc_ServiceCreator::Failed to open JSONL file: " << output_path.c_str();
                }
            }
        }
    });
    m_RPort_OCP2SCr->RegistEventHandlertrajectory([this](const oss::srv::OCP2SCr::proxy::events::trajectory::SampleType& traj){
        m_logger.LogInfo() << "Swc_ServiceCreator::Received trajectory from OCP, points: " << traj.points.size();
        {
            std::lock_guard<std::mutex> lock(m_jsonl_mutex);
            if (m_jsonl_output_file && m_jsonl_output_file->is_open()) {
                try {
                    // Convert trajectory to JSON and write to JSONL file (strict key order)
                    nlohmann::ordered_json json_line = trajectoryToJson(traj);
                    // Build strict-order line: topic, timestamp, message
                    const std::int64_t kNanosecondsInSecond = 1'000'000'000;
                    std::int64_t ts_ns = static_cast<std::int64_t>(traj.header.stamp.sec) * kNanosecondsInSecond
                                         + static_cast<std::int64_t>(traj.header.stamp.nanosec);
                    std::string line = SerializeTrajectoryJsonLine(json_line["message"], ts_ns);
                    *m_jsonl_output_file << line << "\n";
                    m_jsonl_output_file->flush();
                    m_logger.LogInfo() << "Swc_ServiceCreator::Wrote trajectory with " << traj.points.size() << " points to JSONL";
                } catch (const std::exception& e) {
                    m_logger.LogError() << "Swc_ServiceCreator::Error writing trajectory to JSONL: " << e.what();
                }
            } else {
                m_logger.LogWarn() << "Swc_ServiceCreator::Output JSONL file not open, ignoring trajectory";
            }
        }
    });
    
    // Start background connection loop (non-blocking)
    m_running = true;
    m_socket_running = true;
    if (!m_socket_conn_thread.joinable()) {
        m_socket_conn_thread = std::thread([this]() { SocketConnectLoop(); });
    }
    
    // Send test goal pose to MissionPlanner via setwaypointroute method
    // TODO: Replace with socket-based input later
    std::thread([this]() {
        // Wait for service to be discovered
        std::this_thread::sleep_for(std::chrono::seconds(2));
        
        oss::type::tier4_planning_msgs::srv::SetWaypointRoute_Request request;
        
        // Set test goal pose (example coordinates)
        request.goal_pose.position.x = 3745.5;
        request.goal_pose.position.y = 73751.9;
        request.goal_pose.position.z = 0.0;
        
        request.goal_pose.orientation.x = 0.0;
        request.goal_pose.orientation.y = 0.0;
        request.goal_pose.orientation.z = 0.0;
        request.goal_pose.orientation.w = 1.0;
        
        m_logger.LogInfo() << "Swc_ServiceCreator::Sending test goal pose to MissionPlanner";
        m_RPort_MP2SCr->Requestplanning_missionplanning_missionplanner_setwaypointroute(request);


        
    }).detach();

    // m_PPort_SCr2BVP->Start();
    // m_PPort_SCr2CG->Start();
    // m_PPort_SCr2EVLS->Start();
    // m_PPort_SCr2FP->Start();
    // m_PPort_SCr2GPV->Start();
    // m_PPort_SCr2MVP->Start();
    // m_PPort_SCr2PE->Start();
    // m_PPort_SCr2PV->Start();
    // m_PPort_SCr2RS->Start();
    // m_PPort_SCr2SS->Start();
    // m_PPort_SCr2VS->Start();
    // m_RPort_PV2SCr->Start();
}
 
void Swc_ServiceCreator::Terminate()
{
    m_logger.LogVerbose() << "Swc_ServiceCreator::Terminate";
    
    // Close socket connection
    CloseSocketConnection();
    m_socket_running = false;
    if (m_socket_conn_thread.joinable()) {
        m_socket_conn_thread.join();
    }
    if (m_socket_thread.joinable()) {
        m_socket_thread.join();
    }
    
    // stop running
    m_running = false;
    
    m_PPort_SCr2EBS->Terminate();
    m_PPort_SCr2MP->Terminate();
    m_PPort_SCr2PO->Terminate();
    m_RPort_MP2SCr->Terminate();
    m_PPort_SCr2BPP->Terminate();
    
    // m_PPort_SCr2BVP->Terminate();
    // m_PPort_SCr2CG->Terminate();
    // m_PPort_SCr2EVLS->Terminate();
    // m_PPort_SCr2FP->Terminate();
    // m_PPort_SCr2GPV->Terminate();
    // m_PPort_SCr2MVP->Terminate();
    // m_PPort_SCr2OCP->Terminate();
    // m_PPort_SCr2PE->Terminate();
    // m_PPort_SCr2PV->Terminate();
    // m_PPort_SCr2RS->Terminate();
    // m_PPort_SCr2SS->Terminate();
    // m_PPort_SCr2VS->Terminate();
    // m_RPort_PV2SCr->Terminate();
}
 
void Swc_ServiceCreator::Run()
{
    m_logger.LogVerbose() << "Swc_ServiceCreator::Run";

    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EBS->SendEventsystem_operationmode_stateCyclic(); });

    m_workers.Async([this] { m_PPort_SCr2MP->SendEventlocalization_kinematicstateCyclic(); });
    
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PO->SendEventsystem_operationmode_stateCyclic(); });

    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventlocalization_kinematicstateCyclic(); }); 

    // Receive scenario/trajectory from OCP cyclic handlers
    // m_workers.Async([this] { m_RPort_OCP2SCr->ReceiveEventscenarioCyclic(); });
    // m_workers.Async([this] { m_RPort_OCP2SCr->ReceiveEventtrajectoryCyclic(); });

    
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BPP->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2BVP->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2CG->SendEventsystem_operationmode_stateCyclic(); });
   
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2EVLS->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2FP->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2GPV->SendEventsystem_operationmode_stateCyclic(); });

    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2MVP->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2OCP->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PE->SendEventsystem_operationmode_stateCyclic(); });
    
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2PV->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2RS->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2SS->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventclockCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventlocalization_accelerationCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventlocalization_kinematicstateCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventmap_vectormapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventperception_objectrecognition_objectsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventperception_obstaclesegmentation_pointcloudCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventperception_occupancygridmap_mapCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
    // m_workers.Async([this] { m_PPort_SCr2VS->SendEventsystem_operationmode_stateCyclic(); });
    // m_workers.Async([this] { m_RPort_PV2SCr->ReceiveEventplanning_scenarioplanning_trajectoryCyclic(); });
    
    m_workers.Wait();
}

bool Swc_ServiceCreator::ConnectToSocketServer()
{
    m_logger.LogInfo() << "Swc_ServiceCreator::Attempting to connect to " << SOCKET_SERVER_IP << ":" << SOCKET_SERVER_PORT;
    
    // Create socket
    m_socket_fd = ::socket(AF_INET, SOCK_STREAM, 0);
    if (m_socket_fd < 0) {
        m_logger.LogError() << "Swc_ServiceCreator::Failed to create socket";
        return false;
    }
    
    // Set server address
    struct sockaddr_in server_addr;
    std::memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SOCKET_SERVER_PORT);
    
    if (::inet_pton(AF_INET, SOCKET_SERVER_IP, &server_addr.sin_addr) <= 0) {
        m_logger.LogError() << "Swc_ServiceCreator::Invalid IP address";
        ::close(m_socket_fd);
        m_socket_fd = -1;
        return false;
    }
    
    // Connect to server
    if (::connect(m_socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        m_logger.LogError() << "Swc_ServiceCreator::Failed to connect to server";
        ::close(m_socket_fd);
        m_socket_fd = -1;
        return false;
    }
    
    m_socket_connected.store(true);
    m_logger.LogInfo() << "Swc_ServiceCreator::Successfully connected to socket server";
    return true;
}

void Swc_ServiceCreator::SocketReceiveThread()
{
    m_logger.LogInfo() << "Swc_ServiceCreator::Socket receive thread started";
    
    char buffer[SOCKET_BUFFER_SIZE];
    
    try {
        while (m_socket_connected.load() && m_running) {
            std::memset(buffer, 0, sizeof(buffer));
            
            ssize_t bytes_received = ::recv(m_socket_fd, buffer, SOCKET_BUFFER_SIZE - 1, 0);
            
            if (bytes_received > 0) {
                m_logger.LogDebug() << "Swc_ServiceCreator::Received " << bytes_received << " bytes from socket";
                
                // Process received data
                std::string received_data(buffer, bytes_received);
                // Remove trailing whitespace/newline
                const auto endpos = received_data.find_last_not_of(" \n\r\t");
                if (endpos != std::string::npos) received_data.erase(endpos + 1);
                
                m_logger.LogInfo() << "Swc_ServiceCreator::Socket data: " << received_data.c_str();
                
                // Parse scenario data and send to OCP
                if (received_data == "scenario_1") {
                    m_logger.LogInfo() << "Swc_ServiceCreator::Sending scenario 1 to OCP";
                    std::uint8_t scenario_value = 1;
                    m_PPort_SCr2OCP->SendEventscenarioTriggered(scenario_value);
                } else if (received_data == "scenario_2") {
                    m_logger.LogInfo() << "Swc_ServiceCreator::Sending scenario 2 to OCP";
                    std::uint8_t scenario_value = 2;
                    m_PPort_SCr2OCP->SendEventscenarioTriggered(scenario_value);
                } else if (received_data == "scenario_3") {
                    m_logger.LogInfo() << "Swc_ServiceCreator::Sending scenario 3 to OCP";
                    std::uint8_t scenario_value = 3;
                    m_PPort_SCr2OCP->SendEventscenarioTriggered(scenario_value);
                } else {
                    m_logger.LogWarn() << "Swc_ServiceCreator::Unknown scenario command: " << received_data.c_str();
                }
                
            } else if (bytes_received == 0) {
                m_logger.LogWarn() << "Swc_ServiceCreator::Socket connection closed by server";
                break;
            } else {
                m_logger.LogError() << "Swc_ServiceCreator::Socket receive error";
                break;
            }
        }
    } catch (const std::exception& e) {
        m_logger.LogError() << "Swc_ServiceCreator::Socket receive thread exception: " << e.what();
    }

    // Mark disconnected and let connect loop handle reconnection
    m_socket_connected.store(false);
    CloseSocketConnection();
    m_logger.LogInfo() << "Swc_ServiceCreator::Socket receive thread ended";
}

void Swc_ServiceCreator::SocketConnectLoop()
{
    m_logger.LogInfo() << "Swc_ServiceCreator::Socket connect loop started";
    using namespace std::chrono_literals;

    while (m_running && m_socket_running) {
        if (!m_socket_connected.load()) {
            // Not connected: try connect every 1s
            m_logger.LogInfo() << "Swc_ServiceCreator::Attempting to connect to " << SOCKET_SERVER_IP << ":" << SOCKET_SERVER_PORT;
            if (ConnectToSocketServer()) {
                m_logger.LogInfo() << "Swc_ServiceCreator::Socket connected to " << SOCKET_SERVER_IP << ":" << SOCKET_SERVER_PORT;
                // Ensure any previous receive thread is cleaned up
                if (m_socket_thread.joinable()) {
                    m_socket_thread.join();
                }
                m_socket_thread = std::thread([this]() { SocketReceiveThread(); });
            } else {
                m_logger.LogWarn() << "Swc_ServiceCreator::Connect failed, will retry in 1000 ms";
            }
        } else {
            // Connected: heartbeat check each 1s
            if (m_socket_fd >= 0) {
                struct sockaddr_in peer{};
                socklen_t len = sizeof(peer);
                if (::getpeername(m_socket_fd, reinterpret_cast<struct sockaddr*>(&peer), &len) == 0) {
                    m_logger.LogDebug() << "Swc_ServiceCreator::Socket heartbeat: connected";
                } else {
                    m_logger.LogWarn() << "Swc_ServiceCreator::Socket heartbeat: not connected, will reconnect";
                    m_socket_connected.store(false);
                    CloseSocketConnection();
                }
            } else {
                m_logger.LogWarn() << "Swc_ServiceCreator::Socket fd invalid, will reconnect";
                m_socket_connected.store(false);
            }
        }

        std::this_thread::sleep_for(1000ms);
    }

    m_logger.LogInfo() << "Swc_ServiceCreator::Socket connect loop ended";
}

void Swc_ServiceCreator::CloseSocketConnection()
{
    std::lock_guard<std::mutex> lock(m_socket_mutex);
    
    if (m_socket_fd >= 0) {
        m_socket_connected.store(false);
        ::close(m_socket_fd);
        m_socket_fd = -1;
        m_logger.LogInfo() << "Swc_ServiceCreator::Socket connection closed";
    }
}

void Swc_ServiceCreator::SendSocketMessage(const std::string& message)
{
    std::lock_guard<std::mutex> lock(m_socket_mutex);
    if (m_socket_fd < 0 || !m_socket_connected.load()) {
        m_logger.LogWarn() << "Swc_ServiceCreator::SendSocketMessage skipped (not connected): " << message.c_str();
        return;
    }
    const ssize_t sent = ::send(m_socket_fd, message.c_str(), message.size(), MSG_NOSIGNAL);
    if (sent < 0) {
        m_logger.LogError() << "Swc_ServiceCreator::SendSocketMessage failed: " << message.c_str();
    } else {
        m_logger.LogInfo() << "Swc_ServiceCreator::SendSocketMessage sent: " << message.c_str();
    }
}

nlohmann::json Swc_ServiceCreator::trajectoryToJson(const oss::srv::OCP2SCr::proxy::events::trajectory::SampleType& traj)
{
    using json = nlohmann::ordered_json; // preserve insertion order deterministically
    
    json j;

    // Topic first to match example ordering
    j["topic"] = "/planning/scenario_planning/trajectory";
    // Timestamp second (reconstructed from header)
    const std::int64_t kNanosecondsInSecond = 1'000'000'000;
    std::int64_t timestamp_ns = static_cast<std::int64_t>(traj.header.stamp.sec) * kNanosecondsInSecond
                                + static_cast<std::int64_t>(traj.header.stamp.nanosec);
    j["timestamp"] = timestamp_ns;

    // Build message object matching input JSONL structure
    json message;

    // Header (preserve OCP's values)
    message["header"]["stamp"]["sec"] = traj.header.stamp.sec;
    message["header"]["stamp"]["nanosec"] = traj.header.stamp.nanosec;
    // Convert frame_id to string (handle byte arrays or string-like)
    {
        std::string frame_id_str;
        frame_id_str.reserve(32);
        for (const auto &b : traj.header.frame_id) {
            frame_id_str.push_back(static_cast<char>(b));
        }
        if (frame_id_str.empty()) {
            frame_id_str = "map";
        }
        message["header"]["frame_id"] = frame_id_str;
    }
    
    // Points array
    json points = json::array();
    for (const auto& point : traj.points) {
        json point_obj;
        
        point_obj["time_from_start"]["sec"] = point.time_from_start.sec;
        point_obj["time_from_start"]["nanosec"] = point.time_from_start.nanosec;
        
        point_obj["pose"]["position"]["x"] = point.pose.position.x;
        point_obj["pose"]["position"]["y"] = point.pose.position.y;
        point_obj["pose"]["position"]["z"] = point.pose.position.z;
        
        point_obj["pose"]["orientation"]["x"] = point.pose.orientation.x;
        point_obj["pose"]["orientation"]["y"] = point.pose.orientation.y;
        point_obj["pose"]["orientation"]["z"] = point.pose.orientation.z;
        point_obj["pose"]["orientation"]["w"] = point.pose.orientation.w;
        
        point_obj["longitudinal_velocity_mps"] = point.longitudinal_velocity_mps;
        point_obj["lateral_velocity_mps"] = point.lateral_velocity_mps;
        point_obj["acceleration_mps2"] = point.acceleration_mps2;
        point_obj["heading_rate_rps"] = point.heading_rate_rps;
        point_obj["front_wheel_angle_rad"] = point.front_wheel_angle_rad;
        point_obj["rear_wheel_angle_rad"] = point.rear_wheel_angle_rad;
        
        points.push_back(point_obj);
    }
    message["points"] = points;
    
    // Message last to match example ordering
    j["message"] = message;

    return j;
}

// Helper to serialize in strict key order regardless of library behavior
static std::string SerializeTrajectoryJsonLine(
    const nlohmann::ordered_json &message,
    std::int64_t timestamp_ns)
{
    std::string line;
    line.reserve(256 + message.dump().size());
    line += "{";
    line += "\"topic\":\"/planning/scenario_planning/trajectory\",";
    line += "\"timestamp\":";
    line += std::to_string(timestamp_ns);
    line += ",\"message\":";
    line += message.dump();
    line += "}";
    return line;
}
 
} /// namespace aa
} /// namespace exe_servicecreator
