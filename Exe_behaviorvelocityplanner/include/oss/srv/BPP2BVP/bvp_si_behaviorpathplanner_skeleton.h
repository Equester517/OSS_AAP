///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : bvp_si_behaviorpathplanner_skeleton.h
/// SERVICE INTERFACE NAME            : BVP_SI_behaviorpathplanner
/// GENERATED DATE                    : 2025-12-08 15:30:13
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_OSS_SRV_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_SKELETON_H
#define PARA_COM_GEN_OSS_SRV_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_SKELETON_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "bvp_si_behaviorpathplanner_common.h"
#include "para/com/skeleton/skeleton_interface.h"
/// @uptrace{SWS_CM_01005}
namespace oss
{
namespace srv
{
namespace BPP2BVP
{
/// @uptrace{SWS_CM_01006}
namespace skeleton
{
class BVP_SI_behaviorpathplannerSkeleton;
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_avoidancebylanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_avoidancebylanechangeleft(const planning_automodestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_avoidancebylanechangeleft& operator=(const planning_automodestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_avoidancebylanechangeleft(planning_automodestatus_avoidancebylanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_avoidancebylanechangeleft& operator=(planning_automodestatus_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_avoidancebylanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_avoidancebylanechangeright(const planning_automodestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_avoidancebylanechangeright& operator=(const planning_automodestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_avoidancebylanechangeright(planning_automodestatus_avoidancebylanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_avoidancebylanechangeright& operator=(planning_automodestatus_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_goalplanner(const planning_automodestatus_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_goalplanner& operator=(const planning_automodestatus_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_goalplanner(planning_automodestatus_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_goalplanner& operator=(planning_automodestatus_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_lanechangeleft(const planning_automodestatus_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_lanechangeleft& operator=(const planning_automodestatus_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_lanechangeleft(planning_automodestatus_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_lanechangeleft& operator=(planning_automodestatus_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_lanechangeright(const planning_automodestatus_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_lanechangeright& operator=(const planning_automodestatus_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_lanechangeright(planning_automodestatus_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_lanechangeright& operator=(planning_automodestatus_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_startplanner() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_startplanner(const planning_automodestatus_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_startplanner& operator=(const planning_automodestatus_startplanner& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_startplanner(planning_automodestatus_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_startplanner& operator=(planning_automodestatus_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_staticobstacleavoidanceleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_staticobstacleavoidanceleft(const planning_automodestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_staticobstacleavoidanceleft& operator=(const planning_automodestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_staticobstacleavoidanceleft(planning_automodestatus_staticobstacleavoidanceleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_staticobstacleavoidanceleft& operator=(planning_automodestatus_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_staticobstacleavoidanceright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_staticobstacleavoidanceright(const planning_automodestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_staticobstacleavoidanceright& operator=(const planning_automodestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_staticobstacleavoidanceright(planning_automodestatus_staticobstacleavoidanceright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_staticobstacleavoidanceright& operator=(planning_automodestatus_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_avoidancebylanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_avoidancebylanechangeleft(const planning_cooperatestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_avoidancebylanechangeleft& operator=(const planning_cooperatestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_avoidancebylanechangeleft(planning_cooperatestatus_avoidancebylanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_avoidancebylanechangeleft& operator=(planning_cooperatestatus_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_avoidancebylanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_avoidancebylanechangeright(const planning_cooperatestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_avoidancebylanechangeright& operator=(const planning_cooperatestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_avoidancebylanechangeright(planning_cooperatestatus_avoidancebylanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_avoidancebylanechangeright& operator=(planning_cooperatestatus_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_goalplanner(const planning_cooperatestatus_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_goalplanner& operator=(const planning_cooperatestatus_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_goalplanner(planning_cooperatestatus_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_goalplanner& operator=(planning_cooperatestatus_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_lanechangeleft(const planning_cooperatestatus_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_lanechangeleft& operator=(const planning_cooperatestatus_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_lanechangeleft(planning_cooperatestatus_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_lanechangeleft& operator=(planning_cooperatestatus_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_lanechangeright(const planning_cooperatestatus_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_lanechangeright& operator=(const planning_cooperatestatus_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_lanechangeright(planning_cooperatestatus_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_lanechangeright& operator=(planning_cooperatestatus_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_startplanner() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_startplanner(const planning_cooperatestatus_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_startplanner& operator=(const planning_cooperatestatus_startplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_startplanner(planning_cooperatestatus_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_startplanner& operator=(planning_cooperatestatus_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_staticobstacleavoidanceleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_staticobstacleavoidanceleft(const planning_cooperatestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_staticobstacleavoidanceleft& operator=(const planning_cooperatestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_staticobstacleavoidanceleft(planning_cooperatestatus_staticobstacleavoidanceleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_staticobstacleavoidanceleft& operator=(planning_cooperatestatus_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_staticobstacleavoidanceright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_staticobstacleavoidanceright(const planning_cooperatestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_staticobstacleavoidanceright& operator=(const planning_cooperatestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_staticobstacleavoidanceright(planning_cooperatestatus_staticobstacleavoidanceright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_staticobstacleavoidanceright& operator=(planning_cooperatestatus_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_avoidancebylanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_avoidancebylanechangeleft(const planning_debug_objectsofinterest_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_avoidancebylanechangeleft& operator=(const planning_debug_objectsofinterest_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_avoidancebylanechangeleft(planning_debug_objectsofinterest_avoidancebylanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_avoidancebylanechangeleft& operator=(planning_debug_objectsofinterest_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_avoidancebylanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_avoidancebylanechangeright(const planning_debug_objectsofinterest_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_avoidancebylanechangeright& operator=(const planning_debug_objectsofinterest_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_avoidancebylanechangeright(planning_debug_objectsofinterest_avoidancebylanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_avoidancebylanechangeright& operator=(planning_debug_objectsofinterest_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_goalplanner(const planning_debug_objectsofinterest_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_goalplanner& operator=(const planning_debug_objectsofinterest_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_goalplanner(planning_debug_objectsofinterest_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_goalplanner& operator=(planning_debug_objectsofinterest_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_lanechangeleft(const planning_debug_objectsofinterest_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_lanechangeleft& operator=(const planning_debug_objectsofinterest_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_lanechangeleft(planning_debug_objectsofinterest_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_lanechangeleft& operator=(planning_debug_objectsofinterest_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_lanechangeright(const planning_debug_objectsofinterest_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_lanechangeright& operator=(const planning_debug_objectsofinterest_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_lanechangeright(planning_debug_objectsofinterest_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_lanechangeright& operator=(planning_debug_objectsofinterest_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_startplanner() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_startplanner(const planning_debug_objectsofinterest_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_startplanner& operator=(const planning_debug_objectsofinterest_startplanner& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_startplanner(planning_debug_objectsofinterest_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_startplanner& operator=(planning_debug_objectsofinterest_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_staticobstacleavoidanceleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceleft(const planning_debug_objectsofinterest_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceleft& operator=(const planning_debug_objectsofinterest_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceleft(planning_debug_objectsofinterest_staticobstacleavoidanceleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceleft& operator=(planning_debug_objectsofinterest_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_staticobstacleavoidanceright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceright(const planning_debug_objectsofinterest_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceright& operator=(const planning_debug_objectsofinterest_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceright(planning_debug_objectsofinterest_staticobstacleavoidanceright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceright& operator=(planning_debug_objectsofinterest_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_hazardlightscmd
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_vehicle_msgs::msg::HazardLightsCommand;
    /// @brief Constructor
    explicit planning_hazardlightscmd(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::HazardLightsCommandEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_hazardlightscmd() = default;
    /// @brief Delete copy constructor
    planning_hazardlightscmd(const planning_hazardlightscmd& other) = delete;
    /// @brief Delete copy assignment
    planning_hazardlightscmd& operator=(const planning_hazardlightscmd& other) = delete;
    /// @brief Move constructor
    planning_hazardlightscmd(planning_hazardlightscmd&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_hazardlightscmd& operator=(planning_hazardlightscmd&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::HazardLightsCommandEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_vehicle_msgs::msg::HazardLightsCommand_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::HazardLightsCommandEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_hazardlightscmd"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_avoidancebylanechange(const planning_pathcandidate_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_avoidancebylanechange& operator=(const planning_pathcandidate_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_avoidancebylanechange(planning_pathcandidate_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_avoidancebylanechange& operator=(planning_pathcandidate_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_goalplanner(const planning_pathcandidate_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_goalplanner& operator=(const planning_pathcandidate_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_goalplanner(planning_pathcandidate_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_goalplanner& operator=(planning_pathcandidate_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_lanechangeleft(const planning_pathcandidate_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_lanechangeleft& operator=(const planning_pathcandidate_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_lanechangeleft(planning_pathcandidate_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_lanechangeleft& operator=(planning_pathcandidate_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_lanechangeright(const planning_pathcandidate_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_lanechangeright& operator=(const planning_pathcandidate_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_lanechangeright(planning_pathcandidate_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_lanechangeright& operator=(planning_pathcandidate_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_sideshift() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_sideshift(const planning_pathcandidate_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_sideshift& operator=(const planning_pathcandidate_sideshift& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_sideshift(planning_pathcandidate_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_sideshift& operator=(planning_pathcandidate_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_startplanner() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_startplanner(const planning_pathcandidate_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_startplanner& operator=(const planning_pathcandidate_startplanner& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_startplanner(planning_pathcandidate_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_startplanner& operator=(planning_pathcandidate_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_staticobstacleavoidance(const planning_pathcandidate_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_staticobstacleavoidance& operator=(const planning_pathcandidate_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_staticobstacleavoidance(planning_pathcandidate_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathcandidate_staticobstacleavoidance& operator=(planning_pathcandidate_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathcandidate_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_pathreference_avoidancebylanechange(const planning_pathreference_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_avoidancebylanechange& operator=(const planning_pathreference_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_pathreference_avoidancebylanechange(planning_pathreference_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_avoidancebylanechange& operator=(planning_pathreference_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_pathreference_goalplanner(const planning_pathreference_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_goalplanner& operator=(const planning_pathreference_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_pathreference_goalplanner(planning_pathreference_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_goalplanner& operator=(planning_pathreference_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_pathreference_lanechangeleft(const planning_pathreference_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_lanechangeleft& operator=(const planning_pathreference_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_pathreference_lanechangeleft(planning_pathreference_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_lanechangeleft& operator=(planning_pathreference_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_pathreference_lanechangeright(const planning_pathreference_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_lanechangeright& operator=(const planning_pathreference_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_pathreference_lanechangeright(planning_pathreference_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_lanechangeright& operator=(planning_pathreference_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_sideshift() = default;
    /// @brief Delete copy constructor
    planning_pathreference_sideshift(const planning_pathreference_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_sideshift& operator=(const planning_pathreference_sideshift& other) = delete;
    /// @brief Move constructor
    planning_pathreference_sideshift(planning_pathreference_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_sideshift& operator=(planning_pathreference_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_startplanner() = default;
    /// @brief Delete copy constructor
    planning_pathreference_startplanner(const planning_pathreference_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_startplanner& operator=(const planning_pathreference_startplanner& other) = delete;
    /// @brief Move constructor
    planning_pathreference_startplanner(planning_pathreference_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_startplanner& operator=(planning_pathreference_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_pathreference_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_pathreference_staticobstacleavoidance(const planning_pathreference_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_staticobstacleavoidance& operator=(const planning_pathreference_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_pathreference_staticobstacleavoidance(planning_pathreference_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_pathreference_staticobstacleavoidance& operator=(planning_pathreference_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_pathreference_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_avoidancebylanechange(const planning_planningfactors_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_avoidancebylanechange& operator=(const planning_planningfactors_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_avoidancebylanechange(planning_planningfactors_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_avoidancebylanechange& operator=(planning_planningfactors_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_behaviorpathplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_behaviorpathplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_behaviorpathplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_behaviorpathplanner(const planning_planningfactors_behaviorpathplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_behaviorpathplanner& operator=(const planning_planningfactors_behaviorpathplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_behaviorpathplanner(planning_planningfactors_behaviorpathplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_behaviorpathplanner& operator=(planning_planningfactors_behaviorpathplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_behaviorpathplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_goalplanner(const planning_planningfactors_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_goalplanner& operator=(const planning_planningfactors_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_goalplanner(planning_planningfactors_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_goalplanner& operator=(planning_planningfactors_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_lanechangeleft(const planning_planningfactors_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_lanechangeleft& operator=(const planning_planningfactors_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_lanechangeleft(planning_planningfactors_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_lanechangeleft& operator=(planning_planningfactors_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_lanechangeright(const planning_planningfactors_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_lanechangeright& operator=(const planning_planningfactors_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_lanechangeright(planning_planningfactors_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_lanechangeright& operator=(planning_planningfactors_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_sideshift() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_sideshift(const planning_planningfactors_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_sideshift& operator=(const planning_planningfactors_sideshift& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_sideshift(planning_planningfactors_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_sideshift& operator=(planning_planningfactors_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_startplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_startplanner(const planning_planningfactors_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_startplanner& operator=(const planning_planningfactors_startplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_startplanner(planning_planningfactors_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_startplanner& operator=(planning_planningfactors_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_staticobstacleavoidance(const planning_planningfactors_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_staticobstacleavoidance& operator=(const planning_planningfactors_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_staticobstacleavoidance(planning_planningfactors_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_staticobstacleavoidance& operator=(planning_planningfactors_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::AvoidanceDebugMsgArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::AvoidanceDebugMsgArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::AvoidanceDebugMsgArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::AvoidanceDebugMsgArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::AvoidanceDebugMsgArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::RerouteAvailability;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::RerouteAvailabilityEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::RerouteAvailabilityEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::RerouteAvailability_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::RerouteAvailabilityEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PathWithLaneId;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PathWithLaneIdEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(const planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PathWithLaneIdEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PathWithLaneId_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PathWithLaneIdEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_modifiedgoal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::PoseWithUuidStamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_modifiedgoal(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::PoseWithUuidStampedEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_modifiedgoal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_modifiedgoal(const planning_scenarioplanning_modifiedgoal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_modifiedgoal& operator=(const planning_scenarioplanning_modifiedgoal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_modifiedgoal(planning_scenarioplanning_modifiedgoal&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_modifiedgoal& operator=(planning_scenarioplanning_modifiedgoal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::PoseWithUuidStampedEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::PoseWithUuidStamped_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::PoseWithUuidStampedEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_modifiedgoal"};
};
/// @uptrace{SWS_CM_00003}
class planning_turnindicatorscmd
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::TurnIndicatorsCommand;
    /// @brief Constructor
    explicit planning_turnindicatorscmd(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BPP2BVP::TurnIndicatorsCommandEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_turnindicatorscmd() = default;
    /// @brief Delete copy constructor
    planning_turnindicatorscmd(const planning_turnindicatorscmd& other) = delete;
    /// @brief Delete copy assignment
    planning_turnindicatorscmd& operator=(const planning_turnindicatorscmd& other) = delete;
    /// @brief Move constructor
    planning_turnindicatorscmd(planning_turnindicatorscmd&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_turnindicatorscmd& operator=(planning_turnindicatorscmd&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::TurnIndicatorsCommandEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::TurnIndicatorsCommand_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BPP2BVP::TurnIndicatorsCommandEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_turnindicatorscmd"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_00002}
class BVP_SI_behaviorpathplannerSkeleton
{
public:
    /// @uptrace{SWS_CM_00191}
    struct planning_cooperatecommands_avoidancebylanechangeleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_avoidancebylanechangerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_goalplannerOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_lanechangeleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_lanechangerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_startplannerOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_staticobstacleavoidanceleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_staticobstacleavoidancerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_enableautomode_avoidancebylanechangeleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_avoidancebylanechangerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_goalplannerOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_lanechangeleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_lanechangerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_startplannerOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_staticobstacleavoidanceleftOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_staticobstacleavoidancerightOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerOutput
    {
        oss::type::logging_demo::srv::ConfigLogger_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersOutput
    {
        oss::type::rcl_interfaces::srv::DescribeParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersOutput
    {
        oss::type::rcl_interfaces::srv::GetParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesOutput
    {
        oss::type::rcl_interfaces::srv::GetParameterTypes_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersOutput
    {
        oss::type::rcl_interfaces::srv::ListParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersOutput
    {
        oss::type::rcl_interfaces::srv::SetParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyOutput
    {
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Response res;
    };
    /// @brief Constructor
    /// @uptrace{SWS_CM_00002, SWS_CM_00152}
    BVP_SI_behaviorpathplannerSkeleton(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent)
        : mInterface(std::make_unique<para::com::SkeletonInterface>(instanceSpec, mode))
        , mDdsInterface(std::make_unique<para::com::SkeletonDdsInterface>(instanceSpec, mode))
        , mProtocol(para::com::GetServiceProtocol(instanceSpec))
        , planning_automodestatus_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_hazardlightscmd(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathcandidate_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_pathreference_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_behaviorpathplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_modifiedgoal(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_turnindicatorscmd(mInterface.get(), mDdsInterface.get(), mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~BVP_SI_behaviorpathplannerSkeleton() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00134}
    BVP_SI_behaviorpathplannerSkeleton(const BVP_SI_behaviorpathplannerSkeleton& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00134}
    BVP_SI_behaviorpathplannerSkeleton& operator=(const BVP_SI_behaviorpathplannerSkeleton& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00135}
    BVP_SI_behaviorpathplannerSkeleton(BVP_SI_behaviorpathplannerSkeleton&& other) noexcept
        : mInterface(std::move(other.mInterface))
        , mDdsInterface(std::move(other.mDdsInterface))
        , mProtocol(std::move(other.mProtocol))
        , planning_automodestatus_avoidancebylanechangeleft(std::move(other.planning_automodestatus_avoidancebylanechangeleft))
        , planning_automodestatus_avoidancebylanechangeright(std::move(other.planning_automodestatus_avoidancebylanechangeright))
        , planning_automodestatus_goalplanner(std::move(other.planning_automodestatus_goalplanner))
        , planning_automodestatus_lanechangeleft(std::move(other.planning_automodestatus_lanechangeleft))
        , planning_automodestatus_lanechangeright(std::move(other.planning_automodestatus_lanechangeright))
        , planning_automodestatus_startplanner(std::move(other.planning_automodestatus_startplanner))
        , planning_automodestatus_staticobstacleavoidanceleft(std::move(other.planning_automodestatus_staticobstacleavoidanceleft))
        , planning_automodestatus_staticobstacleavoidanceright(std::move(other.planning_automodestatus_staticobstacleavoidanceright))
        , planning_cooperatestatus_avoidancebylanechangeleft(std::move(other.planning_cooperatestatus_avoidancebylanechangeleft))
        , planning_cooperatestatus_avoidancebylanechangeright(std::move(other.planning_cooperatestatus_avoidancebylanechangeright))
        , planning_cooperatestatus_goalplanner(std::move(other.planning_cooperatestatus_goalplanner))
        , planning_cooperatestatus_lanechangeleft(std::move(other.planning_cooperatestatus_lanechangeleft))
        , planning_cooperatestatus_lanechangeright(std::move(other.planning_cooperatestatus_lanechangeright))
        , planning_cooperatestatus_startplanner(std::move(other.planning_cooperatestatus_startplanner))
        , planning_cooperatestatus_staticobstacleavoidanceleft(std::move(other.planning_cooperatestatus_staticobstacleavoidanceleft))
        , planning_cooperatestatus_staticobstacleavoidanceright(std::move(other.planning_cooperatestatus_staticobstacleavoidanceright))
        , planning_debug_objectsofinterest_avoidancebylanechangeleft(std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeleft))
        , planning_debug_objectsofinterest_avoidancebylanechangeright(std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeright))
        , planning_debug_objectsofinterest_goalplanner(std::move(other.planning_debug_objectsofinterest_goalplanner))
        , planning_debug_objectsofinterest_lanechangeleft(std::move(other.planning_debug_objectsofinterest_lanechangeleft))
        , planning_debug_objectsofinterest_lanechangeright(std::move(other.planning_debug_objectsofinterest_lanechangeright))
        , planning_debug_objectsofinterest_startplanner(std::move(other.planning_debug_objectsofinterest_startplanner))
        , planning_debug_objectsofinterest_staticobstacleavoidanceleft(std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceleft))
        , planning_debug_objectsofinterest_staticobstacleavoidanceright(std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceright))
        , planning_hazardlightscmd(std::move(other.planning_hazardlightscmd))
        , planning_pathcandidate_avoidancebylanechange(std::move(other.planning_pathcandidate_avoidancebylanechange))
        , planning_pathcandidate_goalplanner(std::move(other.planning_pathcandidate_goalplanner))
        , planning_pathcandidate_lanechangeleft(std::move(other.planning_pathcandidate_lanechangeleft))
        , planning_pathcandidate_lanechangeright(std::move(other.planning_pathcandidate_lanechangeright))
        , planning_pathcandidate_sideshift(std::move(other.planning_pathcandidate_sideshift))
        , planning_pathcandidate_startplanner(std::move(other.planning_pathcandidate_startplanner))
        , planning_pathcandidate_staticobstacleavoidance(std::move(other.planning_pathcandidate_staticobstacleavoidance))
        , planning_pathreference_avoidancebylanechange(std::move(other.planning_pathreference_avoidancebylanechange))
        , planning_pathreference_goalplanner(std::move(other.planning_pathreference_goalplanner))
        , planning_pathreference_lanechangeleft(std::move(other.planning_pathreference_lanechangeleft))
        , planning_pathreference_lanechangeright(std::move(other.planning_pathreference_lanechangeright))
        , planning_pathreference_sideshift(std::move(other.planning_pathreference_sideshift))
        , planning_pathreference_startplanner(std::move(other.planning_pathreference_startplanner))
        , planning_pathreference_staticobstacleavoidance(std::move(other.planning_pathreference_staticobstacleavoidance))
        , planning_planningfactors_avoidancebylanechange(std::move(other.planning_planningfactors_avoidancebylanechange))
        , planning_planningfactors_behaviorpathplanner(std::move(other.planning_planningfactors_behaviorpathplanner))
        , planning_planningfactors_goalplanner(std::move(other.planning_planningfactors_goalplanner))
        , planning_planningfactors_lanechangeleft(std::move(other.planning_planningfactors_lanechangeleft))
        , planning_planningfactors_lanechangeright(std::move(other.planning_planningfactors_lanechangeright))
        , planning_planningfactors_sideshift(std::move(other.planning_planningfactors_sideshift))
        , planning_planningfactors_startplanner(std::move(other.planning_planningfactors_startplanner))
        , planning_planningfactors_staticobstacleavoidance(std::move(other.planning_planningfactors_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid))
        , planning_scenarioplanning_modifiedgoal(std::move(other.planning_scenarioplanning_modifiedgoal))
        , planning_turnindicatorscmd(std::move(other.planning_turnindicatorscmd))
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00135}
    BVP_SI_behaviorpathplannerSkeleton& operator=(BVP_SI_behaviorpathplannerSkeleton&& other) noexcept
    {
        mInterface = std::move(other.mInterface);
        mDdsInterface = std::move(other.mDdsInterface);
        mProtocol = std::move(other.mProtocol);
        planning_automodestatus_avoidancebylanechangeleft = std::move(other.planning_automodestatus_avoidancebylanechangeleft);
        planning_automodestatus_avoidancebylanechangeright = std::move(other.planning_automodestatus_avoidancebylanechangeright);
        planning_automodestatus_goalplanner = std::move(other.planning_automodestatus_goalplanner);
        planning_automodestatus_lanechangeleft = std::move(other.planning_automodestatus_lanechangeleft);
        planning_automodestatus_lanechangeright = std::move(other.planning_automodestatus_lanechangeright);
        planning_automodestatus_startplanner = std::move(other.planning_automodestatus_startplanner);
        planning_automodestatus_staticobstacleavoidanceleft = std::move(other.planning_automodestatus_staticobstacleavoidanceleft);
        planning_automodestatus_staticobstacleavoidanceright = std::move(other.planning_automodestatus_staticobstacleavoidanceright);
        planning_cooperatestatus_avoidancebylanechangeleft = std::move(other.planning_cooperatestatus_avoidancebylanechangeleft);
        planning_cooperatestatus_avoidancebylanechangeright = std::move(other.planning_cooperatestatus_avoidancebylanechangeright);
        planning_cooperatestatus_goalplanner = std::move(other.planning_cooperatestatus_goalplanner);
        planning_cooperatestatus_lanechangeleft = std::move(other.planning_cooperatestatus_lanechangeleft);
        planning_cooperatestatus_lanechangeright = std::move(other.planning_cooperatestatus_lanechangeright);
        planning_cooperatestatus_startplanner = std::move(other.planning_cooperatestatus_startplanner);
        planning_cooperatestatus_staticobstacleavoidanceleft = std::move(other.planning_cooperatestatus_staticobstacleavoidanceleft);
        planning_cooperatestatus_staticobstacleavoidanceright = std::move(other.planning_cooperatestatus_staticobstacleavoidanceright);
        planning_debug_objectsofinterest_avoidancebylanechangeleft = std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeleft);
        planning_debug_objectsofinterest_avoidancebylanechangeright = std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeright);
        planning_debug_objectsofinterest_goalplanner = std::move(other.planning_debug_objectsofinterest_goalplanner);
        planning_debug_objectsofinterest_lanechangeleft = std::move(other.planning_debug_objectsofinterest_lanechangeleft);
        planning_debug_objectsofinterest_lanechangeright = std::move(other.planning_debug_objectsofinterest_lanechangeright);
        planning_debug_objectsofinterest_startplanner = std::move(other.planning_debug_objectsofinterest_startplanner);
        planning_debug_objectsofinterest_staticobstacleavoidanceleft = std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceleft);
        planning_debug_objectsofinterest_staticobstacleavoidanceright = std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceright);
        planning_hazardlightscmd = std::move(other.planning_hazardlightscmd);
        planning_pathcandidate_avoidancebylanechange = std::move(other.planning_pathcandidate_avoidancebylanechange);
        planning_pathcandidate_goalplanner = std::move(other.planning_pathcandidate_goalplanner);
        planning_pathcandidate_lanechangeleft = std::move(other.planning_pathcandidate_lanechangeleft);
        planning_pathcandidate_lanechangeright = std::move(other.planning_pathcandidate_lanechangeright);
        planning_pathcandidate_sideshift = std::move(other.planning_pathcandidate_sideshift);
        planning_pathcandidate_startplanner = std::move(other.planning_pathcandidate_startplanner);
        planning_pathcandidate_staticobstacleavoidance = std::move(other.planning_pathcandidate_staticobstacleavoidance);
        planning_pathreference_avoidancebylanechange = std::move(other.planning_pathreference_avoidancebylanechange);
        planning_pathreference_goalplanner = std::move(other.planning_pathreference_goalplanner);
        planning_pathreference_lanechangeleft = std::move(other.planning_pathreference_lanechangeleft);
        planning_pathreference_lanechangeright = std::move(other.planning_pathreference_lanechangeright);
        planning_pathreference_sideshift = std::move(other.planning_pathreference_sideshift);
        planning_pathreference_startplanner = std::move(other.planning_pathreference_startplanner);
        planning_pathreference_staticobstacleavoidance = std::move(other.planning_pathreference_staticobstacleavoidance);
        planning_planningfactors_avoidancebylanechange = std::move(other.planning_planningfactors_avoidancebylanechange);
        planning_planningfactors_behaviorpathplanner = std::move(other.planning_planningfactors_behaviorpathplanner);
        planning_planningfactors_goalplanner = std::move(other.planning_planningfactors_goalplanner);
        planning_planningfactors_lanechangeleft = std::move(other.planning_planningfactors_lanechangeleft);
        planning_planningfactors_lanechangeright = std::move(other.planning_planningfactors_lanechangeright);
        planning_planningfactors_sideshift = std::move(other.planning_planningfactors_sideshift);
        planning_planningfactors_startplanner = std::move(other.planning_planningfactors_startplanner);
        planning_planningfactors_staticobstacleavoidance = std::move(other.planning_planningfactors_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid);
        planning_scenarioplanning_modifiedgoal = std::move(other.planning_scenarioplanning_modifiedgoal);
        planning_turnindicatorscmd = std::move(other.planning_turnindicatorscmd);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_avoidancebylanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_avoidancebylanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_goalplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_goalplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangeleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_lanechangerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_lanechangeright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_startplannerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_startplanner(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceleft(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_staticobstacleavoidancerightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_staticobstacleavoidanceright(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
        return *this;
    }
    /// @brief Send "OfferService" message to Communication Management
    /// @uptrace{SWS_CM_00101}
    ara::core::Result<void> OfferService()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->OfferService();
            }
            case para::com::ServiceProtocol::kIpc :
            {
            	return mInterface->OfferService();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
            	return mDdsInterface->OfferService();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Send "StopOfferService" message to Communication Management
    /// @uptrace{SWS_CM_00111}
    void StopOfferService()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopOfferService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopOfferService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopOfferService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Allows the implementation providing the service method to trigger the execution of the next service consumer method call at a specific point of time
    ///        if the processing mode is set to kPoll.
    /// @note This function requires that ara::com::MethodCallProcessingMode is configured as kPoll by constructor
    /// @uptrace{SWS_CM_00199}
    ara::core::Future<bool> ProcessNextMethodCall()
    {
        ara::core::Promise<bool> promise{};
        ara::core::Result<bool> ret{false};
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                ret = mInterface->ProcessNextMethodCall();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                ret = mInterface->ProcessNextMethodCall();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                ret = mDdsInterface->ProcessNextMethodCall();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        if (ret.HasValue())
        {
            promise.set_value(ret.Value());
        }
        else
        {
            promise.SetError(ret.Error());
        }
        return promise.get_future();
    }
    /// @brief In case the call to E2E_check indicated a failed E2E check of the request message, the server application can get notified via an E2E error handler.
    /// @uptrace{SWS_CM_10470}
    virtual void E2EErrorHandler(const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter)
    {
    }
    
private:
    std::unique_ptr<para::com::SkeletonInterface> mInterface;
    std::unique_ptr<para::com::SkeletonDdsInterface> mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    
public:
    /// @brief Event, planning_automodestatus_avoidancebylanechangeleft
    events::planning_automodestatus_avoidancebylanechangeleft planning_automodestatus_avoidancebylanechangeleft;
    /// @brief Event, planning_automodestatus_avoidancebylanechangeright
    events::planning_automodestatus_avoidancebylanechangeright planning_automodestatus_avoidancebylanechangeright;
    /// @brief Event, planning_automodestatus_goalplanner
    events::planning_automodestatus_goalplanner planning_automodestatus_goalplanner;
    /// @brief Event, planning_automodestatus_lanechangeleft
    events::planning_automodestatus_lanechangeleft planning_automodestatus_lanechangeleft;
    /// @brief Event, planning_automodestatus_lanechangeright
    events::planning_automodestatus_lanechangeright planning_automodestatus_lanechangeright;
    /// @brief Event, planning_automodestatus_startplanner
    events::planning_automodestatus_startplanner planning_automodestatus_startplanner;
    /// @brief Event, planning_automodestatus_staticobstacleavoidanceleft
    events::planning_automodestatus_staticobstacleavoidanceleft planning_automodestatus_staticobstacleavoidanceleft;
    /// @brief Event, planning_automodestatus_staticobstacleavoidanceright
    events::planning_automodestatus_staticobstacleavoidanceright planning_automodestatus_staticobstacleavoidanceright;
    /// @brief Event, planning_cooperatestatus_avoidancebylanechangeleft
    events::planning_cooperatestatus_avoidancebylanechangeleft planning_cooperatestatus_avoidancebylanechangeleft;
    /// @brief Event, planning_cooperatestatus_avoidancebylanechangeright
    events::planning_cooperatestatus_avoidancebylanechangeright planning_cooperatestatus_avoidancebylanechangeright;
    /// @brief Event, planning_cooperatestatus_goalplanner
    events::planning_cooperatestatus_goalplanner planning_cooperatestatus_goalplanner;
    /// @brief Event, planning_cooperatestatus_lanechangeleft
    events::planning_cooperatestatus_lanechangeleft planning_cooperatestatus_lanechangeleft;
    /// @brief Event, planning_cooperatestatus_lanechangeright
    events::planning_cooperatestatus_lanechangeright planning_cooperatestatus_lanechangeright;
    /// @brief Event, planning_cooperatestatus_startplanner
    events::planning_cooperatestatus_startplanner planning_cooperatestatus_startplanner;
    /// @brief Event, planning_cooperatestatus_staticobstacleavoidanceleft
    events::planning_cooperatestatus_staticobstacleavoidanceleft planning_cooperatestatus_staticobstacleavoidanceleft;
    /// @brief Event, planning_cooperatestatus_staticobstacleavoidanceright
    events::planning_cooperatestatus_staticobstacleavoidanceright planning_cooperatestatus_staticobstacleavoidanceright;
    /// @brief Event, planning_debug_objectsofinterest_avoidancebylanechangeleft
    events::planning_debug_objectsofinterest_avoidancebylanechangeleft planning_debug_objectsofinterest_avoidancebylanechangeleft;
    /// @brief Event, planning_debug_objectsofinterest_avoidancebylanechangeright
    events::planning_debug_objectsofinterest_avoidancebylanechangeright planning_debug_objectsofinterest_avoidancebylanechangeright;
    /// @brief Event, planning_debug_objectsofinterest_goalplanner
    events::planning_debug_objectsofinterest_goalplanner planning_debug_objectsofinterest_goalplanner;
    /// @brief Event, planning_debug_objectsofinterest_lanechangeleft
    events::planning_debug_objectsofinterest_lanechangeleft planning_debug_objectsofinterest_lanechangeleft;
    /// @brief Event, planning_debug_objectsofinterest_lanechangeright
    events::planning_debug_objectsofinterest_lanechangeright planning_debug_objectsofinterest_lanechangeright;
    /// @brief Event, planning_debug_objectsofinterest_startplanner
    events::planning_debug_objectsofinterest_startplanner planning_debug_objectsofinterest_startplanner;
    /// @brief Event, planning_debug_objectsofinterest_staticobstacleavoidanceleft
    events::planning_debug_objectsofinterest_staticobstacleavoidanceleft planning_debug_objectsofinterest_staticobstacleavoidanceleft;
    /// @brief Event, planning_debug_objectsofinterest_staticobstacleavoidanceright
    events::planning_debug_objectsofinterest_staticobstacleavoidanceright planning_debug_objectsofinterest_staticobstacleavoidanceright;
    /// @brief Event, planning_hazardlightscmd
    events::planning_hazardlightscmd planning_hazardlightscmd;
    /// @brief Event, planning_pathcandidate_avoidancebylanechange
    events::planning_pathcandidate_avoidancebylanechange planning_pathcandidate_avoidancebylanechange;
    /// @brief Event, planning_pathcandidate_goalplanner
    events::planning_pathcandidate_goalplanner planning_pathcandidate_goalplanner;
    /// @brief Event, planning_pathcandidate_lanechangeleft
    events::planning_pathcandidate_lanechangeleft planning_pathcandidate_lanechangeleft;
    /// @brief Event, planning_pathcandidate_lanechangeright
    events::planning_pathcandidate_lanechangeright planning_pathcandidate_lanechangeright;
    /// @brief Event, planning_pathcandidate_sideshift
    events::planning_pathcandidate_sideshift planning_pathcandidate_sideshift;
    /// @brief Event, planning_pathcandidate_startplanner
    events::planning_pathcandidate_startplanner planning_pathcandidate_startplanner;
    /// @brief Event, planning_pathcandidate_staticobstacleavoidance
    events::planning_pathcandidate_staticobstacleavoidance planning_pathcandidate_staticobstacleavoidance;
    /// @brief Event, planning_pathreference_avoidancebylanechange
    events::planning_pathreference_avoidancebylanechange planning_pathreference_avoidancebylanechange;
    /// @brief Event, planning_pathreference_goalplanner
    events::planning_pathreference_goalplanner planning_pathreference_goalplanner;
    /// @brief Event, planning_pathreference_lanechangeleft
    events::planning_pathreference_lanechangeleft planning_pathreference_lanechangeleft;
    /// @brief Event, planning_pathreference_lanechangeright
    events::planning_pathreference_lanechangeright planning_pathreference_lanechangeright;
    /// @brief Event, planning_pathreference_sideshift
    events::planning_pathreference_sideshift planning_pathreference_sideshift;
    /// @brief Event, planning_pathreference_startplanner
    events::planning_pathreference_startplanner planning_pathreference_startplanner;
    /// @brief Event, planning_pathreference_staticobstacleavoidance
    events::planning_pathreference_staticobstacleavoidance planning_pathreference_staticobstacleavoidance;
    /// @brief Event, planning_planningfactors_avoidancebylanechange
    events::planning_planningfactors_avoidancebylanechange planning_planningfactors_avoidancebylanechange;
    /// @brief Event, planning_planningfactors_behaviorpathplanner
    events::planning_planningfactors_behaviorpathplanner planning_planningfactors_behaviorpathplanner;
    /// @brief Event, planning_planningfactors_goalplanner
    events::planning_planningfactors_goalplanner planning_planningfactors_goalplanner;
    /// @brief Event, planning_planningfactors_lanechangeleft
    events::planning_planningfactors_lanechangeleft planning_planningfactors_lanechangeleft;
    /// @brief Event, planning_planningfactors_lanechangeright
    events::planning_planningfactors_lanechangeright planning_planningfactors_lanechangeright;
    /// @brief Event, planning_planningfactors_sideshift
    events::planning_planningfactors_sideshift planning_planningfactors_sideshift;
    /// @brief Event, planning_planningfactors_startplanner
    events::planning_planningfactors_startplanner planning_planningfactors_startplanner;
    /// @brief Event, planning_planningfactors_staticobstacleavoidance
    events::planning_planningfactors_staticobstacleavoidance planning_planningfactors_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid
    events::planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid;
    /// @brief Event, planning_scenarioplanning_modifiedgoal
    events::planning_scenarioplanning_modifiedgoal planning_scenarioplanning_modifiedgoal;
    /// @brief Event, planning_turnindicatorscmd
    events::planning_turnindicatorscmd planning_turnindicatorscmd;
    /// @brief Method, planning_cooperatecommands_avoidancebylanechangeleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_avoidancebylanechangeleftOutput> planning_cooperatecommands_avoidancebylanechangeleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_avoidancebylanechangeright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_avoidancebylanechangerightOutput> planning_cooperatecommands_avoidancebylanechangeright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_goalplanner
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_goalplannerOutput> planning_cooperatecommands_goalplanner(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_lanechangeleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_lanechangeleftOutput> planning_cooperatecommands_lanechangeleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_lanechangeright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_lanechangerightOutput> planning_cooperatecommands_lanechangeright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_startplanner
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_startplannerOutput> planning_cooperatecommands_startplanner(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_staticobstacleavoidanceleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_staticobstacleavoidanceleftOutput> planning_cooperatecommands_staticobstacleavoidanceleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_staticobstacleavoidanceright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_staticobstacleavoidancerightOutput> planning_cooperatecommands_staticobstacleavoidanceright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_enableautomode_avoidancebylanechangeleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_avoidancebylanechangeleftOutput> planning_enableautomode_avoidancebylanechangeleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_avoidancebylanechangeright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_avoidancebylanechangerightOutput> planning_enableautomode_avoidancebylanechangeright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_goalplanner
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_goalplannerOutput> planning_enableautomode_goalplanner(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_lanechangeleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_lanechangeleftOutput> planning_enableautomode_lanechangeleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_lanechangeright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_lanechangerightOutput> planning_enableautomode_lanechangeright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_startplanner
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_startplannerOutput> planning_enableautomode_startplanner(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_staticobstacleavoidanceleft
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_staticobstacleavoidanceleftOutput> planning_enableautomode_staticobstacleavoidanceleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_staticobstacleavoidanceright
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_staticobstacleavoidancerightOutput> planning_enableautomode_staticobstacleavoidanceright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(const oss::type::logging_demo::srv::ConfigLogger_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(const oss::type::rcl_interfaces::srv::GetParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(const oss::type::rcl_interfaces::srv::ListParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(const oss::type::rcl_interfaces::srv::SetParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req) = 0;
    
private:
    void Handleplanning_cooperatecommands_avoidancebylanechangeleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_avoidancebylanechangeleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_avoidancebylanechangeleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_avoidancebylanechangeleftCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_avoidancebylanechangeright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_avoidancebylanechangeright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_avoidancebylanechangerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_avoidancebylanechangerightCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_goalplanner(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_goalplanner(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_goalplannerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_goalplannerCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_lanechangeleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_lanechangeleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_lanechangeleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_lanechangeleftCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_lanechangeright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_lanechangeright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_lanechangerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_lanechangerightCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_startplanner(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_startplanner(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_startplannerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_startplannerCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_staticobstacleavoidanceleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_staticobstacleavoidanceleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_staticobstacleavoidanceleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_staticobstacleavoidanceright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_staticobstacleavoidanceright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_staticobstacleavoidancerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_staticobstacleavoidancerightCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_avoidancebylanechangeleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_avoidancebylanechangeleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_avoidancebylanechangeleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_avoidancebylanechangeleftCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_avoidancebylanechangeright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_avoidancebylanechangeright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_avoidancebylanechangerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_avoidancebylanechangerightCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_goalplanner(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_goalplanner(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_goalplannerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_goalplannerCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_lanechangeleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_lanechangeleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_lanechangeleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_lanechangeleftCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_lanechangeright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_lanechangeright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_lanechangerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_lanechangerightCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_startplanner(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_startplanner(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_startplannerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_startplannerCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_staticobstacleavoidanceleft(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_staticobstacleavoidanceleft(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_staticobstacleavoidanceleftOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_staticobstacleavoidanceleftCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_staticobstacleavoidanceright(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_staticobstacleavoidanceright(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_staticobstacleavoidancerightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_staticobstacleavoidancerightCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::logging_demo::srv::ConfigLogger_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::DescribeParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::GetParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::GetParameterTypes_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::ListParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::SetParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign, retResult, retData, token);
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    void HandleDdsMethod(const dds::sub::AnyDataReader& reader)
    {
        dds::sub::DataReader<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request> _reader_ = reader;
        dds::sub::LoanedSamples<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request> _requests_;
        _requests_ = _reader_.take();
        for (auto& _request_ : _requests_)
        {
            if (_request_->info().valid())
            {
                auto _data_ = _request_.data().data();
                switch (_data_._d())
                {
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Hash :
                    {
                        Handleplanning_cooperatecommands_avoidancebylanechangeleft(_data_.planning_cooperatecommands_avoidancebylanechangeleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Hash :
                    {
                        Handleplanning_cooperatecommands_avoidancebylanechangeright(_data_.planning_cooperatecommands_avoidancebylanechangeright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Hash :
                    {
                        Handleplanning_cooperatecommands_goalplanner(_data_.planning_cooperatecommands_goalplanner(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Hash :
                    {
                        Handleplanning_cooperatecommands_lanechangeleft(_data_.planning_cooperatecommands_lanechangeleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Hash :
                    {
                        Handleplanning_cooperatecommands_lanechangeright(_data_.planning_cooperatecommands_lanechangeright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Hash :
                    {
                        Handleplanning_cooperatecommands_startplanner(_data_.planning_cooperatecommands_startplanner(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Hash :
                    {
                        Handleplanning_cooperatecommands_staticobstacleavoidanceleft(_data_.planning_cooperatecommands_staticobstacleavoidanceleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Hash :
                    {
                        Handleplanning_cooperatecommands_staticobstacleavoidanceright(_data_.planning_cooperatecommands_staticobstacleavoidanceright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Hash :
                    {
                        Handleplanning_enableautomode_avoidancebylanechangeleft(_data_.planning_enableautomode_avoidancebylanechangeleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Hash :
                    {
                        Handleplanning_enableautomode_avoidancebylanechangeright(_data_.planning_enableautomode_avoidancebylanechangeright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Hash :
                    {
                        Handleplanning_enableautomode_goalplanner(_data_.planning_enableautomode_goalplanner(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Hash :
                    {
                        Handleplanning_enableautomode_lanechangeleft(_data_.planning_enableautomode_lanechangeleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Hash :
                    {
                        Handleplanning_enableautomode_lanechangeright(_data_.planning_enableautomode_lanechangeright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Hash :
                    {
                        Handleplanning_enableautomode_startplanner(_data_.planning_enableautomode_startplanner(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Hash :
                    {
                        Handleplanning_enableautomode_staticobstacleavoidanceleft(_data_.planning_enableautomode_staticobstacleavoidanceleft(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Hash :
                    {
                        Handleplanning_enableautomode_staticobstacleavoidanceright(_data_.planning_enableautomode_staticobstacleavoidanceright(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(), _request_.data().header());
                        break;
                    }
                    default : break;
                }
            }
        }
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_avoidancebylanechangeleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_avoidancebylanechangeleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_avoidancebylanechangeleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_avoidancebylanechangeright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_avoidancebylanechangeright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_avoidancebylanechangeright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_goalplanner(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_goalplanner(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_goalplanner(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_lanechangeleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_lanechangeleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_lanechangeleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_lanechangeright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_lanechangeright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_lanechangeright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_startplanner(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_startplanner(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_startplanner(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_staticobstacleavoidanceleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_staticobstacleavoidanceleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_staticobstacleavoidanceleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_staticobstacleavoidanceright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_staticobstacleavoidanceright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_staticobstacleavoidanceright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_avoidancebylanechangeleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_avoidancebylanechangeleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_avoidancebylanechangeleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_avoidancebylanechangeright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_avoidancebylanechangeright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_avoidancebylanechangeright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_goalplanner(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_goalplanner(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_goalplanner(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_lanechangeleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_lanechangeleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_lanechangeleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_lanechangeright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_lanechangeright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_lanechangeright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_startplanner(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_startplanner(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_startplanner(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_staticobstacleavoidanceleft(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_staticobstacleavoidanceleft(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_staticobstacleavoidanceleft(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_staticobstacleavoidanceright(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_staticobstacleavoidanceright(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_enableautomode_staticobstacleavoidanceright(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Result _result_{};
        oss::type::logging_demo::srv::ConfigLogger_Request _req = oss::type::logging_demo::srv::ConfigLogger_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Out _out_args_;
            _out_args_.res() = oss::type::logging_demo::srv::ConfigLogger_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::DescribeParameters_Request _req = oss::type::rcl_interfaces::srv::DescribeParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::DescribeParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::GetParameters_Request _req = oss::type::rcl_interfaces::srv::GetParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::GetParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Result _result_{};
        oss::type::rcl_interfaces::srv::GetParameterTypes_Request _req = oss::type::rcl_interfaces::srv::GetParameterTypes_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::GetParameterTypes_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::ListParameters_Request _req = oss::type::rcl_interfaces::srv::ListParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::ListParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::SetParameters_Request _req = oss::type::rcl_interfaces::srv::SetParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::SetParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Result _result_{};
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Request _req = oss::type::rcl_interfaces::srv::SetParametersAtomically_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::SetParametersAtomically_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(_result_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Hash);
        dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    const std::string kplanning_cooperatecommands_avoidancebylanechangeleftCallSign{"planning_cooperatecommands_avoidancebylanechangeleft"};
    const std::string kplanning_cooperatecommands_avoidancebylanechangerightCallSign{"planning_cooperatecommands_avoidancebylanechangeright"};
    const std::string kplanning_cooperatecommands_goalplannerCallSign{"planning_cooperatecommands_goalplanner"};
    const std::string kplanning_cooperatecommands_lanechangeleftCallSign{"planning_cooperatecommands_lanechangeleft"};
    const std::string kplanning_cooperatecommands_lanechangerightCallSign{"planning_cooperatecommands_lanechangeright"};
    const std::string kplanning_cooperatecommands_startplannerCallSign{"planning_cooperatecommands_startplanner"};
    const std::string kplanning_cooperatecommands_staticobstacleavoidanceleftCallSign{"planning_cooperatecommands_staticobstacleavoidanceleft"};
    const std::string kplanning_cooperatecommands_staticobstacleavoidancerightCallSign{"planning_cooperatecommands_staticobstacleavoidanceright"};
    const std::string kplanning_enableautomode_avoidancebylanechangeleftCallSign{"planning_enableautomode_avoidancebylanechangeleft"};
    const std::string kplanning_enableautomode_avoidancebylanechangerightCallSign{"planning_enableautomode_avoidancebylanechangeright"};
    const std::string kplanning_enableautomode_goalplannerCallSign{"planning_enableautomode_goalplanner"};
    const std::string kplanning_enableautomode_lanechangeleftCallSign{"planning_enableautomode_lanechangeleft"};
    const std::string kplanning_enableautomode_lanechangerightCallSign{"planning_enableautomode_lanechangeright"};
    const std::string kplanning_enableautomode_startplannerCallSign{"planning_enableautomode_startplanner"};
    const std::string kplanning_enableautomode_staticobstacleavoidanceleftCallSign{"planning_enableautomode_staticobstacleavoidanceleft"};
    const std::string kplanning_enableautomode_staticobstacleavoidancerightCallSign{"planning_enableautomode_staticobstacleavoidanceright"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configloggerCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypesCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomicallyCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically"};
};
} /// namespace skeleton
} /// namespace BPP2BVP
} /// namespace srv
} /// namespace oss
#endif /// PARA_COM_GEN_OSS_SRV_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_SKELETON_H