///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : bvp_si_behaviorpathplanner_proxy.h
/// SERVICE INTERFACE NAME            : BVP_SI_behaviorpathplanner
/// GENERATED DATE                    : 2025-12-08 15:30:14
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_OSS_SRV_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_PROXY_H
#define PARA_COM_GEN_OSS_SRV_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_PROXY_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "bvp_si_behaviorpathplanner_common.h"
#include "para/com/proxy/proxy_interface.h"
/// @uptrace{SWS_CM_01005}
namespace oss
{
namespace srv
{
namespace BPP2BVP
{
/// @uptrace{SWS_CM_01007}
namespace proxy
{
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_avoidancebylanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_avoidancebylanechangeleft(const planning_automodestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_avoidancebylanechangeleft& operator=(const planning_automodestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_avoidancebylanechangeleft(planning_automodestatus_avoidancebylanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_avoidancebylanechangeleft& operator=(planning_automodestatus_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_avoidancebylanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_avoidancebylanechangeright(const planning_automodestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_avoidancebylanechangeright& operator=(const planning_automodestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_avoidancebylanechangeright(planning_automodestatus_avoidancebylanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_avoidancebylanechangeright& operator=(planning_automodestatus_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_goalplanner(const planning_automodestatus_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_goalplanner& operator=(const planning_automodestatus_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_goalplanner(planning_automodestatus_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_goalplanner& operator=(planning_automodestatus_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_lanechangeleft(const planning_automodestatus_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_lanechangeleft& operator=(const planning_automodestatus_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_lanechangeleft(planning_automodestatus_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_lanechangeleft& operator=(planning_automodestatus_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_lanechangeright(const planning_automodestatus_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_lanechangeright& operator=(const planning_automodestatus_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_lanechangeright(planning_automodestatus_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_lanechangeright& operator=(planning_automodestatus_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_startplanner() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_startplanner(const planning_automodestatus_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_startplanner& operator=(const planning_automodestatus_startplanner& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_startplanner(planning_automodestatus_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_startplanner& operator=(planning_automodestatus_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_staticobstacleavoidanceleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_staticobstacleavoidanceleft(const planning_automodestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_staticobstacleavoidanceleft& operator=(const planning_automodestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_staticobstacleavoidanceleft(planning_automodestatus_staticobstacleavoidanceleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_staticobstacleavoidanceleft& operator=(planning_automodestatus_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_staticobstacleavoidanceright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_staticobstacleavoidanceright(const planning_automodestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_staticobstacleavoidanceright& operator=(const planning_automodestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_staticobstacleavoidanceright(planning_automodestatus_staticobstacleavoidanceright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_staticobstacleavoidanceright& operator=(planning_automodestatus_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_avoidancebylanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_avoidancebylanechangeleft(const planning_cooperatestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_avoidancebylanechangeleft& operator=(const planning_cooperatestatus_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_avoidancebylanechangeleft(planning_cooperatestatus_avoidancebylanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_avoidancebylanechangeleft& operator=(planning_cooperatestatus_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_avoidancebylanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_avoidancebylanechangeright(const planning_cooperatestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_avoidancebylanechangeright& operator=(const planning_cooperatestatus_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_avoidancebylanechangeright(planning_cooperatestatus_avoidancebylanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_avoidancebylanechangeright& operator=(planning_cooperatestatus_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_goalplanner(const planning_cooperatestatus_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_goalplanner& operator=(const planning_cooperatestatus_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_goalplanner(planning_cooperatestatus_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_goalplanner& operator=(planning_cooperatestatus_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_lanechangeleft(const planning_cooperatestatus_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_lanechangeleft& operator=(const planning_cooperatestatus_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_lanechangeleft(planning_cooperatestatus_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_lanechangeleft& operator=(planning_cooperatestatus_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_lanechangeright(const planning_cooperatestatus_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_lanechangeright& operator=(const planning_cooperatestatus_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_lanechangeright(planning_cooperatestatus_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_lanechangeright& operator=(planning_cooperatestatus_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_startplanner() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_startplanner(const planning_cooperatestatus_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_startplanner& operator=(const planning_cooperatestatus_startplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_startplanner(planning_cooperatestatus_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_startplanner& operator=(planning_cooperatestatus_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_staticobstacleavoidanceleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_staticobstacleavoidanceleft(const planning_cooperatestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_staticobstacleavoidanceleft& operator=(const planning_cooperatestatus_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_staticobstacleavoidanceleft(planning_cooperatestatus_staticobstacleavoidanceleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_staticobstacleavoidanceleft& operator=(planning_cooperatestatus_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_staticobstacleavoidanceright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_staticobstacleavoidanceright(const planning_cooperatestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_staticobstacleavoidanceright& operator=(const planning_cooperatestatus_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_staticobstacleavoidanceright(planning_cooperatestatus_staticobstacleavoidanceright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_staticobstacleavoidanceright& operator=(planning_cooperatestatus_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_avoidancebylanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_avoidancebylanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_avoidancebylanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_avoidancebylanechangeleft(const planning_debug_objectsofinterest_avoidancebylanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_avoidancebylanechangeleft& operator=(const planning_debug_objectsofinterest_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_avoidancebylanechangeleft(planning_debug_objectsofinterest_avoidancebylanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_avoidancebylanechangeleft& operator=(planning_debug_objectsofinterest_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_avoidancebylanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_avoidancebylanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_avoidancebylanechangeright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_avoidancebylanechangeright(const planning_debug_objectsofinterest_avoidancebylanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_avoidancebylanechangeright& operator=(const planning_debug_objectsofinterest_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_avoidancebylanechangeright(planning_debug_objectsofinterest_avoidancebylanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_avoidancebylanechangeright& operator=(planning_debug_objectsofinterest_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_goalplanner(const planning_debug_objectsofinterest_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_goalplanner& operator=(const planning_debug_objectsofinterest_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_goalplanner(planning_debug_objectsofinterest_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_goalplanner& operator=(planning_debug_objectsofinterest_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_lanechangeleft(const planning_debug_objectsofinterest_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_lanechangeleft& operator=(const planning_debug_objectsofinterest_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_lanechangeleft(planning_debug_objectsofinterest_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_lanechangeleft& operator=(planning_debug_objectsofinterest_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_lanechangeright(const planning_debug_objectsofinterest_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_lanechangeright& operator=(const planning_debug_objectsofinterest_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_lanechangeright(planning_debug_objectsofinterest_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_lanechangeright& operator=(planning_debug_objectsofinterest_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_startplanner() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_startplanner(const planning_debug_objectsofinterest_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_startplanner& operator=(const planning_debug_objectsofinterest_startplanner& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_startplanner(planning_debug_objectsofinterest_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_startplanner& operator=(planning_debug_objectsofinterest_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_staticobstacleavoidanceleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_staticobstacleavoidanceleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_staticobstacleavoidanceleft() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceleft(const planning_debug_objectsofinterest_staticobstacleavoidanceleft& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceleft& operator=(const planning_debug_objectsofinterest_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceleft(planning_debug_objectsofinterest_staticobstacleavoidanceleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceleft& operator=(planning_debug_objectsofinterest_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_staticobstacleavoidanceright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_staticobstacleavoidanceright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_staticobstacleavoidanceright() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceright(const planning_debug_objectsofinterest_staticobstacleavoidanceright& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceright& operator=(const planning_debug_objectsofinterest_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_staticobstacleavoidanceright(planning_debug_objectsofinterest_staticobstacleavoidanceright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_staticobstacleavoidanceright& operator=(planning_debug_objectsofinterest_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00003}
class planning_hazardlightscmd
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_vehicle_msgs::msg::HazardLightsCommand;
    /// @brief Constructor
    explicit planning_hazardlightscmd(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_hazardlightscmd() = default;
    /// @brief Delete copy constructor
    planning_hazardlightscmd(const planning_hazardlightscmd& other) = delete;
    /// @brief Delete copy assignment
    planning_hazardlightscmd& operator=(const planning_hazardlightscmd& other) = delete;
    /// @brief Move constructor
    planning_hazardlightscmd(planning_hazardlightscmd&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_hazardlightscmd& operator=(planning_hazardlightscmd&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::HazardLightsCommandEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::HazardLightsCommandEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_vehicle_msgs::msg::HazardLightsCommand_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_hazardlightscmd"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_avoidancebylanechange(const planning_pathcandidate_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_avoidancebylanechange& operator=(const planning_pathcandidate_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_avoidancebylanechange(planning_pathcandidate_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_avoidancebylanechange& operator=(planning_pathcandidate_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_goalplanner(const planning_pathcandidate_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_goalplanner& operator=(const planning_pathcandidate_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_goalplanner(planning_pathcandidate_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_goalplanner& operator=(planning_pathcandidate_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_lanechangeleft(const planning_pathcandidate_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_lanechangeleft& operator=(const planning_pathcandidate_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_lanechangeleft(planning_pathcandidate_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_lanechangeleft& operator=(planning_pathcandidate_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_lanechangeright(const planning_pathcandidate_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_lanechangeright& operator=(const planning_pathcandidate_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_lanechangeright(planning_pathcandidate_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_lanechangeright& operator=(planning_pathcandidate_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_sideshift() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_sideshift(const planning_pathcandidate_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_sideshift& operator=(const planning_pathcandidate_sideshift& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_sideshift(planning_pathcandidate_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_sideshift& operator=(planning_pathcandidate_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_startplanner() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_startplanner(const planning_pathcandidate_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_startplanner& operator=(const planning_pathcandidate_startplanner& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_startplanner(planning_pathcandidate_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_startplanner& operator=(planning_pathcandidate_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathcandidate_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathcandidate_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathcandidate_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_pathcandidate_staticobstacleavoidance(const planning_pathcandidate_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_pathcandidate_staticobstacleavoidance& operator=(const planning_pathcandidate_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_pathcandidate_staticobstacleavoidance(planning_pathcandidate_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathcandidate_staticobstacleavoidance& operator=(planning_pathcandidate_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathcandidate_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_pathreference_avoidancebylanechange(const planning_pathreference_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_avoidancebylanechange& operator=(const planning_pathreference_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_pathreference_avoidancebylanechange(planning_pathreference_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_avoidancebylanechange& operator=(planning_pathreference_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_pathreference_goalplanner(const planning_pathreference_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_goalplanner& operator=(const planning_pathreference_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_pathreference_goalplanner(planning_pathreference_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_goalplanner& operator=(planning_pathreference_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_pathreference_lanechangeleft(const planning_pathreference_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_lanechangeleft& operator=(const planning_pathreference_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_pathreference_lanechangeleft(planning_pathreference_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_lanechangeleft& operator=(planning_pathreference_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_pathreference_lanechangeright(const planning_pathreference_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_lanechangeright& operator=(const planning_pathreference_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_pathreference_lanechangeright(planning_pathreference_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_lanechangeright& operator=(planning_pathreference_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_sideshift() = default;
    /// @brief Delete copy constructor
    planning_pathreference_sideshift(const planning_pathreference_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_sideshift& operator=(const planning_pathreference_sideshift& other) = delete;
    /// @brief Move constructor
    planning_pathreference_sideshift(planning_pathreference_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_sideshift& operator=(planning_pathreference_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_startplanner() = default;
    /// @brief Delete copy constructor
    planning_pathreference_startplanner(const planning_pathreference_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_startplanner& operator=(const planning_pathreference_startplanner& other) = delete;
    /// @brief Move constructor
    planning_pathreference_startplanner(planning_pathreference_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_startplanner& operator=(planning_pathreference_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_pathreference_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_pathreference_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_pathreference_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_pathreference_staticobstacleavoidance(const planning_pathreference_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_pathreference_staticobstacleavoidance& operator=(const planning_pathreference_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_pathreference_staticobstacleavoidance(planning_pathreference_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_pathreference_staticobstacleavoidance& operator=(planning_pathreference_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_pathreference_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_avoidancebylanechange(const planning_planningfactors_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_avoidancebylanechange& operator=(const planning_planningfactors_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_avoidancebylanechange(planning_planningfactors_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_avoidancebylanechange& operator=(planning_planningfactors_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_behaviorpathplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_behaviorpathplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_behaviorpathplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_behaviorpathplanner(const planning_planningfactors_behaviorpathplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_behaviorpathplanner& operator=(const planning_planningfactors_behaviorpathplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_behaviorpathplanner(planning_planningfactors_behaviorpathplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_behaviorpathplanner& operator=(planning_planningfactors_behaviorpathplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_behaviorpathplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_goalplanner(const planning_planningfactors_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_goalplanner& operator=(const planning_planningfactors_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_goalplanner(planning_planningfactors_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_goalplanner& operator=(planning_planningfactors_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_lanechangeleft(const planning_planningfactors_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_lanechangeleft& operator=(const planning_planningfactors_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_lanechangeleft(planning_planningfactors_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_lanechangeleft& operator=(planning_planningfactors_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_lanechangeright(const planning_planningfactors_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_lanechangeright& operator=(const planning_planningfactors_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_lanechangeright(planning_planningfactors_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_lanechangeright& operator=(planning_planningfactors_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_sideshift() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_sideshift(const planning_planningfactors_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_sideshift& operator=(const planning_planningfactors_sideshift& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_sideshift(planning_planningfactors_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_sideshift& operator=(planning_planningfactors_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_startplanner() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_startplanner(const planning_planningfactors_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_startplanner& operator=(const planning_planningfactors_startplanner& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_startplanner(planning_planningfactors_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_startplanner& operator=(planning_planningfactors_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_staticobstacleavoidance(const planning_planningfactors_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_staticobstacleavoidance& operator=(const planning_planningfactors_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_staticobstacleavoidance(planning_planningfactors_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_staticobstacleavoidance& operator=(planning_planningfactors_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::AvoidanceDebugMsgArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::AvoidanceDebugMsgArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::AvoidanceDebugMsgArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::AvoidanceDebugMsgArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::RerouteAvailability;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::RerouteAvailabilityEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::RerouteAvailabilityEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::RerouteAvailability_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PathWithLaneId;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(const planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PathWithLaneIdEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PathWithLaneIdEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PathWithLaneId_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_modifiedgoal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::PoseWithUuidStamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_modifiedgoal(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_modifiedgoal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_modifiedgoal(const planning_scenarioplanning_modifiedgoal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_modifiedgoal& operator=(const planning_scenarioplanning_modifiedgoal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_modifiedgoal(planning_scenarioplanning_modifiedgoal&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_modifiedgoal& operator=(planning_scenarioplanning_modifiedgoal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::PoseWithUuidStampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::PoseWithUuidStampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::PoseWithUuidStamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_modifiedgoal"};
};
/// @uptrace{SWS_CM_00003}
class planning_turnindicatorscmd
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::TurnIndicatorsCommand;
    /// @brief Constructor
    explicit planning_turnindicatorscmd(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_turnindicatorscmd() = default;
    /// @brief Delete copy constructor
    planning_turnindicatorscmd(const planning_turnindicatorscmd& other) = delete;
    /// @brief Delete copy assignment
    planning_turnindicatorscmd& operator=(const planning_turnindicatorscmd& other) = delete;
    /// @brief Move constructor
    planning_turnindicatorscmd(planning_turnindicatorscmd&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_turnindicatorscmd& operator=(planning_turnindicatorscmd&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BPP2BVP::TurnIndicatorsCommandEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BPP2BVP::TurnIndicatorsCommandEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::TurnIndicatorsCommand_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_turnindicatorscmd"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_01015}
namespace methods
{
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_avoidancebylanechangeleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_avoidancebylanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_avoidancebylanechangeleft() = default;
    /// @brief
    planning_cooperatecommands_avoidancebylanechangeleft(const planning_cooperatecommands_avoidancebylanechangeleft& other) = delete;
    planning_cooperatecommands_avoidancebylanechangeleft& operator=(const planning_cooperatecommands_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_avoidancebylanechangeleft(planning_cooperatecommands_avoidancebylanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_avoidancebylanechangeleft& operator=(planning_cooperatecommands_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_avoidancebylanechangeleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Out _response_ = data.result();
            methods::planning_cooperatecommands_avoidancebylanechangeleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_avoidancebylanechangeleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_avoidancebylanechangeright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_avoidancebylanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_avoidancebylanechangeright() = default;
    /// @brief
    planning_cooperatecommands_avoidancebylanechangeright(const planning_cooperatecommands_avoidancebylanechangeright& other) = delete;
    planning_cooperatecommands_avoidancebylanechangeright& operator=(const planning_cooperatecommands_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_avoidancebylanechangeright(planning_cooperatecommands_avoidancebylanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_avoidancebylanechangeright& operator=(planning_cooperatecommands_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_avoidancebylanechangeright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Out _response_ = data.result();
            methods::planning_cooperatecommands_avoidancebylanechangeright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_avoidancebylanechangeright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_avoidancebylanechangeright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_goalplanner
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_goalplanner() = default;
    /// @brief
    planning_cooperatecommands_goalplanner(const planning_cooperatecommands_goalplanner& other) = delete;
    planning_cooperatecommands_goalplanner& operator=(const planning_cooperatecommands_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_goalplanner(planning_cooperatecommands_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_goalplanner& operator=(planning_cooperatecommands_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_goalplanner(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_goalplanner::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Out _response_ = data.result();
            methods::planning_cooperatecommands_goalplanner::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_goalplanner::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_goalplanner::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_goalplanner::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_goalplanner::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_goalplanner"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_lanechangeleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_lanechangeleft() = default;
    /// @brief
    planning_cooperatecommands_lanechangeleft(const planning_cooperatecommands_lanechangeleft& other) = delete;
    planning_cooperatecommands_lanechangeleft& operator=(const planning_cooperatecommands_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_lanechangeleft(planning_cooperatecommands_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_lanechangeleft& operator=(planning_cooperatecommands_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_lanechangeleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Out _response_ = data.result();
            methods::planning_cooperatecommands_lanechangeleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_lanechangeleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_lanechangeleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_lanechangeright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_lanechangeright() = default;
    /// @brief
    planning_cooperatecommands_lanechangeright(const planning_cooperatecommands_lanechangeright& other) = delete;
    planning_cooperatecommands_lanechangeright& operator=(const planning_cooperatecommands_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_lanechangeright(planning_cooperatecommands_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_lanechangeright& operator=(planning_cooperatecommands_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_lanechangeright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Out _response_ = data.result();
            methods::planning_cooperatecommands_lanechangeright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_lanechangeright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_lanechangeright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_lanechangeright"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_startplanner
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_startplanner() = default;
    /// @brief
    planning_cooperatecommands_startplanner(const planning_cooperatecommands_startplanner& other) = delete;
    planning_cooperatecommands_startplanner& operator=(const planning_cooperatecommands_startplanner& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_startplanner(planning_cooperatecommands_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_startplanner& operator=(planning_cooperatecommands_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_startplanner(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_startplanner::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Out _response_ = data.result();
            methods::planning_cooperatecommands_startplanner::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_startplanner::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_startplanner::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_startplanner::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_startplanner::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_startplanner"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_staticobstacleavoidanceleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_staticobstacleavoidanceleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_staticobstacleavoidanceleft() = default;
    /// @brief
    planning_cooperatecommands_staticobstacleavoidanceleft(const planning_cooperatecommands_staticobstacleavoidanceleft& other) = delete;
    planning_cooperatecommands_staticobstacleavoidanceleft& operator=(const planning_cooperatecommands_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_staticobstacleavoidanceleft(planning_cooperatecommands_staticobstacleavoidanceleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_staticobstacleavoidanceleft& operator=(planning_cooperatecommands_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_staticobstacleavoidanceleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Out _response_ = data.result();
            methods::planning_cooperatecommands_staticobstacleavoidanceleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_staticobstacleavoidanceleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_staticobstacleavoidanceright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_staticobstacleavoidanceright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_staticobstacleavoidanceright() = default;
    /// @brief
    planning_cooperatecommands_staticobstacleavoidanceright(const planning_cooperatecommands_staticobstacleavoidanceright& other) = delete;
    planning_cooperatecommands_staticobstacleavoidanceright& operator=(const planning_cooperatecommands_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_staticobstacleavoidanceright(planning_cooperatecommands_staticobstacleavoidanceright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_staticobstacleavoidanceright& operator=(planning_cooperatecommands_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_staticobstacleavoidanceright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Out _response_ = data.result();
            methods::planning_cooperatecommands_staticobstacleavoidanceright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_staticobstacleavoidanceright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_staticobstacleavoidanceright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_avoidancebylanechangeleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_avoidancebylanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_avoidancebylanechangeleft() = default;
    /// @brief
    planning_enableautomode_avoidancebylanechangeleft(const planning_enableautomode_avoidancebylanechangeleft& other) = delete;
    planning_enableautomode_avoidancebylanechangeleft& operator=(const planning_enableautomode_avoidancebylanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_avoidancebylanechangeleft(planning_enableautomode_avoidancebylanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_avoidancebylanechangeleft& operator=(planning_enableautomode_avoidancebylanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_avoidancebylanechangeleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Out _response_ = data.result();
            methods::planning_enableautomode_avoidancebylanechangeleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_avoidancebylanechangeleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_avoidancebylanechangeleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_avoidancebylanechangeright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_avoidancebylanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_avoidancebylanechangeright() = default;
    /// @brief
    planning_enableautomode_avoidancebylanechangeright(const planning_enableautomode_avoidancebylanechangeright& other) = delete;
    planning_enableautomode_avoidancebylanechangeright& operator=(const planning_enableautomode_avoidancebylanechangeright& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_avoidancebylanechangeright(planning_enableautomode_avoidancebylanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_avoidancebylanechangeright& operator=(planning_enableautomode_avoidancebylanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_avoidancebylanechangeright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Out _response_ = data.result();
            methods::planning_enableautomode_avoidancebylanechangeright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_avoidancebylanechangeright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_avoidancebylanechangeright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_avoidancebylanechangeright"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_goalplanner
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_goalplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_goalplanner() = default;
    /// @brief
    planning_enableautomode_goalplanner(const planning_enableautomode_goalplanner& other) = delete;
    planning_enableautomode_goalplanner& operator=(const planning_enableautomode_goalplanner& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_goalplanner(planning_enableautomode_goalplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_goalplanner& operator=(planning_enableautomode_goalplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_goalplanner(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_goalplanner::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Out _response_ = data.result();
            methods::planning_enableautomode_goalplanner::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_goalplanner::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_goalplanner::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_goalplanner::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_goalplanner::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_goalplanner"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_lanechangeleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_lanechangeleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_lanechangeleft() = default;
    /// @brief
    planning_enableautomode_lanechangeleft(const planning_enableautomode_lanechangeleft& other) = delete;
    planning_enableautomode_lanechangeleft& operator=(const planning_enableautomode_lanechangeleft& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_lanechangeleft(planning_enableautomode_lanechangeleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_lanechangeleft& operator=(planning_enableautomode_lanechangeleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_lanechangeleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_lanechangeleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Out _response_ = data.result();
            methods::planning_enableautomode_lanechangeleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_lanechangeleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_lanechangeleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_lanechangeleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_lanechangeleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_lanechangeleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_lanechangeright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_lanechangeright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_lanechangeright() = default;
    /// @brief
    planning_enableautomode_lanechangeright(const planning_enableautomode_lanechangeright& other) = delete;
    planning_enableautomode_lanechangeright& operator=(const planning_enableautomode_lanechangeright& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_lanechangeright(planning_enableautomode_lanechangeright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_lanechangeright& operator=(planning_enableautomode_lanechangeright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_lanechangeright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_lanechangeright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Out _response_ = data.result();
            methods::planning_enableautomode_lanechangeright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_lanechangeright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_lanechangeright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_lanechangeright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_lanechangeright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_lanechangeright"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_startplanner
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_startplanner(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_startplanner() = default;
    /// @brief
    planning_enableautomode_startplanner(const planning_enableautomode_startplanner& other) = delete;
    planning_enableautomode_startplanner& operator=(const planning_enableautomode_startplanner& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_startplanner(planning_enableautomode_startplanner&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_startplanner& operator=(planning_enableautomode_startplanner&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_startplanner(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_startplanner::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Out _response_ = data.result();
            methods::planning_enableautomode_startplanner::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_startplanner::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_startplanner::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_startplanner::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_startplanner::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_startplanner"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_staticobstacleavoidanceleft
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_staticobstacleavoidanceleft(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_staticobstacleavoidanceleft() = default;
    /// @brief
    planning_enableautomode_staticobstacleavoidanceleft(const planning_enableautomode_staticobstacleavoidanceleft& other) = delete;
    planning_enableautomode_staticobstacleavoidanceleft& operator=(const planning_enableautomode_staticobstacleavoidanceleft& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_staticobstacleavoidanceleft(planning_enableautomode_staticobstacleavoidanceleft&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_staticobstacleavoidanceleft& operator=(planning_enableautomode_staticobstacleavoidanceleft&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_staticobstacleavoidanceleft(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceleft::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Out _response_ = data.result();
            methods::planning_enableautomode_staticobstacleavoidanceleft::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceleft::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceleft::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_staticobstacleavoidanceleft::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceleft::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_staticobstacleavoidanceleft"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_staticobstacleavoidanceright
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_staticobstacleavoidanceright(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_staticobstacleavoidanceright() = default;
    /// @brief
    planning_enableautomode_staticobstacleavoidanceright(const planning_enableautomode_staticobstacleavoidanceright& other) = delete;
    planning_enableautomode_staticobstacleavoidanceright& operator=(const planning_enableautomode_staticobstacleavoidanceright& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_staticobstacleavoidanceright(planning_enableautomode_staticobstacleavoidanceright&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_staticobstacleavoidanceright& operator=(planning_enableautomode_staticobstacleavoidanceright&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_enableautomode_staticobstacleavoidanceright(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceright::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Out _response_ = data.result();
            methods::planning_enableautomode_staticobstacleavoidanceright::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceright::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceright::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_staticobstacleavoidanceright::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_staticobstacleavoidanceright::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_staticobstacleavoidanceright"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::logging_demo::srv::ConfigLogger_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_In _in_args_;
                _in_args_.req() = oss::type::logging_demo::srv::ConfigLogger_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output _out_args_;
            _out_args_.res = oss::type::logging_demo::srv::ConfigLogger_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::DescribeParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::DescribeParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::DescribeParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameterTypes_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameterTypes_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameterTypes_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::ListParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::ListParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::ListParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParametersAtomically_Request_ConvertToDdsType(req);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(_in_args_, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Hash);
                dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParametersAtomically_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically"};
};
} /// namespace methods
/// @uptrace{SWS_CM_00004}
class BVP_SI_behaviorpathplannerProxy
{
public: 
    /// @uptrace{SWS_CM_00312}
    class HandleType
    {
    public:
        HandleType() = default;
        HandleType(ara::core::InstanceSpecifier instanceSpecifier, para::com::ServiceHandle service)
            : mInstanceSpecifier(std::move(instanceSpecifier))
            , mServiceHandle(service)
        {
        }
        ~HandleType() = default;
        /// @uptrace{SWS_CM_00317}
        HandleType(const HandleType& other) = default;
        HandleType& operator=(const HandleType& other) = default;
        /// @uptrace{SWS_CM_00318}
        HandleType(HandleType&& other) = default;
        HandleType& operator=(HandleType&& other) = default;
        /// @brief Return instance specifier
        ara::core::InstanceSpecifier GetInstanceSpecifier()
        {
            return mInstanceSpecifier;
        }
        /// @brief Return handle for bound service
        para::com::ServiceHandle GetServiceHandle()
        {
            return mServiceHandle;
        }
        /// @brief Is equal to operator
        inline bool operator==(const HandleType& other) const
        {
            return mInstanceSpecifier == other.mInstanceSpecifier && mServiceHandle == other.mServiceHandle;
        }
        /// @brief Less than operator
        inline bool operator<(const HandleType& other) const
        {
            return mServiceHandle.version < other.mServiceHandle.version;
        }
        
    private:
        ara::core::InstanceSpecifier mInstanceSpecifier{"undefined"};
        para::com::ServiceHandle mServiceHandle;
    };
    /// @brief Requests "FindService" message to Communication Management with callback
    /// @uptrace{SWS_CM_00623}
    static ara::core::Result<ara::com::FindServiceHandle> StartFindService(ara::com::FindServiceHandler<BVP_SI_behaviorpathplannerProxy::HandleType> handler, ara::core::InstanceSpecifier instanceSpec)
    {
        switch (para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyDdsInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyDdsInterface::StartFindService(instanceSpec, findCallback);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::FindServiceHandle>::FromError(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Send "FindService" message to Communication Management at once
    /// @uptrace{SWS_CM_00622}
    static ara::core::Result<ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType>> FindService(ara::core::InstanceSpecifier instanceSpec)
    {
        switch(para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto result = para::com::ProxyDdsInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::ServiceHandleContainer<BVP_SI_behaviorpathplannerProxy::HandleType>>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Constructor
    /// @note This function shall be called after processing of FindService/StartFindService was completed
    /// @uptrace{SWS_CM_00004, SWS_CM_00131}
    explicit BVP_SI_behaviorpathplannerProxy(HandleType& handle)
        : mHandle(handle)
        , mInterface(std::make_unique<para::com::ProxyInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , mDdsInterface(std::make_unique<para::com::ProxyDdsInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , planning_automodestatus_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_hazardlightscmd(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathcandidate_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_pathreference_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_behaviorpathplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_modifiedgoal(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_turnindicatorscmd(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_avoidancebylanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_avoidancebylanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_goalplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_lanechangeleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_lanechangeright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_startplanner(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_staticobstacleavoidanceleft(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_staticobstacleavoidanceright(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
    {
        #ifdef PARA_DDS_IMPLEMENTATION
        if (mHandle.GetServiceHandle().protocol == para::com::ServiceProtocol::kDds)
        {
            mDdsInterface->CreateMethods<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Request, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply>();
            auto methodReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetMethodPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeleft_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_avoidancebylanechangeleft();
                                planning_cooperatecommands_avoidancebylanechangeleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_avoidancebylanechangeright_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_avoidancebylanechangeright();
                                planning_cooperatecommands_avoidancebylanechangeright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_goalplanner_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_goalplanner();
                                planning_cooperatecommands_goalplanner.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeleft_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_lanechangeleft();
                                planning_cooperatecommands_lanechangeleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_lanechangeright_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_lanechangeright();
                                planning_cooperatecommands_lanechangeright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_startplanner_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_startplanner();
                                planning_cooperatecommands_startplanner.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceleft_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_staticobstacleavoidanceleft();
                                planning_cooperatecommands_staticobstacleavoidanceleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_cooperatecommands_staticobstacleavoidanceright_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_staticobstacleavoidanceright();
                                planning_cooperatecommands_staticobstacleavoidanceright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeleft_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_avoidancebylanechangeleft();
                                planning_enableautomode_avoidancebylanechangeleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_avoidancebylanechangeright_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_avoidancebylanechangeright();
                                planning_enableautomode_avoidancebylanechangeright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_goalplanner_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_goalplanner();
                                planning_enableautomode_goalplanner.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeleft_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_lanechangeleft();
                                planning_enableautomode_lanechangeleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_lanechangeright_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_lanechangeright();
                                planning_enableautomode_lanechangeright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_startplanner_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_startplanner();
                                planning_enableautomode_startplanner.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceleft_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_staticobstacleavoidanceleft();
                                planning_enableautomode_staticobstacleavoidanceleft.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_enableautomode_staticobstacleavoidanceright_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_staticobstacleavoidanceright();
                                planning_enableautomode_staticobstacleavoidanceright.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetMethodReturnHandler(methodReplyHandler);
            mDdsInterface->CreateFields<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerField_Request, dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerField_Reply>();
            auto fieldReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerField_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::BPP2BVP::BVP_SI_behaviorpathplannerField_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetFieldPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetFieldReturnHandler(fieldReplyHandler);
        }
        #endif /// PARA_DDS_IMPLEMENTATION
    }
    /// @brief Destructor
    /// @uptrace{SWS_CM_10446}
    ~BVP_SI_behaviorpathplannerProxy() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00136}
    BVP_SI_behaviorpathplannerProxy(BVP_SI_behaviorpathplannerProxy& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00136}
    BVP_SI_behaviorpathplannerProxy& operator=(const BVP_SI_behaviorpathplannerProxy& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00137}
    BVP_SI_behaviorpathplannerProxy(BVP_SI_behaviorpathplannerProxy&& other) noexcept
        : mHandle(std::move(other.mHandle))
        , mInterface(std::move(other.mInterface))
        , mDdsInterface(std::move(other.mDdsInterface))
        , planning_automodestatus_avoidancebylanechangeleft(std::move(other.planning_automodestatus_avoidancebylanechangeleft))
        , planning_automodestatus_avoidancebylanechangeright(std::move(other.planning_automodestatus_avoidancebylanechangeright))
        , planning_automodestatus_goalplanner(std::move(other.planning_automodestatus_goalplanner))
        , planning_automodestatus_lanechangeleft(std::move(other.planning_automodestatus_lanechangeleft))
        , planning_automodestatus_lanechangeright(std::move(other.planning_automodestatus_lanechangeright))
        , planning_automodestatus_startplanner(std::move(other.planning_automodestatus_startplanner))
        , planning_automodestatus_staticobstacleavoidanceleft(std::move(other.planning_automodestatus_staticobstacleavoidanceleft))
        , planning_automodestatus_staticobstacleavoidanceright(std::move(other.planning_automodestatus_staticobstacleavoidanceright))
        , planning_cooperatestatus_avoidancebylanechangeleft(std::move(other.planning_cooperatestatus_avoidancebylanechangeleft))
        , planning_cooperatestatus_avoidancebylanechangeright(std::move(other.planning_cooperatestatus_avoidancebylanechangeright))
        , planning_cooperatestatus_goalplanner(std::move(other.planning_cooperatestatus_goalplanner))
        , planning_cooperatestatus_lanechangeleft(std::move(other.planning_cooperatestatus_lanechangeleft))
        , planning_cooperatestatus_lanechangeright(std::move(other.planning_cooperatestatus_lanechangeright))
        , planning_cooperatestatus_startplanner(std::move(other.planning_cooperatestatus_startplanner))
        , planning_cooperatestatus_staticobstacleavoidanceleft(std::move(other.planning_cooperatestatus_staticobstacleavoidanceleft))
        , planning_cooperatestatus_staticobstacleavoidanceright(std::move(other.planning_cooperatestatus_staticobstacleavoidanceright))
        , planning_debug_objectsofinterest_avoidancebylanechangeleft(std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeleft))
        , planning_debug_objectsofinterest_avoidancebylanechangeright(std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeright))
        , planning_debug_objectsofinterest_goalplanner(std::move(other.planning_debug_objectsofinterest_goalplanner))
        , planning_debug_objectsofinterest_lanechangeleft(std::move(other.planning_debug_objectsofinterest_lanechangeleft))
        , planning_debug_objectsofinterest_lanechangeright(std::move(other.planning_debug_objectsofinterest_lanechangeright))
        , planning_debug_objectsofinterest_startplanner(std::move(other.planning_debug_objectsofinterest_startplanner))
        , planning_debug_objectsofinterest_staticobstacleavoidanceleft(std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceleft))
        , planning_debug_objectsofinterest_staticobstacleavoidanceright(std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceright))
        , planning_hazardlightscmd(std::move(other.planning_hazardlightscmd))
        , planning_pathcandidate_avoidancebylanechange(std::move(other.planning_pathcandidate_avoidancebylanechange))
        , planning_pathcandidate_goalplanner(std::move(other.planning_pathcandidate_goalplanner))
        , planning_pathcandidate_lanechangeleft(std::move(other.planning_pathcandidate_lanechangeleft))
        , planning_pathcandidate_lanechangeright(std::move(other.planning_pathcandidate_lanechangeright))
        , planning_pathcandidate_sideshift(std::move(other.planning_pathcandidate_sideshift))
        , planning_pathcandidate_startplanner(std::move(other.planning_pathcandidate_startplanner))
        , planning_pathcandidate_staticobstacleavoidance(std::move(other.planning_pathcandidate_staticobstacleavoidance))
        , planning_pathreference_avoidancebylanechange(std::move(other.planning_pathreference_avoidancebylanechange))
        , planning_pathreference_goalplanner(std::move(other.planning_pathreference_goalplanner))
        , planning_pathreference_lanechangeleft(std::move(other.planning_pathreference_lanechangeleft))
        , planning_pathreference_lanechangeright(std::move(other.planning_pathreference_lanechangeright))
        , planning_pathreference_sideshift(std::move(other.planning_pathreference_sideshift))
        , planning_pathreference_startplanner(std::move(other.planning_pathreference_startplanner))
        , planning_pathreference_staticobstacleavoidance(std::move(other.planning_pathreference_staticobstacleavoidance))
        , planning_planningfactors_avoidancebylanechange(std::move(other.planning_planningfactors_avoidancebylanechange))
        , planning_planningfactors_behaviorpathplanner(std::move(other.planning_planningfactors_behaviorpathplanner))
        , planning_planningfactors_goalplanner(std::move(other.planning_planningfactors_goalplanner))
        , planning_planningfactors_lanechangeleft(std::move(other.planning_planningfactors_lanechangeleft))
        , planning_planningfactors_lanechangeright(std::move(other.planning_planningfactors_lanechangeright))
        , planning_planningfactors_sideshift(std::move(other.planning_planningfactors_sideshift))
        , planning_planningfactors_startplanner(std::move(other.planning_planningfactors_startplanner))
        , planning_planningfactors_staticobstacleavoidance(std::move(other.planning_planningfactors_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance))
        , planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid))
        , planning_scenarioplanning_modifiedgoal(std::move(other.planning_scenarioplanning_modifiedgoal))
        , planning_turnindicatorscmd(std::move(other.planning_turnindicatorscmd))
        , planning_cooperatecommands_avoidancebylanechangeleft(std::move(other.planning_cooperatecommands_avoidancebylanechangeleft))
        , planning_cooperatecommands_avoidancebylanechangeright(std::move(other.planning_cooperatecommands_avoidancebylanechangeright))
        , planning_cooperatecommands_goalplanner(std::move(other.planning_cooperatecommands_goalplanner))
        , planning_cooperatecommands_lanechangeleft(std::move(other.planning_cooperatecommands_lanechangeleft))
        , planning_cooperatecommands_lanechangeright(std::move(other.planning_cooperatecommands_lanechangeright))
        , planning_cooperatecommands_startplanner(std::move(other.planning_cooperatecommands_startplanner))
        , planning_cooperatecommands_staticobstacleavoidanceleft(std::move(other.planning_cooperatecommands_staticobstacleavoidanceleft))
        , planning_cooperatecommands_staticobstacleavoidanceright(std::move(other.planning_cooperatecommands_staticobstacleavoidanceright))
        , planning_enableautomode_avoidancebylanechangeleft(std::move(other.planning_enableautomode_avoidancebylanechangeleft))
        , planning_enableautomode_avoidancebylanechangeright(std::move(other.planning_enableautomode_avoidancebylanechangeright))
        , planning_enableautomode_goalplanner(std::move(other.planning_enableautomode_goalplanner))
        , planning_enableautomode_lanechangeleft(std::move(other.planning_enableautomode_lanechangeleft))
        , planning_enableautomode_lanechangeright(std::move(other.planning_enableautomode_lanechangeright))
        , planning_enableautomode_startplanner(std::move(other.planning_enableautomode_startplanner))
        , planning_enableautomode_staticobstacleavoidanceleft(std::move(other.planning_enableautomode_staticobstacleavoidanceleft))
        , planning_enableautomode_staticobstacleavoidanceright(std::move(other.planning_enableautomode_staticobstacleavoidanceright))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically))
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00137}
    BVP_SI_behaviorpathplannerProxy& operator=(BVP_SI_behaviorpathplannerProxy&& other) noexcept
    {
        mHandle = std::move(other.mHandle);
        mInterface = std::move(other.mInterface);
        mDdsInterface = std::move(other.mDdsInterface);
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        planning_automodestatus_avoidancebylanechangeleft = std::move(other.planning_automodestatus_avoidancebylanechangeleft);
        planning_automodestatus_avoidancebylanechangeright = std::move(other.planning_automodestatus_avoidancebylanechangeright);
        planning_automodestatus_goalplanner = std::move(other.planning_automodestatus_goalplanner);
        planning_automodestatus_lanechangeleft = std::move(other.planning_automodestatus_lanechangeleft);
        planning_automodestatus_lanechangeright = std::move(other.planning_automodestatus_lanechangeright);
        planning_automodestatus_startplanner = std::move(other.planning_automodestatus_startplanner);
        planning_automodestatus_staticobstacleavoidanceleft = std::move(other.planning_automodestatus_staticobstacleavoidanceleft);
        planning_automodestatus_staticobstacleavoidanceright = std::move(other.planning_automodestatus_staticobstacleavoidanceright);
        planning_cooperatestatus_avoidancebylanechangeleft = std::move(other.planning_cooperatestatus_avoidancebylanechangeleft);
        planning_cooperatestatus_avoidancebylanechangeright = std::move(other.planning_cooperatestatus_avoidancebylanechangeright);
        planning_cooperatestatus_goalplanner = std::move(other.planning_cooperatestatus_goalplanner);
        planning_cooperatestatus_lanechangeleft = std::move(other.planning_cooperatestatus_lanechangeleft);
        planning_cooperatestatus_lanechangeright = std::move(other.planning_cooperatestatus_lanechangeright);
        planning_cooperatestatus_startplanner = std::move(other.planning_cooperatestatus_startplanner);
        planning_cooperatestatus_staticobstacleavoidanceleft = std::move(other.planning_cooperatestatus_staticobstacleavoidanceleft);
        planning_cooperatestatus_staticobstacleavoidanceright = std::move(other.planning_cooperatestatus_staticobstacleavoidanceright);
        planning_debug_objectsofinterest_avoidancebylanechangeleft = std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeleft);
        planning_debug_objectsofinterest_avoidancebylanechangeright = std::move(other.planning_debug_objectsofinterest_avoidancebylanechangeright);
        planning_debug_objectsofinterest_goalplanner = std::move(other.planning_debug_objectsofinterest_goalplanner);
        planning_debug_objectsofinterest_lanechangeleft = std::move(other.planning_debug_objectsofinterest_lanechangeleft);
        planning_debug_objectsofinterest_lanechangeright = std::move(other.planning_debug_objectsofinterest_lanechangeright);
        planning_debug_objectsofinterest_startplanner = std::move(other.planning_debug_objectsofinterest_startplanner);
        planning_debug_objectsofinterest_staticobstacleavoidanceleft = std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceleft);
        planning_debug_objectsofinterest_staticobstacleavoidanceright = std::move(other.planning_debug_objectsofinterest_staticobstacleavoidanceright);
        planning_hazardlightscmd = std::move(other.planning_hazardlightscmd);
        planning_pathcandidate_avoidancebylanechange = std::move(other.planning_pathcandidate_avoidancebylanechange);
        planning_pathcandidate_goalplanner = std::move(other.planning_pathcandidate_goalplanner);
        planning_pathcandidate_lanechangeleft = std::move(other.planning_pathcandidate_lanechangeleft);
        planning_pathcandidate_lanechangeright = std::move(other.planning_pathcandidate_lanechangeright);
        planning_pathcandidate_sideshift = std::move(other.planning_pathcandidate_sideshift);
        planning_pathcandidate_startplanner = std::move(other.planning_pathcandidate_startplanner);
        planning_pathcandidate_staticobstacleavoidance = std::move(other.planning_pathcandidate_staticobstacleavoidance);
        planning_pathreference_avoidancebylanechange = std::move(other.planning_pathreference_avoidancebylanechange);
        planning_pathreference_goalplanner = std::move(other.planning_pathreference_goalplanner);
        planning_pathreference_lanechangeleft = std::move(other.planning_pathreference_lanechangeleft);
        planning_pathreference_lanechangeright = std::move(other.planning_pathreference_lanechangeright);
        planning_pathreference_sideshift = std::move(other.planning_pathreference_sideshift);
        planning_pathreference_startplanner = std::move(other.planning_pathreference_startplanner);
        planning_pathreference_staticobstacleavoidance = std::move(other.planning_pathreference_staticobstacleavoidance);
        planning_planningfactors_avoidancebylanechange = std::move(other.planning_planningfactors_avoidancebylanechange);
        planning_planningfactors_behaviorpathplanner = std::move(other.planning_planningfactors_behaviorpathplanner);
        planning_planningfactors_goalplanner = std::move(other.planning_planningfactors_goalplanner);
        planning_planningfactors_lanechangeleft = std::move(other.planning_planningfactors_lanechangeleft);
        planning_planningfactors_lanechangeright = std::move(other.planning_planningfactors_lanechangeright);
        planning_planningfactors_sideshift = std::move(other.planning_planningfactors_sideshift);
        planning_planningfactors_startplanner = std::move(other.planning_planningfactors_startplanner);
        planning_planningfactors_staticobstacleavoidance = std::move(other.planning_planningfactors_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance);
        planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid);
        planning_scenarioplanning_modifiedgoal = std::move(other.planning_scenarioplanning_modifiedgoal);
        planning_turnindicatorscmd = std::move(other.planning_turnindicatorscmd);
        planning_cooperatecommands_avoidancebylanechangeleft = std::move(other.planning_cooperatecommands_avoidancebylanechangeleft);
        planning_cooperatecommands_avoidancebylanechangeright = std::move(other.planning_cooperatecommands_avoidancebylanechangeright);
        planning_cooperatecommands_goalplanner = std::move(other.planning_cooperatecommands_goalplanner);
        planning_cooperatecommands_lanechangeleft = std::move(other.planning_cooperatecommands_lanechangeleft);
        planning_cooperatecommands_lanechangeright = std::move(other.planning_cooperatecommands_lanechangeright);
        planning_cooperatecommands_startplanner = std::move(other.planning_cooperatecommands_startplanner);
        planning_cooperatecommands_staticobstacleavoidanceleft = std::move(other.planning_cooperatecommands_staticobstacleavoidanceleft);
        planning_cooperatecommands_staticobstacleavoidanceright = std::move(other.planning_cooperatecommands_staticobstacleavoidanceright);
        planning_enableautomode_avoidancebylanechangeleft = std::move(other.planning_enableautomode_avoidancebylanechangeleft);
        planning_enableautomode_avoidancebylanechangeright = std::move(other.planning_enableautomode_avoidancebylanechangeright);
        planning_enableautomode_goalplanner = std::move(other.planning_enableautomode_goalplanner);
        planning_enableautomode_lanechangeleft = std::move(other.planning_enableautomode_lanechangeleft);
        planning_enableautomode_lanechangeright = std::move(other.planning_enableautomode_lanechangeright);
        planning_enableautomode_startplanner = std::move(other.planning_enableautomode_startplanner);
        planning_enableautomode_staticobstacleavoidanceleft = std::move(other.planning_enableautomode_staticobstacleavoidanceleft);
        planning_enableautomode_staticobstacleavoidanceright = std::move(other.planning_enableautomode_staticobstacleavoidanceright);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically);
        other.mInterface.reset();
        other.mDdsInterface.reset();
        return *this;
    }
    /// @brief Stop the running StartFindService
    /// @uptrace{SWS_CM_00125}
    void StopFindService(ara::com::FindServiceHandle /*handle*/)
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return handle that is connected with service provider currently
    /// @uptrace{SWS_CM_10383}
    HandleType GetHandle() const
    {
        return mHandle;
    }
    
private:
    HandleType mHandle;
    std::unique_ptr<para::com::ProxyInterface> mInterface;
    std::unique_ptr<para::com::ProxyDdsInterface> mDdsInterface;
    
public:
    /// @brief - event, planning_automodestatus_avoidancebylanechangeleft
    events::planning_automodestatus_avoidancebylanechangeleft planning_automodestatus_avoidancebylanechangeleft;
    /// @brief - event, planning_automodestatus_avoidancebylanechangeright
    events::planning_automodestatus_avoidancebylanechangeright planning_automodestatus_avoidancebylanechangeright;
    /// @brief - event, planning_automodestatus_goalplanner
    events::planning_automodestatus_goalplanner planning_automodestatus_goalplanner;
    /// @brief - event, planning_automodestatus_lanechangeleft
    events::planning_automodestatus_lanechangeleft planning_automodestatus_lanechangeleft;
    /// @brief - event, planning_automodestatus_lanechangeright
    events::planning_automodestatus_lanechangeright planning_automodestatus_lanechangeright;
    /// @brief - event, planning_automodestatus_startplanner
    events::planning_automodestatus_startplanner planning_automodestatus_startplanner;
    /// @brief - event, planning_automodestatus_staticobstacleavoidanceleft
    events::planning_automodestatus_staticobstacleavoidanceleft planning_automodestatus_staticobstacleavoidanceleft;
    /// @brief - event, planning_automodestatus_staticobstacleavoidanceright
    events::planning_automodestatus_staticobstacleavoidanceright planning_automodestatus_staticobstacleavoidanceright;
    /// @brief - event, planning_cooperatestatus_avoidancebylanechangeleft
    events::planning_cooperatestatus_avoidancebylanechangeleft planning_cooperatestatus_avoidancebylanechangeleft;
    /// @brief - event, planning_cooperatestatus_avoidancebylanechangeright
    events::planning_cooperatestatus_avoidancebylanechangeright planning_cooperatestatus_avoidancebylanechangeright;
    /// @brief - event, planning_cooperatestatus_goalplanner
    events::planning_cooperatestatus_goalplanner planning_cooperatestatus_goalplanner;
    /// @brief - event, planning_cooperatestatus_lanechangeleft
    events::planning_cooperatestatus_lanechangeleft planning_cooperatestatus_lanechangeleft;
    /// @brief - event, planning_cooperatestatus_lanechangeright
    events::planning_cooperatestatus_lanechangeright planning_cooperatestatus_lanechangeright;
    /// @brief - event, planning_cooperatestatus_startplanner
    events::planning_cooperatestatus_startplanner planning_cooperatestatus_startplanner;
    /// @brief - event, planning_cooperatestatus_staticobstacleavoidanceleft
    events::planning_cooperatestatus_staticobstacleavoidanceleft planning_cooperatestatus_staticobstacleavoidanceleft;
    /// @brief - event, planning_cooperatestatus_staticobstacleavoidanceright
    events::planning_cooperatestatus_staticobstacleavoidanceright planning_cooperatestatus_staticobstacleavoidanceright;
    /// @brief - event, planning_debug_objectsofinterest_avoidancebylanechangeleft
    events::planning_debug_objectsofinterest_avoidancebylanechangeleft planning_debug_objectsofinterest_avoidancebylanechangeleft;
    /// @brief - event, planning_debug_objectsofinterest_avoidancebylanechangeright
    events::planning_debug_objectsofinterest_avoidancebylanechangeright planning_debug_objectsofinterest_avoidancebylanechangeright;
    /// @brief - event, planning_debug_objectsofinterest_goalplanner
    events::planning_debug_objectsofinterest_goalplanner planning_debug_objectsofinterest_goalplanner;
    /// @brief - event, planning_debug_objectsofinterest_lanechangeleft
    events::planning_debug_objectsofinterest_lanechangeleft planning_debug_objectsofinterest_lanechangeleft;
    /// @brief - event, planning_debug_objectsofinterest_lanechangeright
    events::planning_debug_objectsofinterest_lanechangeright planning_debug_objectsofinterest_lanechangeright;
    /// @brief - event, planning_debug_objectsofinterest_startplanner
    events::planning_debug_objectsofinterest_startplanner planning_debug_objectsofinterest_startplanner;
    /// @brief - event, planning_debug_objectsofinterest_staticobstacleavoidanceleft
    events::planning_debug_objectsofinterest_staticobstacleavoidanceleft planning_debug_objectsofinterest_staticobstacleavoidanceleft;
    /// @brief - event, planning_debug_objectsofinterest_staticobstacleavoidanceright
    events::planning_debug_objectsofinterest_staticobstacleavoidanceright planning_debug_objectsofinterest_staticobstacleavoidanceright;
    /// @brief - event, planning_hazardlightscmd
    events::planning_hazardlightscmd planning_hazardlightscmd;
    /// @brief - event, planning_pathcandidate_avoidancebylanechange
    events::planning_pathcandidate_avoidancebylanechange planning_pathcandidate_avoidancebylanechange;
    /// @brief - event, planning_pathcandidate_goalplanner
    events::planning_pathcandidate_goalplanner planning_pathcandidate_goalplanner;
    /// @brief - event, planning_pathcandidate_lanechangeleft
    events::planning_pathcandidate_lanechangeleft planning_pathcandidate_lanechangeleft;
    /// @brief - event, planning_pathcandidate_lanechangeright
    events::planning_pathcandidate_lanechangeright planning_pathcandidate_lanechangeright;
    /// @brief - event, planning_pathcandidate_sideshift
    events::planning_pathcandidate_sideshift planning_pathcandidate_sideshift;
    /// @brief - event, planning_pathcandidate_startplanner
    events::planning_pathcandidate_startplanner planning_pathcandidate_startplanner;
    /// @brief - event, planning_pathcandidate_staticobstacleavoidance
    events::planning_pathcandidate_staticobstacleavoidance planning_pathcandidate_staticobstacleavoidance;
    /// @brief - event, planning_pathreference_avoidancebylanechange
    events::planning_pathreference_avoidancebylanechange planning_pathreference_avoidancebylanechange;
    /// @brief - event, planning_pathreference_goalplanner
    events::planning_pathreference_goalplanner planning_pathreference_goalplanner;
    /// @brief - event, planning_pathreference_lanechangeleft
    events::planning_pathreference_lanechangeleft planning_pathreference_lanechangeleft;
    /// @brief - event, planning_pathreference_lanechangeright
    events::planning_pathreference_lanechangeright planning_pathreference_lanechangeright;
    /// @brief - event, planning_pathreference_sideshift
    events::planning_pathreference_sideshift planning_pathreference_sideshift;
    /// @brief - event, planning_pathreference_startplanner
    events::planning_pathreference_startplanner planning_pathreference_startplanner;
    /// @brief - event, planning_pathreference_staticobstacleavoidance
    events::planning_pathreference_staticobstacleavoidance planning_pathreference_staticobstacleavoidance;
    /// @brief - event, planning_planningfactors_avoidancebylanechange
    events::planning_planningfactors_avoidancebylanechange planning_planningfactors_avoidancebylanechange;
    /// @brief - event, planning_planningfactors_behaviorpathplanner
    events::planning_planningfactors_behaviorpathplanner planning_planningfactors_behaviorpathplanner;
    /// @brief - event, planning_planningfactors_goalplanner
    events::planning_planningfactors_goalplanner planning_planningfactors_goalplanner;
    /// @brief - event, planning_planningfactors_lanechangeleft
    events::planning_planningfactors_lanechangeleft planning_planningfactors_lanechangeleft;
    /// @brief - event, planning_planningfactors_lanechangeright
    events::planning_planningfactors_lanechangeright planning_planningfactors_lanechangeright;
    /// @brief - event, planning_planningfactors_sideshift
    events::planning_planningfactors_sideshift planning_planningfactors_sideshift;
    /// @brief - event, planning_planningfactors_startplanner
    events::planning_planningfactors_startplanner planning_planningfactors_startplanner;
    /// @brief - event, planning_planningfactors_staticobstacleavoidance
    events::planning_planningfactors_staticobstacleavoidance planning_planningfactors_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid
    events::planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid;
    /// @brief - event, planning_scenarioplanning_modifiedgoal
    events::planning_scenarioplanning_modifiedgoal planning_scenarioplanning_modifiedgoal;
    /// @brief - event, planning_turnindicatorscmd
    events::planning_turnindicatorscmd planning_turnindicatorscmd;
    /// @brief - method, planning_cooperatecommands_avoidancebylanechangeleft
    methods::planning_cooperatecommands_avoidancebylanechangeleft planning_cooperatecommands_avoidancebylanechangeleft;
    /// @brief - method, planning_cooperatecommands_avoidancebylanechangeright
    methods::planning_cooperatecommands_avoidancebylanechangeright planning_cooperatecommands_avoidancebylanechangeright;
    /// @brief - method, planning_cooperatecommands_goalplanner
    methods::planning_cooperatecommands_goalplanner planning_cooperatecommands_goalplanner;
    /// @brief - method, planning_cooperatecommands_lanechangeleft
    methods::planning_cooperatecommands_lanechangeleft planning_cooperatecommands_lanechangeleft;
    /// @brief - method, planning_cooperatecommands_lanechangeright
    methods::planning_cooperatecommands_lanechangeright planning_cooperatecommands_lanechangeright;
    /// @brief - method, planning_cooperatecommands_startplanner
    methods::planning_cooperatecommands_startplanner planning_cooperatecommands_startplanner;
    /// @brief - method, planning_cooperatecommands_staticobstacleavoidanceleft
    methods::planning_cooperatecommands_staticobstacleavoidanceleft planning_cooperatecommands_staticobstacleavoidanceleft;
    /// @brief - method, planning_cooperatecommands_staticobstacleavoidanceright
    methods::planning_cooperatecommands_staticobstacleavoidanceright planning_cooperatecommands_staticobstacleavoidanceright;
    /// @brief - method, planning_enableautomode_avoidancebylanechangeleft
    methods::planning_enableautomode_avoidancebylanechangeleft planning_enableautomode_avoidancebylanechangeleft;
    /// @brief - method, planning_enableautomode_avoidancebylanechangeright
    methods::planning_enableautomode_avoidancebylanechangeright planning_enableautomode_avoidancebylanechangeright;
    /// @brief - method, planning_enableautomode_goalplanner
    methods::planning_enableautomode_goalplanner planning_enableautomode_goalplanner;
    /// @brief - method, planning_enableautomode_lanechangeleft
    methods::planning_enableautomode_lanechangeleft planning_enableautomode_lanechangeleft;
    /// @brief - method, planning_enableautomode_lanechangeright
    methods::planning_enableautomode_lanechangeright planning_enableautomode_lanechangeright;
    /// @brief - method, planning_enableautomode_startplanner
    methods::planning_enableautomode_startplanner planning_enableautomode_startplanner;
    /// @brief - method, planning_enableautomode_staticobstacleavoidanceleft
    methods::planning_enableautomode_staticobstacleavoidanceleft planning_enableautomode_staticobstacleavoidanceleft;
    /// @brief - method, planning_enableautomode_staticobstacleavoidanceright
    methods::planning_enableautomode_staticobstacleavoidanceright planning_enableautomode_staticobstacleavoidanceright;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically;
};
} /// namespace proxy
} /// namespace BPP2BVP
} /// namespace srv
} /// namespace oss
#endif /// PARA_COM_GEN_oss_srv_BPP2BVP_SERVICE_INTERFACE_BVP_SI_BEHAVIORPATHPLANNER_PROXY_H