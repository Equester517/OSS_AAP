///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : rport_bpp2bvp.cpp
/// SOFTWARE COMPONENT NAME           : RPort_BPP2BVP
/// GENERATED DATE                    : 2025-12-08 15:30:48
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_behaviorvelocityplanner/aa/port/rport_bpp2bvp.h"
 
namespace exe_behaviorvelocityplanner
{
namespace aa
{
namespace port
{
 
RPort_BPP2BVP::RPort_BPP2BVP()
    : m_logger(ara::log::CreateLogger("BHVP", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_found{false}
    , m_receiverplanning_automodestatus_avoidancebylanechangeleft{nullptr}
    , m_receiverplanning_automodestatus_avoidancebylanechangeright{nullptr}
    , m_receiverplanning_automodestatus_goalplanner{nullptr}
    , m_receiverplanning_automodestatus_lanechangeleft{nullptr}
    , m_receiverplanning_automodestatus_lanechangeright{nullptr}
    , m_receiverplanning_automodestatus_startplanner{nullptr}
    , m_receiverplanning_automodestatus_staticobstacleavoidanceleft{nullptr}
    , m_receiverplanning_automodestatus_staticobstacleavoidanceright{nullptr}
    , m_receiverplanning_cooperatestatus_avoidancebylanechangeleft{nullptr}
    , m_receiverplanning_cooperatestatus_avoidancebylanechangeright{nullptr}
    , m_receiverplanning_cooperatestatus_goalplanner{nullptr}
    , m_receiverplanning_cooperatestatus_lanechangeleft{nullptr}
    , m_receiverplanning_cooperatestatus_lanechangeright{nullptr}
    , m_receiverplanning_cooperatestatus_startplanner{nullptr}
    , m_receiverplanning_cooperatestatus_staticobstacleavoidanceleft{nullptr}
    , m_receiverplanning_cooperatestatus_staticobstacleavoidanceright{nullptr}
    , m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeleft{nullptr}
    , m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeright{nullptr}
    , m_receiverplanning_debug_objectsofinterest_goalplanner{nullptr}
    , m_receiverplanning_debug_objectsofinterest_lanechangeleft{nullptr}
    , m_receiverplanning_debug_objectsofinterest_lanechangeright{nullptr}
    , m_receiverplanning_debug_objectsofinterest_startplanner{nullptr}
    , m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft{nullptr}
    , m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceright{nullptr}
    , m_receiverplanning_hazardlightscmd{nullptr}
    , m_receiverplanning_pathcandidate_avoidancebylanechange{nullptr}
    , m_receiverplanning_pathcandidate_goalplanner{nullptr}
    , m_receiverplanning_pathcandidate_lanechangeleft{nullptr}
    , m_receiverplanning_pathcandidate_lanechangeright{nullptr}
    , m_receiverplanning_pathcandidate_sideshift{nullptr}
    , m_receiverplanning_pathcandidate_startplanner{nullptr}
    , m_receiverplanning_pathcandidate_staticobstacleavoidance{nullptr}
    , m_receiverplanning_pathreference_avoidancebylanechange{nullptr}
    , m_receiverplanning_pathreference_goalplanner{nullptr}
    , m_receiverplanning_pathreference_lanechangeleft{nullptr}
    , m_receiverplanning_pathreference_lanechangeright{nullptr}
    , m_receiverplanning_pathreference_sideshift{nullptr}
    , m_receiverplanning_pathreference_startplanner{nullptr}
    , m_receiverplanning_pathreference_staticobstacleavoidance{nullptr}
    , m_receiverplanning_planningfactors_avoidancebylanechange{nullptr}
    , m_receiverplanning_planningfactors_behaviorpathplanner{nullptr}
    , m_receiverplanning_planningfactors_goalplanner{nullptr}
    , m_receiverplanning_planningfactors_lanechangeleft{nullptr}
    , m_receiverplanning_planningfactors_lanechangeright{nullptr}
    , m_receiverplanning_planningfactors_sideshift{nullptr}
    , m_receiverplanning_planningfactors_startplanner{nullptr}
    , m_receiverplanning_planningfactors_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid{nullptr}
    , m_receiverplanning_scenarioplanning_modifiedgoal{nullptr}
    , m_receiverplanning_turnindicatorscmd{nullptr}
    , m_responderplanning_cooperatecommands_avoidancebylanechangeleft{nullptr}
    , m_responderplanning_cooperatecommands_avoidancebylanechangeright{nullptr}
    , m_responderplanning_cooperatecommands_goalplanner{nullptr}
    , m_responderplanning_cooperatecommands_lanechangeleft{nullptr}
    , m_responderplanning_cooperatecommands_lanechangeright{nullptr}
    , m_responderplanning_cooperatecommands_startplanner{nullptr}
    , m_responderplanning_cooperatecommands_staticobstacleavoidanceleft{nullptr}
    , m_responderplanning_cooperatecommands_staticobstacleavoidanceright{nullptr}
    , m_responderplanning_enableautomode_avoidancebylanechangeleft{nullptr}
    , m_responderplanning_enableautomode_avoidancebylanechangeright{nullptr}
    , m_responderplanning_enableautomode_goalplanner{nullptr}
    , m_responderplanning_enableautomode_lanechangeleft{nullptr}
    , m_responderplanning_enableautomode_lanechangeright{nullptr}
    , m_responderplanning_enableautomode_startplanner{nullptr}
    , m_responderplanning_enableautomode_staticobstacleavoidanceleft{nullptr}
    , m_responderplanning_enableautomode_staticobstacleavoidanceright{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically{nullptr}
{
}
 
RPort_BPP2BVP::~RPort_BPP2BVP()
{
}
 
void RPort_BPP2BVP::Start()
{
    m_logger.LogVerbose() << "RPort_BPP2BVP::Start";
    
    // regist callback
    ara::core::InstanceSpecifier specifier{"Exe_behaviorvelocityplanner/AA/RPort_BPP2BVP"};
    auto handler = [this](ara::com::ServiceHandleContainer<oss::srv::BPP2BVP::proxy::BVP_SI_behaviorpathplannerProxy::HandleType> handles,
                          ara::com::FindServiceHandle findHandle) {
        this->Find(handles, findHandle);
    };
    
    // find service
    auto find = oss::srv::BPP2BVP::proxy::BVP_SI_behaviorpathplannerProxy::StartFindService(handler, specifier);
    if (find.HasValue())
    {
        m_logger.LogVerbose() << "RPort_BPP2BVP::Start::StartFindService";
    }
    else
    {
        m_logger.LogError() << "RPort_BPP2BVP::Start::StartFindService::" << find.Error().Message();
    }
    
    // run port
    m_running = true;
}
 
void RPort_BPP2BVP::Terminate()
{
    m_logger.LogVerbose() << "RPort_BPP2BVP::Terminate";
    
    // stop port
    m_running = false;
    
    // clear service proxy
    if (m_interface)
    {
        // stop subscribe
        StopSubscribeplanning_automodestatus_avoidancebylanechangeleft();
        StopSubscribeplanning_automodestatus_avoidancebylanechangeright();
        StopSubscribeplanning_automodestatus_goalplanner();
        StopSubscribeplanning_automodestatus_lanechangeleft();
        StopSubscribeplanning_automodestatus_lanechangeright();
        StopSubscribeplanning_automodestatus_startplanner();
        StopSubscribeplanning_automodestatus_staticobstacleavoidanceleft();
        StopSubscribeplanning_automodestatus_staticobstacleavoidanceright();
        StopSubscribeplanning_cooperatestatus_avoidancebylanechangeleft();
        StopSubscribeplanning_cooperatestatus_avoidancebylanechangeright();
        StopSubscribeplanning_cooperatestatus_goalplanner();
        StopSubscribeplanning_cooperatestatus_lanechangeleft();
        StopSubscribeplanning_cooperatestatus_lanechangeright();
        StopSubscribeplanning_cooperatestatus_startplanner();
        StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceleft();
        StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceright();
        StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft();
        StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeright();
        StopSubscribeplanning_debug_objectsofinterest_goalplanner();
        StopSubscribeplanning_debug_objectsofinterest_lanechangeleft();
        StopSubscribeplanning_debug_objectsofinterest_lanechangeright();
        StopSubscribeplanning_debug_objectsofinterest_startplanner();
        StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft();
        StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright();
        StopSubscribeplanning_hazardlightscmd();
        StopSubscribeplanning_pathcandidate_avoidancebylanechange();
        StopSubscribeplanning_pathcandidate_goalplanner();
        StopSubscribeplanning_pathcandidate_lanechangeleft();
        StopSubscribeplanning_pathcandidate_lanechangeright();
        StopSubscribeplanning_pathcandidate_sideshift();
        StopSubscribeplanning_pathcandidate_startplanner();
        StopSubscribeplanning_pathcandidate_staticobstacleavoidance();
        StopSubscribeplanning_pathreference_avoidancebylanechange();
        StopSubscribeplanning_pathreference_goalplanner();
        StopSubscribeplanning_pathreference_lanechangeleft();
        StopSubscribeplanning_pathreference_lanechangeright();
        StopSubscribeplanning_pathreference_sideshift();
        StopSubscribeplanning_pathreference_startplanner();
        StopSubscribeplanning_pathreference_staticobstacleavoidance();
        StopSubscribeplanning_planningfactors_avoidancebylanechange();
        StopSubscribeplanning_planningfactors_behaviorpathplanner();
        StopSubscribeplanning_planningfactors_goalplanner();
        StopSubscribeplanning_planningfactors_lanechangeleft();
        StopSubscribeplanning_planningfactors_lanechangeright();
        StopSubscribeplanning_planningfactors_sideshift();
        StopSubscribeplanning_planningfactors_startplanner();
        StopSubscribeplanning_planningfactors_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid();
        StopSubscribeplanning_scenarioplanning_modifiedgoal();
        StopSubscribeplanning_turnindicatorscmd();
        
        // stop find service
        m_interface->StopFindService(*m_findHandle);
        m_found = false;
        
        m_logger.LogVerbose() << "RPort_BPP2BVP::Terminate::StopFindService";
    }
}
 
void RPort_BPP2BVP::Find(ara::com::ServiceHandleContainer<oss::srv::BPP2BVP::proxy::BVP_SI_behaviorpathplannerProxy::HandleType> handles, ara::com::FindServiceHandle findHandle)
{
    // check finding handles
    if (handles.empty())
    {
        m_logger.LogVerbose() << "RPort_BPP2BVP::Find::Service Instances not found";
        return;
    }
    else
    {
        for (auto& handle : handles)
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Find::Searched Instance::ServiceId =" << 
                                     handle.GetServiceHandle().serviceId << 
                                     ", InstanceId =" << 
                                     handle.GetServiceHandle().instanceId;
        }
    }
    
    // create proxy
    if (m_interface)
    {
        m_logger.LogVerbose() << "RPort_BPP2BVP::Find::Proxy is already running";
    }
    else
    {
        m_logger.LogVerbose() << "RPort_BPP2BVP::Find::Using Instance::ServiceId =" << 
                                 handles[0].GetServiceHandle().serviceId << 
                                 ", InstanceId =" << 
                                 handles[0].GetServiceHandle().instanceId;
        m_interface = std::make_unique<oss::srv::BPP2BVP::proxy::BVP_SI_behaviorpathplannerProxy>(handles[0]);
        m_findHandle = std::make_unique<ara::com::FindServiceHandle>(findHandle);
        m_found = true;
        
        // subscribe events
        Subscribeplanning_automodestatus_avoidancebylanechangeleft();
        Subscribeplanning_automodestatus_avoidancebylanechangeright();
        Subscribeplanning_automodestatus_goalplanner();
        Subscribeplanning_automodestatus_lanechangeleft();
        Subscribeplanning_automodestatus_lanechangeright();
        Subscribeplanning_automodestatus_startplanner();
        Subscribeplanning_automodestatus_staticobstacleavoidanceleft();
        Subscribeplanning_automodestatus_staticobstacleavoidanceright();
        Subscribeplanning_cooperatestatus_avoidancebylanechangeleft();
        Subscribeplanning_cooperatestatus_avoidancebylanechangeright();
        Subscribeplanning_cooperatestatus_goalplanner();
        Subscribeplanning_cooperatestatus_lanechangeleft();
        Subscribeplanning_cooperatestatus_lanechangeright();
        Subscribeplanning_cooperatestatus_startplanner();
        Subscribeplanning_cooperatestatus_staticobstacleavoidanceleft();
        Subscribeplanning_cooperatestatus_staticobstacleavoidanceright();
        Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft();
        Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeright();
        Subscribeplanning_debug_objectsofinterest_goalplanner();
        Subscribeplanning_debug_objectsofinterest_lanechangeleft();
        Subscribeplanning_debug_objectsofinterest_lanechangeright();
        Subscribeplanning_debug_objectsofinterest_startplanner();
        Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft();
        Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright();
        Subscribeplanning_hazardlightscmd();
        Subscribeplanning_pathcandidate_avoidancebylanechange();
        Subscribeplanning_pathcandidate_goalplanner();
        Subscribeplanning_pathcandidate_lanechangeleft();
        Subscribeplanning_pathcandidate_lanechangeright();
        Subscribeplanning_pathcandidate_sideshift();
        Subscribeplanning_pathcandidate_startplanner();
        Subscribeplanning_pathcandidate_staticobstacleavoidance();
        Subscribeplanning_pathreference_avoidancebylanechange();
        Subscribeplanning_pathreference_goalplanner();
        Subscribeplanning_pathreference_lanechangeleft();
        Subscribeplanning_pathreference_lanechangeright();
        Subscribeplanning_pathreference_sideshift();
        Subscribeplanning_pathreference_startplanner();
        Subscribeplanning_pathreference_staticobstacleavoidance();
        Subscribeplanning_planningfactors_avoidancebylanechange();
        Subscribeplanning_planningfactors_behaviorpathplanner();
        Subscribeplanning_planningfactors_goalplanner();
        Subscribeplanning_planningfactors_lanechangeleft();
        Subscribeplanning_planningfactors_lanechangeright();
        Subscribeplanning_planningfactors_sideshift();
        Subscribeplanning_planningfactors_startplanner();
        Subscribeplanning_planningfactors_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid();
        Subscribeplanning_scenarioplanning_modifiedgoal();
        Subscribeplanning_turnindicatorscmd();
    }
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_avoidancebylanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_avoidancebylanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_avoidancebylanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_avoidancebylanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_avoidancebylanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_avoidancebylanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_avoidancebylanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_avoidancebylanechangeleft)
    {
        m_receiverplanning_automodestatus_avoidancebylanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_avoidancebylanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_avoidancebylanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_avoidancebylanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_avoidancebylanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_avoidancebylanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_avoidancebylanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_avoidancebylanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_avoidancebylanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_avoidancebylanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_avoidancebylanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_avoidancebylanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_avoidancebylanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_avoidancebylanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_avoidancebylanechangeright)
    {
        m_receiverplanning_automodestatus_avoidancebylanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_avoidancebylanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_avoidancebylanechangeright::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_avoidancebylanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_goalplanner)
    {
        m_receiverplanning_automodestatus_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_lanechangeleft)
    {
        m_receiverplanning_automodestatus_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_lanechangeright)
    {
        m_receiverplanning_automodestatus_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_startplanner)
    {
        m_receiverplanning_automodestatus_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_startplanner::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_staticobstacleavoidanceleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_staticobstacleavoidanceleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_staticobstacleavoidanceleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_staticobstacleavoidanceleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_staticobstacleavoidanceleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_staticobstacleavoidanceleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_staticobstacleavoidanceleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_staticobstacleavoidanceleft)
    {
        m_receiverplanning_automodestatus_staticobstacleavoidanceleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_staticobstacleavoidanceleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_staticobstacleavoidanceleft::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_staticobstacleavoidanceleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_staticobstacleavoidanceright();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_staticobstacleavoidanceright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_automodestatus_staticobstacleavoidanceright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_automodestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_staticobstacleavoidanceright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_automodestatus_staticobstacleavoidanceright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_staticobstacleavoidancerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_staticobstacleavoidanceright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_automodestatus_staticobstacleavoidanceright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidancerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidancerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_automodestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_automodestatus_staticobstacleavoidanceright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_automodestatus_staticobstacleavoidanceright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_staticobstacleavoidanceright)
    {
        m_receiverplanning_automodestatus_staticobstacleavoidanceright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_automodestatus_staticobstacleavoidanceright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_automodestatus_staticobstacleavoidanceright::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_staticobstacleavoidanceright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_avoidancebylanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_avoidancebylanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_avoidancebylanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_avoidancebylanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_avoidancebylanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_avoidancebylanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_avoidancebylanechangeleft)
    {
        m_receiverplanning_cooperatestatus_avoidancebylanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_avoidancebylanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_avoidancebylanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_avoidancebylanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_avoidancebylanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_avoidancebylanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_avoidancebylanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_avoidancebylanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_avoidancebylanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_avoidancebylanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_avoidancebylanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_avoidancebylanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_avoidancebylanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_avoidancebylanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_avoidancebylanechangeright)
    {
        m_receiverplanning_cooperatestatus_avoidancebylanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_avoidancebylanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_avoidancebylanechangeright::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_avoidancebylanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_goalplanner)
    {
        m_receiverplanning_cooperatestatus_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_lanechangeleft)
    {
        m_receiverplanning_cooperatestatus_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_lanechangeright)
    {
        m_receiverplanning_cooperatestatus_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_startplanner)
    {
        m_receiverplanning_cooperatestatus_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_startplanner::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_staticobstacleavoidanceleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_staticobstacleavoidanceleft)
    {
        m_receiverplanning_cooperatestatus_staticobstacleavoidanceleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_staticobstacleavoidanceleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_staticobstacleavoidanceleft::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_staticobstacleavoidanceleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceright();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_staticobstacleavoidanceright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_cooperatestatus_staticobstacleavoidanceright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_staticobstacleavoidanceright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_cooperatestatus_staticobstacleavoidanceright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_staticobstacleavoidancerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_staticobstacleavoidanceright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_cooperatestatus_staticobstacleavoidanceright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidancerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidancerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_cooperatestatus_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_cooperatestatus_staticobstacleavoidanceright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_staticobstacleavoidanceright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_staticobstacleavoidanceright)
    {
        m_receiverplanning_cooperatestatus_staticobstacleavoidanceright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_cooperatestatus_staticobstacleavoidanceright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_cooperatestatus_staticobstacleavoidanceright::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_staticobstacleavoidanceright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_avoidancebylanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_avoidancebylanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeleft)
    {
        m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_avoidancebylanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_avoidancebylanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_avoidancebylanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_avoidancebylanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_avoidancebylanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_avoidancebylanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_avoidancebylanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_avoidancebylanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_avoidancebylanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeright)
    {
        m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_avoidancebylanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_avoidancebylanechangeright::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_avoidancebylanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_goalplanner)
    {
        m_receiverplanning_debug_objectsofinterest_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_lanechangeleft)
    {
        m_receiverplanning_debug_objectsofinterest_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_lanechangeright)
    {
        m_receiverplanning_debug_objectsofinterest_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_startplanner)
    {
        m_receiverplanning_debug_objectsofinterest_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_startplanner::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_staticobstacleavoidanceleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft)
    {
        m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_staticobstacleavoidanceleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_staticobstacleavoidanceleft::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceright();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_debug_objectsofinterest_staticobstacleavoidanceright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidancerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_debug_objectsofinterest_staticobstacleavoidanceright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidancerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidancerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_staticobstacleavoidanceright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_debug_objectsofinterest_staticobstacleavoidanceright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_debug_objectsofinterest_staticobstacleavoidanceright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_staticobstacleavoidanceright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceright)
    {
        m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_debug_objectsofinterest_staticobstacleavoidanceright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_debug_objectsofinterest_staticobstacleavoidanceright::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_staticobstacleavoidanceright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_hazardlightscmd()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_hazardlightscmd();
        
        // request subscribe
        auto subscribe = m_interface->planning_hazardlightscmd.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_hazardlightscmd::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_hazardlightscmd::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_hazardlightscmd()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_hazardlightscmd.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_hazardlightscmd::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_hazardlightscmd()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_hazardlightscmdTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_hazardlightscmd.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_hazardlightscmd::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_hazardlightscmd::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmdTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_hazardlightscmd.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_hazardlightscmd.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_hazardlightscmd(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmd::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmd::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmdCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_hazardlightscmd.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_hazardlightscmd.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_hazardlightscmd(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmd::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_hazardlightscmd::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_hazardlightscmd(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_hazardlightscmd::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_hazardlightscmd)
    {
        m_receiverplanning_hazardlightscmd(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_hazardlightscmd(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_hazardlightscmd::SampleType&)> handler)
{
    m_receiverplanning_hazardlightscmd = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_avoidancebylanechange)
    {
        m_receiverplanning_pathcandidate_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_goalplanner)
    {
        m_receiverplanning_pathcandidate_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_lanechangeleft)
    {
        m_receiverplanning_pathcandidate_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_lanechangeright)
    {
        m_receiverplanning_pathcandidate_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_sideshift)
    {
        m_receiverplanning_pathcandidate_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_sideshift::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_startplanner)
    {
        m_receiverplanning_pathcandidate_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_startplanner::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathcandidate_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathcandidate_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathcandidate_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathcandidate_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathcandidate_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathcandidate_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathcandidate_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathcandidate_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathcandidate_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathcandidate_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathcandidate_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathcandidate_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathcandidate_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathcandidate_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathcandidate_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathcandidate_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathcandidate_staticobstacleavoidance)
    {
        m_receiverplanning_pathcandidate_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathcandidate_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathcandidate_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_pathcandidate_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_avoidancebylanechange)
    {
        m_receiverplanning_pathreference_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_pathreference_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_goalplanner)
    {
        m_receiverplanning_pathreference_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_pathreference_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_lanechangeleft)
    {
        m_receiverplanning_pathreference_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_pathreference_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_lanechangeright)
    {
        m_receiverplanning_pathreference_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_pathreference_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_sideshift)
    {
        m_receiverplanning_pathreference_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_sideshift::SampleType&)> handler)
{
    m_receiverplanning_pathreference_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_startplanner)
    {
        m_receiverplanning_pathreference_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_startplanner::SampleType&)> handler)
{
    m_receiverplanning_pathreference_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_pathreference_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_pathreference_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_pathreference_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_pathreference_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_pathreference_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_pathreference_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_pathreference_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_pathreference_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_pathreference_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_pathreference_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_pathreference_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_pathreference_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_pathreference_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_pathreference_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_pathreference_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_pathreference_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_pathreference_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_pathreference_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_pathreference_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_pathreference_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_pathreference_staticobstacleavoidance)
    {
        m_receiverplanning_pathreference_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_pathreference_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_pathreference_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_pathreference_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_avoidancebylanechange)
    {
        m_receiverplanning_planningfactors_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_behaviorpathplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_behaviorpathplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_behaviorpathplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_behaviorpathplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_behaviorpathplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_behaviorpathplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_behaviorpathplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_behaviorpathplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_behaviorpathplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_behaviorpathplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_behaviorpathplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_behaviorpathplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_behaviorpathplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_behaviorpathplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_behaviorpathplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_behaviorpathplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_behaviorpathplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_behaviorpathplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_behaviorpathplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_behaviorpathplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_behaviorpathplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_behaviorpathplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_behaviorpathplanner)
    {
        m_receiverplanning_planningfactors_behaviorpathplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_behaviorpathplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_behaviorpathplanner::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_behaviorpathplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_goalplanner)
    {
        m_receiverplanning_planningfactors_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_lanechangeleft)
    {
        m_receiverplanning_planningfactors_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_lanechangeright)
    {
        m_receiverplanning_planningfactors_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_sideshift)
    {
        m_receiverplanning_planningfactors_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_sideshift::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_startplanner)
    {
        m_receiverplanning_planningfactors_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_startplanner::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_planningfactors_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_planningfactors_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_planningfactors_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_planningfactors_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_planningfactors_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_planningfactors_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_planningfactors_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_planningfactors_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_planningfactors_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_planningfactors_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_planningfactors_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_staticobstacleavoidance)
    {
        m_receiverplanning_planningfactors_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_planningfactors_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_planningfactors_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearrayTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearrayTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearrayCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_avoidancedebugmessagearray = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_boundTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_boundTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_boundCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_bound = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfoTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfoTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfoCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_debug_turnsignalinfo = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_drivablelanes_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_info_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailableTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailableTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailableCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_output_isrerouteavailable = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_processingtime_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechangeTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechangeTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechangeCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_avoidancebylanechange = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_goalplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangerightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangerightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangerightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshiftTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshiftTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshiftCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_sideshift = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplannerTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplannerTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplannerCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_startplanner = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidanceTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidanceTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidanceCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_virtualwall_staticobstacleavoidance = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneidTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneidTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneidCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_pathwithlaneid = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_scenarioplanning_modifiedgoal()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_modifiedgoal();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_modifiedgoal.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_modifiedgoal::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_scenarioplanning_modifiedgoal::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_modifiedgoal()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_modifiedgoal.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_scenarioplanning_modifiedgoal::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_modifiedgoal()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_modifiedgoalTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_modifiedgoal.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_modifiedgoal::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_scenarioplanning_modifiedgoal::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoalTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_modifiedgoal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_modifiedgoal.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_scenarioplanning_modifiedgoal(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoal::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoal::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoalCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_modifiedgoal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_modifiedgoal.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_scenarioplanning_modifiedgoal(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoal::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_scenarioplanning_modifiedgoal::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_scenarioplanning_modifiedgoal(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_modifiedgoal::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_modifiedgoal)
    {
        m_receiverplanning_scenarioplanning_modifiedgoal(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_scenarioplanning_modifiedgoal(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_scenarioplanning_modifiedgoal::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_modifiedgoal = handler;
}
 
void RPort_BPP2BVP::Subscribeplanning_turnindicatorscmd()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_turnindicatorscmd();
        
        // request subscribe
        auto subscribe = m_interface->planning_turnindicatorscmd.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Subscribeplanning_turnindicatorscmd::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Subscribeplanning_turnindicatorscmd::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::StopSubscribeplanning_turnindicatorscmd()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_turnindicatorscmd.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BPP2BVP::StopSubscribeplanning_turnindicatorscmd::Unsubscribed";
    }
}
 
void RPort_BPP2BVP::RegistReceiverplanning_turnindicatorscmd()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_turnindicatorscmdTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_turnindicatorscmd.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::RegistReceiverplanning_turnindicatorscmd::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::RegistReceiverplanning_turnindicatorscmd::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmdTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_turnindicatorscmd.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_turnindicatorscmd.GetNewSamples([&](auto samplePtr) {
                RPort_BPP2BVP::ReadDataplanning_turnindicatorscmd(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmd::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmd::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmdCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_turnindicatorscmd.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_turnindicatorscmd.GetNewSamples([&](auto samplePtr) {
                    RPort_BPP2BVP::ReadDataplanning_turnindicatorscmd(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmd::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BPP2BVP::ReceiveEventplanning_turnindicatorscmd::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BPP2BVP::ReadDataplanning_turnindicatorscmd(ara::com::SamplePtr<oss::srv::BPP2BVP::proxy::events::planning_turnindicatorscmd::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_turnindicatorscmd)
    {
        m_receiverplanning_turnindicatorscmd(data);
    }
}
 
void RPort_BPP2BVP::RegistEventHandlerplanning_turnindicatorscmd(std::function<void(const oss::srv::BPP2BVP::proxy::events::planning_turnindicatorscmd::SampleType&)> handler)
{
    m_receiverplanning_turnindicatorscmd = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_avoidancebylanechangeleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_avoidancebylanechangeleft)
            {
                m_responderplanning_cooperatecommands_avoidancebylanechangeleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_avoidancebylanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_avoidancebylanechangeleft::Output&)> handler)
{
    m_responderplanning_cooperatecommands_avoidancebylanechangeleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_avoidancebylanechangeright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_avoidancebylanechangeright)
            {
                m_responderplanning_cooperatecommands_avoidancebylanechangeright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_avoidancebylanechangeright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_avoidancebylanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_avoidancebylanechangeright::Output&)> handler)
{
    m_responderplanning_cooperatecommands_avoidancebylanechangeright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_goalplanner(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_goalplanner(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_goalplanner::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_goalplanner)
            {
                m_responderplanning_cooperatecommands_goalplanner(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_goalplanner::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_goalplanner::Output&)> handler)
{
    m_responderplanning_cooperatecommands_goalplanner = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_lanechangeleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_lanechangeleft)
            {
                m_responderplanning_cooperatecommands_lanechangeleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_lanechangeleft::Output&)> handler)
{
    m_responderplanning_cooperatecommands_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_lanechangeright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_lanechangeright)
            {
                m_responderplanning_cooperatecommands_lanechangeright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_lanechangeright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_lanechangeright::Output&)> handler)
{
    m_responderplanning_cooperatecommands_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_startplanner(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_startplanner(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_startplanner::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_startplanner)
            {
                m_responderplanning_cooperatecommands_startplanner(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_startplanner::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_startplanner::Output&)> handler)
{
    m_responderplanning_cooperatecommands_startplanner = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceleft(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_staticobstacleavoidanceleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_staticobstacleavoidanceleft)
            {
                m_responderplanning_cooperatecommands_staticobstacleavoidanceleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_staticobstacleavoidanceleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_staticobstacleavoidanceleft::Output&)> handler)
{
    m_responderplanning_cooperatecommands_staticobstacleavoidanceleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceright(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_staticobstacleavoidanceright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_staticobstacleavoidanceright)
            {
                m_responderplanning_cooperatecommands_staticobstacleavoidanceright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_cooperatecommands_staticobstacleavoidanceright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_cooperatecommands_staticobstacleavoidanceright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_cooperatecommands_staticobstacleavoidanceright::Output&)> handler)
{
    m_responderplanning_cooperatecommands_staticobstacleavoidanceright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_avoidancebylanechangeleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_avoidancebylanechangeleft)
            {
                m_responderplanning_enableautomode_avoidancebylanechangeleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_avoidancebylanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_avoidancebylanechangeleft::Output&)> handler)
{
    m_responderplanning_enableautomode_avoidancebylanechangeleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_avoidancebylanechangeright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_avoidancebylanechangeright)
            {
                m_responderplanning_enableautomode_avoidancebylanechangeright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_avoidancebylanechangeright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_avoidancebylanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_avoidancebylanechangeright::Output&)> handler)
{
    m_responderplanning_enableautomode_avoidancebylanechangeright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_goalplanner(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_goalplanner(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_goalplanner::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_goalplanner)
            {
                m_responderplanning_enableautomode_goalplanner(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_goalplanner::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_goalplanner(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_goalplanner::Output&)> handler)
{
    m_responderplanning_enableautomode_goalplanner = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_lanechangeleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_lanechangeleft)
            {
                m_responderplanning_enableautomode_lanechangeleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_lanechangeleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_lanechangeleft::Output&)> handler)
{
    m_responderplanning_enableautomode_lanechangeleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_lanechangeright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_lanechangeright)
            {
                m_responderplanning_enableautomode_lanechangeright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_lanechangeright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_lanechangeright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_lanechangeright::Output&)> handler)
{
    m_responderplanning_enableautomode_lanechangeright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_startplanner(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_startplanner(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_startplanner::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_startplanner)
            {
                m_responderplanning_enableautomode_startplanner(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_startplanner::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_startplanner(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_startplanner::Output&)> handler)
{
    m_responderplanning_enableautomode_startplanner = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceleft(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_staticobstacleavoidanceleft(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceleft::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_staticobstacleavoidanceleft)
            {
                m_responderplanning_enableautomode_staticobstacleavoidanceleft(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceleft::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_staticobstacleavoidanceleft(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_staticobstacleavoidanceleft::Output&)> handler)
{
    m_responderplanning_enableautomode_staticobstacleavoidanceleft = handler;
}
 
void RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceright(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_staticobstacleavoidanceright(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceright::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_staticobstacleavoidanceright)
            {
                m_responderplanning_enableautomode_staticobstacleavoidanceright(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_enableautomode_staticobstacleavoidanceright::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_enableautomode_staticobstacleavoidanceright(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_enableautomode_staticobstacleavoidanceright::Output&)> handler)
{
    m_responderplanning_enableautomode_staticobstacleavoidanceright = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_configlogger = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_describeparameters = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparameters = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_getparametertypes = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_listparameters = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparameters = handler;
}
 
void RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BPP2BVP::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::" << response.Error().Message();
        }
    }
}
 
void RPort_BPP2BVP::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically(std::function<void(const oss::srv::BPP2BVP::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_setparametersatomically = handler;
}
 
} /// namespace port
} /// namespace aa
} /// namespace exe_behaviorvelocityplanner
 
/// EOF