///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : pport_bvp2ebs.cpp
/// SOFTWARE COMPONENT NAME           : PPort_BVP2EBS
/// GENERATED DATE                    : 2025-12-08 15:30:48
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_behaviorvelocityplanner/aa/port/pport_bvp2ebs.h"
 
namespace oss
{
namespace srv
{
namespace BVP2EBS
{
namespace skeleton
{
 
EBS_SI_behaviorvelocityplannerSkeletonImpl::EBS_SI_behaviorvelocityplannerSkeletonImpl(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode)
    : EBS_SI_behaviorvelocityplannerSkeleton(instanceSpec, mode)
    , m_logger(ara::log::CreateLogger("BHVP", "PORT", ara::log::LogLevel::kVerbose))
{
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_blindspotOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_blindspot(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_blindspot::Requested";
    
    planning_cooperatecommands_blindspotOutput response;
    ara::core::Promise<planning_cooperatecommands_blindspotOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_crosswalkOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_crosswalk(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_crosswalk::Requested";
    
    planning_cooperatecommands_crosswalkOutput response;
    ara::core::Promise<planning_cooperatecommands_crosswalkOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_intersectionOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_intersection(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_intersection::Requested";
    
    planning_cooperatecommands_intersectionOutput response;
    ara::core::Promise<planning_cooperatecommands_intersectionOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_intersectionocclusionOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_intersectionocclusion::Requested";
    
    planning_cooperatecommands_intersectionocclusionOutput response;
    ara::core::Promise<planning_cooperatecommands_intersectionocclusionOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_nostoppingareaOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_nostoppingarea::Requested";
    
    planning_cooperatecommands_nostoppingareaOutput response;
    ara::core::Promise<planning_cooperatecommands_nostoppingareaOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_cooperatecommands_trafficlightOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_cooperatecommands_trafficlight(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_cooperatecommands_trafficlight::Requested";
    
    planning_cooperatecommands_trafficlightOutput response;
    ara::core::Promise<planning_cooperatecommands_trafficlightOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_blindspotOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_blindspot(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_blindspot::Requested";
    
    planning_enableautomode_blindspotOutput response;
    ara::core::Promise<planning_enableautomode_blindspotOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_crosswalkOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_crosswalk(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_crosswalk::Requested";
    
    planning_enableautomode_crosswalkOutput response;
    ara::core::Promise<planning_enableautomode_crosswalkOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_intersectionOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_intersection(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_intersection::Requested";
    
    planning_enableautomode_intersectionOutput response;
    ara::core::Promise<planning_enableautomode_intersectionOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_intersectionocclusionOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_intersectionocclusion::Requested";
    
    planning_enableautomode_intersectionocclusionOutput response;
    ara::core::Promise<planning_enableautomode_intersectionocclusionOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_nostoppingareaOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_nostoppingarea::Requested";
    
    planning_enableautomode_nostoppingareaOutput response;
    ara::core::Promise<planning_enableautomode_nostoppingareaOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_enableautomode_trafficlightOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_enableautomode_trafficlight(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_enableautomode_trafficlight::Requested";
    
    planning_enableautomode_trafficlightOutput response;
    ara::core::Promise<planning_enableautomode_trafficlightOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<EBS_SI_behaviorvelocityplannerSkeleton::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput> EBS_SI_behaviorvelocityplannerSkeletonImpl::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Requested";
    
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput response;
    ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
} /// namespace skeleton
} /// namespace BVP2EBS
} /// namespace srv
} /// namespace oss

namespace exe_behaviorvelocityplanner
{
namespace aa
{
namespace port
{
 
PPort_BVP2EBS::PPort_BVP2EBS()
    : m_logger(ara::log::CreateLogger("BHVP", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_planning_automodestatus_blindspotData{{0U}, false}
    , m_planning_automodestatus_crosswalkData{{0U}, false}
    , m_planning_automodestatus_intersectionData{{0U}, false}
    , m_planning_automodestatus_intersectionocclusionData{{0U}, false}
    , m_planning_automodestatus_nostoppingareaData{{0U}, false}
    , m_planning_automodestatus_trafficlightData{{0U}, false}
    , m_planning_cooperatestatus_blindspotData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_cooperatestatus_crosswalkData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_cooperatestatus_intersectionData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_cooperatestatus_intersectionocclusionData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_cooperatestatus_nostoppingareaData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_cooperatestatus_trafficlightData{{{0, 0U}, "str_string"}, {{{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}, {{0, 0U}, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {0U}, false, false, {0U}, {0U}, false, 0.0f, 0.0f}}}
    , m_planning_debug_objectsofinterest_blindspotData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_debug_objectsofinterest_crosswalkData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_debug_objectsofinterest_intersectionData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_debug_objectsofinterest_nostoppingareaData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_debug_objectsofinterest_trafficlightData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_planningfactors_blindspotData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_crosswalkData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_detectionareaData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_intersectionData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_mergefromprivateData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_nostoppingareaData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_runoutData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_stoplineData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_trafficlightData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_planningfactors_walkwayData{{{0, 0U}, "str_string"}, {{"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}, {"str_string", false, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f}}, oss::type::PlanningFactor_behavior::UNKNOWN, "str_string", {{{0, 0U}, "str_string"}, {{oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}, {oss::type::SafetyFactor_type::UNKNOWN, {{{0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}}}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}}, {0, 0U}, 0.0f}, 0.0f, 0.0f, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, false, "str_string"}}, false, "str_string"}}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData{"str_string"}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData{0LL, {{oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}, {oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}, {oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData{{{0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}, {0, "str_string", 0.0, 0, "str_string"}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData{{0, 0U}, 0}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData{{0, 0U}, {{{"str_string", 0U, 0U}, {"str_string", 0U, 0U}, {"str_string", 0U, 0U}}, 0U}, {0.0f, 0.0f, 0.0f}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData{{{0, 0U}, "str_string"}, 0U, 0U, {{"str_string", 0U, 0U, 0U}, {"str_string", 0U, 0U, 0U}, {"str_string", 0U, 0U, 0U}}, false, 0U, 0U, {0U, 0U, 0U}, false}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData{{{{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}, {{{0, 0U}, "str_string"}, "str_string", 0, oss::type::Marker_type::ARROW, oss::type::Marker_action::ADD, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, {0.0, 0.0, 0.0}, {0.0f, 0.0f, 0.0f, 0.0f}, {0, 0U}, false, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f, 0.0f}}, "str_string", {{{0, 0U}, "str_string"}, "str_string", {0U, 0U, 0U}}, {{0.0f, 0.0f}, {0.0f, 0.0f}, {0.0f, 0.0f}}, "str_string", "str_string", {"str_string", {0U, 0U, 0U}}, false}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData{0LL, {{oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}, {oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}, {oss::type::TrafficLightElement_color::UNKNOWN, oss::type::TrafficLightElement_shape::UNKNOWN, oss::type::TrafficLightElement_status::UNKNOWN, 0.0f}}}
    , m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData{{{0, 0U}, "str_string"}, {{{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f, false}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f, false}, {{{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0}}, 0.0f, 0.0f, 0.0f, false}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}, {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}}}
{
}
 
PPort_BVP2EBS::~PPort_BVP2EBS()
{
}
 
void PPort_BVP2EBS::Start()
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::Start";
    
    // construct skeleton
    ara::core::InstanceSpecifier specifier{"Exe_behaviorvelocityplanner/AA/PPort_BVP2EBS"};
    m_interface = std::make_unique<oss::srv::BVP2EBS::skeleton::EBS_SI_behaviorvelocityplannerSkeletonImpl>(specifier);
    
    // offer service
    auto offer = m_interface->OfferService();
    if (offer.HasValue())
    {
        m_running = true;
        m_logger.LogVerbose() << "PPort_BVP2EBS::Start::OfferService";
    }
    else
    {
        m_running = false;
        m_logger.LogError() << "PPort_BVP2EBS::Start::OfferService::" << offer.Error().Message();
    }
}
 
void PPort_BVP2EBS::Terminate()
{
    m_logger.LogVerbose() << "PPort_BVP2EBS::Terminate";
    
    // stop port
    m_running = false;
    
    // stop offer service
    m_interface->StopOfferService();
    m_logger.LogVerbose() << "PPort_BVP2EBS::Terminate::StopOfferService";
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_blindspot.Send(m_planning_automodestatus_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_blindspot.Send(m_planning_automodestatus_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_blindspotData = data;
    auto send = m_interface->planning_automodestatus_blindspot.Send(m_planning_automodestatus_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_crosswalk.Send(m_planning_automodestatus_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_crosswalk.Send(m_planning_automodestatus_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_crosswalkData = data;
    auto send = m_interface->planning_automodestatus_crosswalk.Send(m_planning_automodestatus_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_intersection.Send(m_planning_automodestatus_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_intersection.Send(m_planning_automodestatus_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_intersectionData = data;
    auto send = m_interface->planning_automodestatus_intersection.Send(m_planning_automodestatus_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_intersectionocclusion(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_intersectionocclusion::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_intersectionocclusionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_intersectionocclusion.Send(m_planning_automodestatus_intersectionocclusionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_intersectionocclusion.Send(m_planning_automodestatus_intersectionocclusionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_intersectionocclusion::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_intersectionocclusionData = data;
    auto send = m_interface->planning_automodestatus_intersectionocclusion.Send(m_planning_automodestatus_intersectionocclusionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_intersectionocclusionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_nostoppingarea.Send(m_planning_automodestatus_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_nostoppingarea.Send(m_planning_automodestatus_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_nostoppingareaData = data;
    auto send = m_interface->planning_automodestatus_nostoppingarea.Send(m_planning_automodestatus_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_automodestatus_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_automodestatus_trafficlight.Send(m_planning_automodestatus_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_automodestatus_trafficlight.Send(m_planning_automodestatus_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_automodestatus_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_automodestatus_trafficlightData = data;
    auto send = m_interface->planning_automodestatus_trafficlight.Send(m_planning_automodestatus_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_automodestatus_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_blindspot.Send(m_planning_cooperatestatus_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_blindspot.Send(m_planning_cooperatestatus_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_blindspotData = data;
    auto send = m_interface->planning_cooperatestatus_blindspot.Send(m_planning_cooperatestatus_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_crosswalk.Send(m_planning_cooperatestatus_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_crosswalk.Send(m_planning_cooperatestatus_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_crosswalkData = data;
    auto send = m_interface->planning_cooperatestatus_crosswalk.Send(m_planning_cooperatestatus_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_intersection.Send(m_planning_cooperatestatus_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_intersection.Send(m_planning_cooperatestatus_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_intersectionData = data;
    auto send = m_interface->planning_cooperatestatus_intersection.Send(m_planning_cooperatestatus_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_intersectionocclusion(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_intersectionocclusion::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_intersectionocclusionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_intersectionocclusion.Send(m_planning_cooperatestatus_intersectionocclusionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_intersectionocclusion.Send(m_planning_cooperatestatus_intersectionocclusionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_intersectionocclusion::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_intersectionocclusionData = data;
    auto send = m_interface->planning_cooperatestatus_intersectionocclusion.Send(m_planning_cooperatestatus_intersectionocclusionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_intersectionocclusionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_nostoppingarea.Send(m_planning_cooperatestatus_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_nostoppingarea.Send(m_planning_cooperatestatus_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_nostoppingareaData = data;
    auto send = m_interface->planning_cooperatestatus_nostoppingarea.Send(m_planning_cooperatestatus_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_cooperatestatus_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_cooperatestatus_trafficlight.Send(m_planning_cooperatestatus_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_cooperatestatus_trafficlight.Send(m_planning_cooperatestatus_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_cooperatestatus_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_cooperatestatus_trafficlightData = data;
    auto send = m_interface->planning_cooperatestatus_trafficlight.Send(m_planning_cooperatestatus_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_cooperatestatus_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_debug_objectsofinterest_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_debug_objectsofinterest_blindspot.Send(m_planning_debug_objectsofinterest_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_debug_objectsofinterest_blindspot.Send(m_planning_debug_objectsofinterest_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_blindspotData = data;
    auto send = m_interface->planning_debug_objectsofinterest_blindspot.Send(m_planning_debug_objectsofinterest_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_debug_objectsofinterest_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_debug_objectsofinterest_crosswalk.Send(m_planning_debug_objectsofinterest_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_debug_objectsofinterest_crosswalk.Send(m_planning_debug_objectsofinterest_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_crosswalkData = data;
    auto send = m_interface->planning_debug_objectsofinterest_crosswalk.Send(m_planning_debug_objectsofinterest_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_debug_objectsofinterest_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_debug_objectsofinterest_intersection.Send(m_planning_debug_objectsofinterest_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_debug_objectsofinterest_intersection.Send(m_planning_debug_objectsofinterest_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_intersectionData = data;
    auto send = m_interface->planning_debug_objectsofinterest_intersection.Send(m_planning_debug_objectsofinterest_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_debug_objectsofinterest_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_debug_objectsofinterest_nostoppingarea.Send(m_planning_debug_objectsofinterest_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_debug_objectsofinterest_nostoppingarea.Send(m_planning_debug_objectsofinterest_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_nostoppingareaData = data;
    auto send = m_interface->planning_debug_objectsofinterest_nostoppingarea.Send(m_planning_debug_objectsofinterest_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_debug_objectsofinterest_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_debug_objectsofinterest_trafficlight.Send(m_planning_debug_objectsofinterest_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_debug_objectsofinterest_trafficlight.Send(m_planning_debug_objectsofinterest_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_debug_objectsofinterest_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_debug_objectsofinterest_trafficlightData = data;
    auto send = m_interface->planning_debug_objectsofinterest_trafficlight.Send(m_planning_debug_objectsofinterest_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_debug_objectsofinterest_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_blindspot.Send(m_planning_planningfactors_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_blindspot.Send(m_planning_planningfactors_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_blindspotData = data;
    auto send = m_interface->planning_planningfactors_blindspot.Send(m_planning_planningfactors_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_crosswalk.Send(m_planning_planningfactors_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_crosswalk.Send(m_planning_planningfactors_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_crosswalkData = data;
    auto send = m_interface->planning_planningfactors_crosswalk.Send(m_planning_planningfactors_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_detectionarea(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_detectionareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_detectionarea.Send(m_planning_planningfactors_detectionareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_detectionarea.Send(m_planning_planningfactors_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_detectionareaData = data;
    auto send = m_interface->planning_planningfactors_detectionarea.Send(m_planning_planningfactors_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_intersection.Send(m_planning_planningfactors_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_intersection.Send(m_planning_planningfactors_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_intersectionData = data;
    auto send = m_interface->planning_planningfactors_intersection.Send(m_planning_planningfactors_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_mergefromprivate(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_mergefromprivateData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_mergefromprivate.Send(m_planning_planningfactors_mergefromprivateData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_mergefromprivate.Send(m_planning_planningfactors_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_mergefromprivateData = data;
    auto send = m_interface->planning_planningfactors_mergefromprivate.Send(m_planning_planningfactors_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_nostoppingarea.Send(m_planning_planningfactors_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_nostoppingarea.Send(m_planning_planningfactors_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_nostoppingareaData = data;
    auto send = m_interface->planning_planningfactors_nostoppingarea.Send(m_planning_planningfactors_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_runout(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_runoutData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_runoutCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_runout.Send(m_planning_planningfactors_runoutData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_runout.Send(m_planning_planningfactors_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_runoutData = data;
    auto send = m_interface->planning_planningfactors_runout.Send(m_planning_planningfactors_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_stopline(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_stoplineData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_stopline.Send(m_planning_planningfactors_stoplineData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_stopline.Send(m_planning_planningfactors_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_stoplineData = data;
    auto send = m_interface->planning_planningfactors_stopline.Send(m_planning_planningfactors_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_trafficlight.Send(m_planning_planningfactors_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_trafficlight.Send(m_planning_planningfactors_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_trafficlightData = data;
    auto send = m_interface->planning_planningfactors_trafficlight.Send(m_planning_planningfactors_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_planningfactors_walkway(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_walkwayData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_planningfactors_walkway.Send(m_planning_planningfactors_walkwayData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_planningfactors_walkway.Send(m_planning_planningfactors_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_planningfactors_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_planningfactors_walkwayData = data;
    auto send = m_interface->planning_planningfactors_walkway.Send(m_planning_planningfactors_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_planningfactors_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::WriteDataplanning_scenarioplanning_lanedriving_behaviorplanning_path(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_path::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData = data;
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathCyclic::Send";
            }
            else
            {
                m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathCyclic::Send::" << send.Error().Message();
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered::Send::" << send.Error().Message();
    }
}
 
void PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered(const oss::srv::BVP2EBS::skeleton::events::planning_scenarioplanning_lanedriving_behaviorplanning_path::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData = data;
    auto send = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.Send(m_planning_scenarioplanning_lanedriving_behaviorplanning_pathData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered::Send";
    }
    else
    {
        m_logger.LogError() << "PPort_BVP2EBS::SendEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered::Send::" << send.Error().Message();
    }
}
 
} /// namespace port
} /// namespace aa
} /// namespace exe_behaviorvelocityplanner
 
/// EOF