///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_obstaclecruiseplanner.h
/// SOFTWARE COMPONENT NAME           : Swc_obstaclecruiseplanner
/// GENERATED DATE                    : 2025-12-12 16:18:11
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_AA_GEN_SOFTWARE_COMPONENT_EXE_OBSTACLECRUISEPLANNER_AA_H
#define PARA_AA_GEN_SOFTWARE_COMPONENT_EXE_OBSTACLECRUISEPLANNER_AA_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_obstaclecruiseplanner/aa/port/pport_ocp2evls.h"
#include "exe_obstaclecruiseplanner/aa/port/pport_ocp2ss.h"
#include "exe_obstaclecruiseplanner/aa/port/rport_mvp2ocp.h"
#include "exe_obstaclecruiseplanner/aa/port/rport_scr2ocp.h"
#include "exe_obstaclecruiseplanner/aa/port/pport_ocp2scr.h"

#include "ara/log/logger.h"
#include "para/swc/port_pool.h"

#include <mutex>
#include <memory>
#include <vector>
#include <cstdint>
#include <random>

namespace exe_obstaclecruiseplanner
{
    namespace aa
    {

        class Swc_obstaclecruiseplanner
        {
        public:
            /// @brief Constructor
            Swc_obstaclecruiseplanner();

            /// @brief Destructor
            ~Swc_obstaclecruiseplanner();

            /// @brief Initialize software component
            bool Initialize();

            /// @brief Start software component
            void Start();

            /// @brief Terminate software component
            void Terminate();

            /// @brief Run software component
            void Run();

        private:
            /// @brief Running status of software component
            bool m_running;

            /// @brief Pool of port
            ::para::swc::PortPool m_workers;

            /// @brief Logger for software component
            ara::log::Logger &m_logger;

            /// @brief Instance of Port {Swc_obstaclecruiseplanner.PPort_OCP2EVLS}
            std::unique_ptr<exe_obstaclecruiseplanner::aa::port::PPort_OCP2EVLS> m_PPort_OCP2EVLS;

            /// @brief Instance of Port {Swc_obstaclecruiseplanner.PPort_OCP2SS}
            std::unique_ptr<exe_obstaclecruiseplanner::aa::port::PPort_OCP2SS> m_PPort_OCP2SS;

            /// @brief Instance of Port {Swc_obstaclecruiseplanner.RPort_MVP2OCP}
            std::unique_ptr<exe_obstaclecruiseplanner::aa::port::RPort_MVP2OCP> m_RPort_MVP2OCP;

            /// @brief Instance of Port {Swc_obstaclecruiseplanner.RPort_SCr2OCP}
            std::unique_ptr<exe_obstaclecruiseplanner::aa::port::RPort_SCr2OCP> m_RPort_SCr2OCP;

            /// @brief Instance of Port {Swc_obstaclecruiseplanner.PPort_OCP2SCr}
            std::unique_ptr<exe_obstaclecruiseplanner::aa::port::PPort_OCP2SCr> m_PPort_OCP2SCr;

        private:
            // Scenario handling members
            std::mutex m_scenario_mutex;
            std::uint8_t m_current_scenario_id{0};

            // Trajectory buffer for thread-safe passing
            // Using AUTOSAR trajectory type from PPort_OCP2SCr
            struct TrajectoryBuffer
            {
                std::mutex mutex;
                oss::srv::OCP2SCr::skeleton::events::trajectory::SampleType data;
                bool is_valid{false};
            };
            std::unique_ptr<TrajectoryBuffer> m_trajectory_buffer;

            // Processor-like timing helpers
            std::mt19937 m_rng{std::random_device{}()};
            std::uniform_int_distribution<int64_t> interval_dist_ns_{
                140'124'091, // 140 ms
                188'221'083  // 188 ms
            };

            // Callback handler for scenario triggered event
            void onScenarioTriggered(std::uint8_t scenario_id);

            // JSONL reading and conversion
            std::string getScenarioFilePath(std::uint8_t scenario_id);
            void loadAndProcessScenario(std::uint8_t scenario_id);
        };

    } /// namespace aa
} /// namespace exe_obstaclecruiseplanner

#endif /// PARA_AA_GEN_SOFTWARE_COMPONENT_EXE_OBSTACLECRUISEPLANNER_AA_H