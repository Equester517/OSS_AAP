///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_obstaclecruiseplanner.cpp
/// SOFTWARE COMPONENT NAME           : Swc_obstaclecruiseplanner
/// GENERATED DATE                    : 2025-12-12 16:18:12
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_obstaclecruiseplanner/aa/swc_obstaclecruiseplanner.h"

#include <experimental/filesystem>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <thread>
#include <string>
#include <chrono>
#include <random>
#include <nlohmann/json.hpp>

namespace fs = std::experimental::filesystem;
using json = nlohmann::json;

namespace exe_obstaclecruiseplanner
{
    namespace aa
    {

        Swc_obstaclecruiseplanner::Swc_obstaclecruiseplanner()
            : m_logger(ara::log::CreateLogger("OCPL", "SWC", ara::log::LogLevel::kVerbose)), m_running{false}, m_workers(49), m_current_scenario_id{0}, m_trajectory_buffer(std::make_unique<TrajectoryBuffer>())
        {
        }

        Swc_obstaclecruiseplanner::~Swc_obstaclecruiseplanner()
        {
        }

        bool Swc_obstaclecruiseplanner::Initialize()
        {
            m_logger.LogVerbose() << "Swc_obstaclecruiseplanner::Initialize";

            bool init = true;

            // m_PPort_OCP2EVLS = std::make_unique<exe_obstaclecruiseplanner::aa::port::PPort_OCP2EVLS>();
            // m_PPort_OCP2SS = std::make_unique<exe_obstaclecruiseplanner::aa::port::PPort_OCP2SS>();
            m_RPort_MVP2OCP = std::make_unique<exe_obstaclecruiseplanner::aa::port::RPort_MVP2OCP>();
            m_RPort_SCr2OCP = std::make_unique<exe_obstaclecruiseplanner::aa::port::RPort_SCr2OCP>();
            m_PPort_OCP2SCr = std::make_unique<exe_obstaclecruiseplanner::aa::port::PPort_OCP2SCr>();

            // put your code for initialization

            return init;
        }

        void Swc_obstaclecruiseplanner::Start()
        {
            m_logger.LogVerbose() << "Swc_obstaclecruiseplanner::Start";

            // m_PPort_OCP2EVLS->Start();
            // m_PPort_OCP2SS->Start();
            m_RPort_MVP2OCP->Start();
            m_RPort_SCr2OCP->Start();
            m_PPort_OCP2SCr->Start();

            // Register callback for scenario triggered event
            m_RPort_SCr2OCP->RegistEventHandlerscenario(
                [this](const std::uint8_t &scenario_id)
                {
                    this->onScenarioTriggered(scenario_id);
                });
        }

        void Swc_obstaclecruiseplanner::Terminate()
        {
            m_logger.LogVerbose() << "Swc_obstaclecruiseplanner::Terminate";

            // stop running
            m_running = false;

            // m_PPort_OCP2EVLS->Terminate();
            // m_PPort_OCP2SS->Terminate();
            m_RPort_MVP2OCP->Terminate();
            m_RPort_SCr2OCP->Terminate();
            m_PPort_OCP2SCr->Terminate();
        }

        void Swc_obstaclecruiseplanner::Run()
        {
            m_logger.LogVerbose() << "Swc_obstaclecruiseplanner::Run";

            // start running
            m_running = true;

            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_debug_objectsofinterest_obstaclecruiseplannerCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_planningfactors_obstaclecruiseplannerCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_clearvelocitylimitCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_debug_cruiseplanninginfoCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_debug_markerCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_debug_processingtimemsCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_debug_slowdownplanninginfoCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_debug_stopplanninginfoCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_metricsCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_output_stopspeedexceededCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_virtualwall_cruiseCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_virtualwall_slowdownCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_motionplanning_obstaclecruiseplanner_virtualwall_stopCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_lanedriving_trajectoryCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2EVLS->SendEventplanning_scenarioplanning_maxvelocitycandidatesCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2SS->SendEventplanning_scenarioplanning_lanedriving_trajectoryCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_planningfactors_dynamicobstaclestopCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_planningfactors_outoflaneCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_dynamicobstaclestop_pstmsdiagCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_markersCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_obstaclevelocitylimiter_pstmsdiagCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_outoflane_processingtimemsdiagCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_debug_processingtimemsdiagCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_debugmarkersCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_dynamicobstaclestop_virtualwallsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_metricsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_debugmarkersCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_obstaclevelocitylimiter_virtualwallsCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_debugmarkersCyclic(); });
            // m_workers.Async([this] { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_outoflane_virtualwallsCyclic(); });
            m_workers.Async([this]
                            { m_RPort_MVP2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_motionplanning_motionvelocityplanner_trajectoryCyclic(); });

            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventclockCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventlocalization_accelerationCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventlocalization_kinematicstateCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventmap_vectormapCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventperception_objectrecognition_objectsCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventperception_obstaclesegmentation_pointcloudCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventperception_occupancygridmap_mapCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventperception_trafficlightrecognition_trafficsignalsCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorpathplanner_input_lateraloffsetCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventplanning_scenarioplanning_maxvelocitydefaultCyclic(); });
            // m_workers.Async([this] { m_RPort_SCr2OCP->ReceiveEventsystem_operationmode_stateCyclic(); });

            m_workers.Async([this]
                            { m_RPort_SCr2OCP->ReceiveEventscenarioCyclic(); });

            // m_workers.Async([this] { m_PPort_OCP2SCr->SendEventtrajectoryCyclic(); });
            // m_workers.Async([this] { m_PPort_OCP2SCr->SendEventscenarioCyclic(); });

            m_workers.Wait();
        }

        std::string Swc_obstaclecruiseplanner::getScenarioFilePath(std::uint8_t scenario_id)
        {
            // Map scenario ID to jsonl file path
            // The reference_output folder is copied to the build directory.
            // Depending on where the executable runs, files may be under
            // "reference_output/..." or "src/reference_output/...".

            // 1) Try relative path from current working directory
            {
                std::string p = "reference_output/scenario_" + std::to_string(scenario_id) + "/planning__scenario_planning__trajectory.jsonl";
                if (fs::exists(p))
                    return p;
            }

            // 2) Try path under src/ (as seen in build tree)
            {
                std::string p = "src/reference_output/scenario_" + std::to_string(scenario_id) + "/planning__scenario_planning__trajectory.jsonl";
                if (fs::exists(p))
                    return p;
            }

            // 2.6) Try path from EM install bin to build tree
            // CWD: build/install/opt/Exe_obstaclecruiseplanner/bin
            // Build tree: build/Exe_obstaclecruiseplanner/src/reference_output
            {
                std::string p = "../../../../Exe_obstaclecruiseplanner/src/reference_output/scenario_" + std::to_string(scenario_id) + "/planning__scenario_planning__trajectory.jsonl";
                if (fs::exists(p))
                    return p;
            }

            // 3) Try source tree absolute-relative fallback
            {
                std::string p = "../Exe_obstaclecruiseplanner/OSS_TEST_HELPER/reference_output/scenario_" + std::to_string(scenario_id) + "/planning__scenario_planning__trajectory.jsonl";
                if (fs::exists(p))
                    return p;
            }

            // If none found, return default relative path (will log not found)
            return "reference_output/scenario_" + std::to_string(scenario_id) + "/planning__scenario_planning__trajectory.jsonl";
        }

        void Swc_obstaclecruiseplanner::onScenarioTriggered(std::uint8_t scenario_id)
        {
            m_logger.LogInfo() << "Swc_obstaclecruiseplanner::onScenarioTriggered - Scenario ID: " << static_cast<int>(scenario_id);

            // Store current scenario ID
            {
                std::lock_guard<std::mutex> lock(m_scenario_mutex);
                m_current_scenario_id = scenario_id;
            }

            // Immediately notify ServiceCreator of scenario ID before heavy parsing
            m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Sending scenario ID (pre-parse) to ServiceCreator: " << static_cast<int>(scenario_id);
            m_PPort_OCP2SCr->SendEventscenarioTriggered(scenario_id);

            // Load JSONL file and prepare data
            try
            {
                loadAndProcessScenario(scenario_id);

                // Trajectory data is already being sent in loadAndProcessScenario
                // via SendEventtrajectoryTriggered()
            }
            catch (const std::exception &e)
            {
                m_logger.LogError() << "Swc_obstaclecruiseplanner::Failed to process scenario: " << e.what();
            }
        }

        void Swc_obstaclecruiseplanner::loadAndProcessScenario(std::uint8_t scenario_id)
        {
            try
            {
                // Get file path for this scenario
                std::string file_path = getScenarioFilePath(scenario_id);
                // Log current working directory to diagnose path issues
                try
                {
                    m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Current working dir: " << fs::current_path().string().c_str();
                }
                catch (...)
                {
                    m_logger.LogWarn() << "Swc_obstaclecruiseplanner::Failed to get current working dir";
                }
                m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Loading scenario file: " << file_path.c_str();

                // Verify file exists
                if (!fs::exists(file_path))
                {
                    m_logger.LogError() << "Swc_obstaclecruiseplanner::Scenario file not found: " << file_path.c_str();
                    return;
                }

                // Open JSONL file
                std::ifstream jsonl_file(file_path);
                if (!jsonl_file.is_open())
                {
                    m_logger.LogError() << "Swc_obstaclecruiseplanner::Failed to open file: " << file_path.c_str();
                    return;
                }

                m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Successfully opened scenario file";

                // Read all non-empty lines first to allow timing behavior like Processor
                std::vector<std::string> lines;
                {
                    std::string line;
                    while (std::getline(jsonl_file, line))
                    {
                        if (!line.empty())
                        {
                            lines.emplace_back(std::move(line));
                        }
                    }
                }
                jsonl_file.close();

                m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Successfully loaded " << lines.size() << " messages";

                // Initialize current timestamp in nanoseconds (same logic as Processor)
                constexpr std::int64_t kNanosecondsInSecond = 1'000'000'000;
                std::int64_t current_ts_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                                 std::chrono::system_clock::now().time_since_epoch())
                                                 .count();

                for (std::size_t index = 0; index < lines.size(); ++index)
                {
                    try
                    {
                        // Parse JSON line
                        json j = json::parse(lines[index]);

                        // Create AUTOSAR trajectory type
                        oss::srv::OCP2SCr::skeleton::events::trajectory::SampleType autosar_trajectory;

                        // Parse message object
                        auto msg = j["message"];

                        // Overwrite header timestamp with current_ts_ns
                        const auto sec = static_cast<std::uint32_t>(current_ts_ns / kNanosecondsInSecond);
                        const auto nanosec = static_cast<std::uint32_t>(current_ts_ns % kNanosecondsInSecond);
                        autosar_trajectory.header.stamp.sec = sec;
                        autosar_trajectory.header.stamp.nanosec = nanosec;
                        autosar_trajectory.header.frame_id = msg["header"]["frame_id"].get<std::string>();

                        // Parse points array
                        auto points = msg["points"];
                        autosar_trajectory.points.clear();
                        autosar_trajectory.points.reserve(points.size());

                        for (const auto &point : points)
                        {
                            oss::type::autoware_planning_msgs::msg::TrajectoryPoint traj_point;

                            // time_from_start
                            traj_point.time_from_start.sec = point["time_from_start"]["sec"].get<std::int32_t>();
                            traj_point.time_from_start.nanosec = point["time_from_start"]["nanosec"].get<std::uint32_t>();

                            // pose
                            traj_point.pose.position.x = point["pose"]["position"]["x"].get<double>();
                            traj_point.pose.position.y = point["pose"]["position"]["y"].get<double>();
                            traj_point.pose.position.z = point["pose"]["position"]["z"].get<double>();

                            traj_point.pose.orientation.x = point["pose"]["orientation"]["x"].get<double>();
                            traj_point.pose.orientation.y = point["pose"]["orientation"]["y"].get<double>();
                            traj_point.pose.orientation.z = point["pose"]["orientation"]["z"].get<double>();
                            traj_point.pose.orientation.w = point["pose"]["orientation"]["w"].get<double>();

                            // velocities and accelerations
                            traj_point.longitudinal_velocity_mps = point["longitudinal_velocity_mps"].get<float>();
                            traj_point.lateral_velocity_mps = point["lateral_velocity_mps"].get<float>();
                            traj_point.acceleration_mps2 = point["acceleration_mps2"].get<float>();
                            traj_point.heading_rate_rps = point["heading_rate_rps"].get<float>();
                            traj_point.front_wheel_angle_rad = point["front_wheel_angle_rad"].get<float>();
                            traj_point.rear_wheel_angle_rad = point["rear_wheel_angle_rad"].get<float>();

                            // Add point to trajectory
                            autosar_trajectory.points.push_back(traj_point);
                        }

                        // Send trajectory via PPort
                        m_PPort_OCP2SCr->SendEventtrajectoryTriggered(autosar_trajectory);
                        m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Sent [message " << (index + 1)
                                           << "] ts=" << current_ts_ns
                                           << " points=" << autosar_trajectory.points.size();

                        // Advance time with small random delay like Processor
                        if (index + 1 < lines.size())
                        {
                            const int64_t delay_ns = interval_dist_ns_(m_rng);
                            std::this_thread::sleep_for(std::chrono::nanoseconds(delay_ns));
                            current_ts_ns += static_cast<std::int64_t>(delay_ns);
                        }
                    }
                    catch (const nlohmann::json::exception &e)
                    {
                        m_logger.LogError() << "Swc_obstaclecruiseplanner::JSON parsing error: " << e.what();
                        continue;
                    }
                    catch (const std::exception &e)
                    {
                        m_logger.LogError() << "Swc_obstaclecruiseplanner::Error processing scenario line: " << e.what();
                        continue;
                    }
                }

                m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Successfully processed " << lines.size() << " lines from scenario file";

                // Send scenario completion notification
                m_PPort_OCP2SCr->SendEventscenarioTriggered(m_current_scenario_id);
                m_logger.LogInfo() << "Swc_obstaclecruiseplanner::Sent scenario completion notification for scenario " << static_cast<int>(m_current_scenario_id);
            }
            catch (const std::exception &e)
            {
                m_logger.LogError() << "Swc_obstaclecruiseplanner::Failed to process scenario: " << e.what();
            }
        }

    } /// namespace aa
} /// namespace exe_obstaclecruiseplanner