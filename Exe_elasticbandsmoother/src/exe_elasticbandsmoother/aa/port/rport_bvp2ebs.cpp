///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : rport_bvp2ebs.cpp
/// SOFTWARE COMPONENT NAME           : RPort_BVP2EBS
/// GENERATED DATE                    : 2025-12-05 12:02:34
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "exe_elasticbandsmoother/aa/port/rport_bvp2ebs.h"
 
namespace exe_elasticbandsmoother
{
namespace aa
{
namespace port
{
 
RPort_BVP2EBS::RPort_BVP2EBS()
    : m_logger(ara::log::CreateLogger("EBST", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
    , m_found{false}
    , m_receiverplanning_automodestatus_blindspot{nullptr}
    , m_receiverplanning_automodestatus_crosswalk{nullptr}
    , m_receiverplanning_automodestatus_intersection{nullptr}
    , m_receiverplanning_automodestatus_intersectionocclusion{nullptr}
    , m_receiverplanning_automodestatus_nostoppingarea{nullptr}
    , m_receiverplanning_automodestatus_trafficlight{nullptr}
    , m_receiverplanning_cooperatestatus_blindspot{nullptr}
    , m_receiverplanning_cooperatestatus_crosswalk{nullptr}
    , m_receiverplanning_cooperatestatus_intersection{nullptr}
    , m_receiverplanning_cooperatestatus_intersectionocclusion{nullptr}
    , m_receiverplanning_cooperatestatus_nostoppingarea{nullptr}
    , m_receiverplanning_cooperatestatus_trafficlight{nullptr}
    , m_receiverplanning_debug_objectsofinterest_blindspot{nullptr}
    , m_receiverplanning_debug_objectsofinterest_crosswalk{nullptr}
    , m_receiverplanning_debug_objectsofinterest_intersection{nullptr}
    , m_receiverplanning_debug_objectsofinterest_nostoppingarea{nullptr}
    , m_receiverplanning_debug_objectsofinterest_trafficlight{nullptr}
    , m_receiverplanning_planningfactors_blindspot{nullptr}
    , m_receiverplanning_planningfactors_crosswalk{nullptr}
    , m_receiverplanning_planningfactors_detectionarea{nullptr}
    , m_receiverplanning_planningfactors_intersection{nullptr}
    , m_receiverplanning_planningfactors_mergefromprivate{nullptr}
    , m_receiverplanning_planningfactors_nostoppingarea{nullptr}
    , m_receiverplanning_planningfactors_runout{nullptr}
    , m_receiverplanning_planningfactors_stopline{nullptr}
    , m_receiverplanning_planningfactors_trafficlight{nullptr}
    , m_receiverplanning_planningfactors_walkway{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal{nullptr}
    , m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_path{nullptr}
    , m_responderplanning_cooperatecommands_blindspot{nullptr}
    , m_responderplanning_cooperatecommands_crosswalk{nullptr}
    , m_responderplanning_cooperatecommands_intersection{nullptr}
    , m_responderplanning_cooperatecommands_intersectionocclusion{nullptr}
    , m_responderplanning_cooperatecommands_nostoppingarea{nullptr}
    , m_responderplanning_cooperatecommands_trafficlight{nullptr}
    , m_responderplanning_enableautomode_blindspot{nullptr}
    , m_responderplanning_enableautomode_crosswalk{nullptr}
    , m_responderplanning_enableautomode_intersection{nullptr}
    , m_responderplanning_enableautomode_intersectionocclusion{nullptr}
    , m_responderplanning_enableautomode_nostoppingarea{nullptr}
    , m_responderplanning_enableautomode_trafficlight{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters{nullptr}
    , m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically{nullptr}
{
}
 
RPort_BVP2EBS::~RPort_BVP2EBS()
{
}
 
void RPort_BVP2EBS::Start()
{
    m_logger.LogVerbose() << "RPort_BVP2EBS::Start";
    
    // regist callback
    ara::core::InstanceSpecifier specifier{"Exe_elasticbandsmoother/AA/RPort_BVP2EBS"};
    auto handler = [this](ara::com::ServiceHandleContainer<oss::srv::BVP2EBS::proxy::EBS_SI_behaviorvelocityplannerProxy::HandleType> handles,
                          ara::com::FindServiceHandle findHandle) {
        this->Find(handles, findHandle);
    };
    
    // find service
    auto find = oss::srv::BVP2EBS::proxy::EBS_SI_behaviorvelocityplannerProxy::StartFindService(handler, specifier);
    if (find.HasValue())
    {
        m_logger.LogVerbose() << "RPort_BVP2EBS::Start::StartFindService";
    }
    else
    {
        m_logger.LogError() << "RPort_BVP2EBS::Start::StartFindService::" << find.Error().Message();
    }
    
    // run port
    m_running = true;
}
 
void RPort_BVP2EBS::Terminate()
{
    m_logger.LogVerbose() << "RPort_BVP2EBS::Terminate";
    
    // stop port
    m_running = false;
    
    // clear service proxy
    if (m_interface)
    {
        // stop subscribe
        StopSubscribeplanning_automodestatus_blindspot();
        StopSubscribeplanning_automodestatus_crosswalk();
        StopSubscribeplanning_automodestatus_intersection();
        StopSubscribeplanning_automodestatus_intersectionocclusion();
        StopSubscribeplanning_automodestatus_nostoppingarea();
        StopSubscribeplanning_automodestatus_trafficlight();
        StopSubscribeplanning_cooperatestatus_blindspot();
        StopSubscribeplanning_cooperatestatus_crosswalk();
        StopSubscribeplanning_cooperatestatus_intersection();
        StopSubscribeplanning_cooperatestatus_intersectionocclusion();
        StopSubscribeplanning_cooperatestatus_nostoppingarea();
        StopSubscribeplanning_cooperatestatus_trafficlight();
        StopSubscribeplanning_debug_objectsofinterest_blindspot();
        StopSubscribeplanning_debug_objectsofinterest_crosswalk();
        StopSubscribeplanning_debug_objectsofinterest_intersection();
        StopSubscribeplanning_debug_objectsofinterest_nostoppingarea();
        StopSubscribeplanning_debug_objectsofinterest_trafficlight();
        StopSubscribeplanning_planningfactors_blindspot();
        StopSubscribeplanning_planningfactors_crosswalk();
        StopSubscribeplanning_planningfactors_detectionarea();
        StopSubscribeplanning_planningfactors_intersection();
        StopSubscribeplanning_planningfactors_mergefromprivate();
        StopSubscribeplanning_planningfactors_nostoppingarea();
        StopSubscribeplanning_planningfactors_runout();
        StopSubscribeplanning_planningfactors_stopline();
        StopSubscribeplanning_planningfactors_trafficlight();
        StopSubscribeplanning_planningfactors_walkway();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal();
        StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path();
        
        // stop find service
        m_interface->StopFindService(*m_findHandle);
        m_found = false;
        
        m_logger.LogVerbose() << "RPort_BVP2EBS::Terminate::StopFindService";
    }
}
 
void RPort_BVP2EBS::Find(ara::com::ServiceHandleContainer<oss::srv::BVP2EBS::proxy::EBS_SI_behaviorvelocityplannerProxy::HandleType> handles, ara::com::FindServiceHandle findHandle)
{
    // check finding handles
    if (handles.empty())
    {
        m_logger.LogVerbose() << "RPort_BVP2EBS::Find::Service Instances not found";
        return;
    }
    else
    {
        for (auto& handle : handles)
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Find::Searched Instance::ServiceId =" << 
                                     handle.GetServiceHandle().serviceId << 
                                     ", InstanceId =" << 
                                     handle.GetServiceHandle().instanceId;
        }
    }
    
    // create proxy
    if (m_interface)
    {
        m_logger.LogVerbose() << "RPort_BVP2EBS::Find::Proxy is already running";
    }
    else
    {
        m_logger.LogVerbose() << "RPort_BVP2EBS::Find::Using Instance::ServiceId =" << 
                                 handles[0].GetServiceHandle().serviceId << 
                                 ", InstanceId =" << 
                                 handles[0].GetServiceHandle().instanceId;
        m_interface = std::make_unique<oss::srv::BVP2EBS::proxy::EBS_SI_behaviorvelocityplannerProxy>(handles[0]);
        m_findHandle = std::make_unique<ara::com::FindServiceHandle>(findHandle);
        m_found = true;
        
        // subscribe events
        Subscribeplanning_automodestatus_blindspot();
        Subscribeplanning_automodestatus_crosswalk();
        Subscribeplanning_automodestatus_intersection();
        Subscribeplanning_automodestatus_intersectionocclusion();
        Subscribeplanning_automodestatus_nostoppingarea();
        Subscribeplanning_automodestatus_trafficlight();
        Subscribeplanning_cooperatestatus_blindspot();
        Subscribeplanning_cooperatestatus_crosswalk();
        Subscribeplanning_cooperatestatus_intersection();
        Subscribeplanning_cooperatestatus_intersectionocclusion();
        Subscribeplanning_cooperatestatus_nostoppingarea();
        Subscribeplanning_cooperatestatus_trafficlight();
        Subscribeplanning_debug_objectsofinterest_blindspot();
        Subscribeplanning_debug_objectsofinterest_crosswalk();
        Subscribeplanning_debug_objectsofinterest_intersection();
        Subscribeplanning_debug_objectsofinterest_nostoppingarea();
        Subscribeplanning_debug_objectsofinterest_trafficlight();
        Subscribeplanning_planningfactors_blindspot();
        Subscribeplanning_planningfactors_crosswalk();
        Subscribeplanning_planningfactors_detectionarea();
        Subscribeplanning_planningfactors_intersection();
        Subscribeplanning_planningfactors_mergefromprivate();
        Subscribeplanning_planningfactors_nostoppingarea();
        Subscribeplanning_planningfactors_runout();
        Subscribeplanning_planningfactors_stopline();
        Subscribeplanning_planningfactors_trafficlight();
        Subscribeplanning_planningfactors_walkway();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal();
        Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path();
    }
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_blindspot)
    {
        m_receiverplanning_automodestatus_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_blindspot::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_crosswalk)
    {
        m_receiverplanning_automodestatus_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_intersection)
    {
        m_receiverplanning_automodestatus_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_intersection::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_intersectionocclusion()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_intersectionocclusion();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_intersectionocclusion.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_intersectionocclusion::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_intersectionocclusion::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_intersectionocclusion()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_intersectionocclusion.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_intersectionocclusion::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersectionocclusion()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_intersectionocclusionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_intersectionocclusion.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersectionocclusion::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_intersectionocclusion::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_intersectionocclusion.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_intersectionocclusion.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_intersectionocclusion(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusion::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusion::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_intersectionocclusion.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_intersectionocclusion.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_intersectionocclusion(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusion::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_intersectionocclusion::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_intersectionocclusion(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_intersectionocclusion::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_intersectionocclusion)
    {
        m_receiverplanning_automodestatus_intersectionocclusion(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_intersectionocclusion(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_intersectionocclusion::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_intersectionocclusion = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_nostoppingarea)
    {
        m_receiverplanning_automodestatus_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_automodestatus_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_automodestatus_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_automodestatus_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_automodestatus_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_automodestatus_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_automodestatus_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_automodestatus_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_automodestatus_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_automodestatus_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_automodestatus_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_automodestatus_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_automodestatus_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_automodestatus_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_automodestatus_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_automodestatus_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_automodestatus_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_automodestatus_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_automodestatus_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_automodestatus_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_automodestatus_trafficlight)
    {
        m_receiverplanning_automodestatus_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_automodestatus_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_automodestatus_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_automodestatus_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_blindspot)
    {
        m_receiverplanning_cooperatestatus_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_blindspot::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_crosswalk)
    {
        m_receiverplanning_cooperatestatus_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_intersection)
    {
        m_receiverplanning_cooperatestatus_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_intersection::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersectionocclusion()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_intersectionocclusion();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_intersectionocclusion.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersectionocclusion::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_intersectionocclusion::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_intersectionocclusion()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_intersectionocclusion.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_intersectionocclusion::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersectionocclusion()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_intersectionocclusionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_intersectionocclusion.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersectionocclusion::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_intersectionocclusion::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_intersectionocclusion.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_intersectionocclusion.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersectionocclusion(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusion::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusion::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_intersectionocclusion.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_intersectionocclusion.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersectionocclusion(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusion::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_intersectionocclusion::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_intersectionocclusion(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_intersectionocclusion::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_intersectionocclusion)
    {
        m_receiverplanning_cooperatestatus_intersectionocclusion(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_intersectionocclusion(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_intersectionocclusion::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_intersectionocclusion = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_nostoppingarea)
    {
        m_receiverplanning_cooperatestatus_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_cooperatestatus_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_cooperatestatus_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_cooperatestatus_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_cooperatestatus_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_cooperatestatus_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_cooperatestatus_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_cooperatestatus_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_cooperatestatus_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_cooperatestatus_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_cooperatestatus_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_cooperatestatus_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_cooperatestatus_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_cooperatestatus_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_cooperatestatus_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_cooperatestatus_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_cooperatestatus_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_cooperatestatus_trafficlight)
    {
        m_receiverplanning_cooperatestatus_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_cooperatestatus_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_cooperatestatus_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_cooperatestatus_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_blindspot)
    {
        m_receiverplanning_debug_objectsofinterest_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_debug_objectsofinterest_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_blindspot::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_crosswalk)
    {
        m_receiverplanning_debug_objectsofinterest_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_debug_objectsofinterest_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_intersection)
    {
        m_receiverplanning_debug_objectsofinterest_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_debug_objectsofinterest_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_intersection::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_nostoppingarea)
    {
        m_receiverplanning_debug_objectsofinterest_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_debug_objectsofinterest_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_debug_objectsofinterest_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_debug_objectsofinterest_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_debug_objectsofinterest_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_debug_objectsofinterest_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_debug_objectsofinterest_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_debug_objectsofinterest_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_debug_objectsofinterest_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_debug_objectsofinterest_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_debug_objectsofinterest_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_debug_objectsofinterest_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_debug_objectsofinterest_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_debug_objectsofinterest_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_debug_objectsofinterest_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_debug_objectsofinterest_trafficlight)
    {
        m_receiverplanning_debug_objectsofinterest_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_debug_objectsofinterest_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_debug_objectsofinterest_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_debug_objectsofinterest_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_blindspot)
    {
        m_receiverplanning_planningfactors_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_blindspot::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_crosswalk)
    {
        m_receiverplanning_planningfactors_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_detectionarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_detectionarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_detectionarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_detectionarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_detectionarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_detectionarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_detectionarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_detectionarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_detectionarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_detectionareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_detectionarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_detectionarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_detectionarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_detectionarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_detectionarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_detectionarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_detectionarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_detectionarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_detectionarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_detectionarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_detectionarea)
    {
        m_receiverplanning_planningfactors_detectionarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_detectionarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_detectionarea::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_detectionarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_intersection)
    {
        m_receiverplanning_planningfactors_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_intersection::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_mergefromprivate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_mergefromprivate();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_mergefromprivate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_mergefromprivate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_mergefromprivate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_mergefromprivate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_mergefromprivate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_mergefromprivate::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_mergefromprivate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_mergefromprivateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_mergefromprivate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_mergefromprivate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_mergefromprivate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_mergefromprivate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_mergefromprivate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_mergefromprivate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_mergefromprivate(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_mergefromprivate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_mergefromprivate)
    {
        m_receiverplanning_planningfactors_mergefromprivate(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_mergefromprivate(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_mergefromprivate::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_mergefromprivate = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_nostoppingarea)
    {
        m_receiverplanning_planningfactors_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_runout()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_runout();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_runout.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_runout::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_runout::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_runout()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_runout.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_runout::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_runout()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_runoutTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_runout.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_runout::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_runout::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runoutTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_runout.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_runout(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runout::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runout::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runoutCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_runout.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_runout(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runout::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_runout::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_runout(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_runout::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_runout)
    {
        m_receiverplanning_planningfactors_runout(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_runout(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_runout::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_runout = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_stopline()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_stopline();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_stopline.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_stopline::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_stopline::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_stopline()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_stopline.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_stopline::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_stopline()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_stoplineTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_stopline.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_stopline::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_stopline::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stoplineTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_stopline.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_stopline(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stopline::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stopline::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stoplineCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_stopline.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_stopline(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stopline::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_stopline::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_stopline(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_stopline::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_stopline)
    {
        m_receiverplanning_planningfactors_stopline(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_stopline(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_stopline::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_stopline = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_trafficlight)
    {
        m_receiverplanning_planningfactors_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_planningfactors_walkway()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_planningfactors_walkway();
        
        // request subscribe
        auto subscribe = m_interface->planning_planningfactors_walkway.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_walkway::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_planningfactors_walkway::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_planningfactors_walkway()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_planningfactors_walkway.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_planningfactors_walkway::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_planningfactors_walkway()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_planningfactors_walkwayTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_planningfactors_walkway.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_walkway::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_planningfactors_walkway::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkwayTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_planningfactors_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_walkway.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_planningfactors_walkway(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkway::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkway::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkwayCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_planningfactors_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_planningfactors_walkway.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_planningfactors_walkway(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkway::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_planningfactors_walkway::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_planningfactors_walkway(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_planningfactors_walkway::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_planningfactors_walkway)
    {
        m_receiverplanning_planningfactors_walkway(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_planningfactors_walkway(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_planningfactors_walkway::SampleType&)> handler)
{
    m_receiverplanning_planningfactors_walkway = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignalCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pathCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runoutCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stoplineCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkwayCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsctCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runoutCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreasonCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvaluesCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloudCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stoplineCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkwayCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspotCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalkCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersectionCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivateCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingareaCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runoutCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stoplineCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlightCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkwayCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignalCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal = handler;
}
 
void RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path()
{
    if (m_found)
    {
        // regist receiver handler
        // if you want to enable it, please uncomment below code
        // RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_path();
        
        // request subscribe
        auto subscribe = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.Subscribe(1);
        if (subscribe.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path::Subscribed";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Subscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path::" << subscribe.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path()
{
    if (m_found)
    {
        // request stop subscribe
        m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.Unsubscribe();
        m_logger.LogVerbose() << "RPort_BVP2EBS::StopSubscribeplanning_scenarioplanning_lanedriving_behaviorplanning_path::Unsubscribed";
    }
}
 
void RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_path()
{
    if (m_found)
    {
        // set callback
        auto receiver = [this]() -> void {
            return ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered();
        };
        
        // regist callback
        auto callback = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.SetReceiveHandler(receiver);
        if (callback.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_path::SetReceiveHandler";
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::RegistReceiverplanning_scenarioplanning_lanedriving_behaviorplanning_path::SetReceiveHandler::" << callback.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathTriggered()
{
    if (m_found)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
        {
            auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.GetNewSamples([&](auto samplePtr) {
                RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_path(std::move(samplePtr));
            }));
            if (recv->HasValue())
            {
                m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_path::GetNewSamples::" << recv->Value();
            }
            else
            {
                m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_path::GetNewSamples::" << recv->Error().Message();
            }
        }
    }
}
 
void RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_pathCyclic()
{
    while (m_running)
    {
        if (m_found)
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.GetSubscriptionState() == ara::com::SubscriptionState::kSubscribed)
            {
                auto recv = std::make_unique<ara::core::Result<size_t>>(m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_path.GetNewSamples([&](auto samplePtr) {
                    RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_path(std::move(samplePtr));
                }));
                if (recv->HasValue())
                {
                    m_logger.LogVerbose() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_path::GetNewSamples::" << recv->Value();
                }
                else
                {
                    m_logger.LogError() << "RPort_BVP2EBS::ReceiveEventplanning_scenarioplanning_lanedriving_behaviorplanning_path::GetNewSamples::" << recv->Error().Message();
                }
            }
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void RPort_BVP2EBS::ReadDataplanning_scenarioplanning_lanedriving_behaviorplanning_path(ara::com::SamplePtr<oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_path::SampleType const> samplePtr)
{
    auto data = *samplePtr.Get();
    if (m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_path)
    {
        m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_path(data);
    }
}
 
void RPort_BVP2EBS::RegistEventHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_path(std::function<void(const oss::srv::BVP2EBS::proxy::events::planning_scenarioplanning_lanedriving_behaviorplanning_path::SampleType&)> handler)
{
    m_receiverplanning_scenarioplanning_lanedriving_behaviorplanning_path = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_blindspot(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_blindspot(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_blindspot::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_blindspot)
            {
                m_responderplanning_cooperatecommands_blindspot(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_blindspot::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_blindspot::Output&)> handler)
{
    m_responderplanning_cooperatecommands_blindspot = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_crosswalk(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_crosswalk(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_crosswalk::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_crosswalk)
            {
                m_responderplanning_cooperatecommands_crosswalk(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_crosswalk::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_crosswalk::Output&)> handler)
{
    m_responderplanning_cooperatecommands_crosswalk = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_intersection(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_intersection(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_intersection::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_intersection)
            {
                m_responderplanning_cooperatecommands_intersection(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_intersection::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_intersection::Output&)> handler)
{
    m_responderplanning_cooperatecommands_intersection = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_intersectionocclusion(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_intersectionocclusion::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_intersectionocclusion)
            {
                m_responderplanning_cooperatecommands_intersectionocclusion(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_intersectionocclusion::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_intersectionocclusion(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_intersectionocclusion::Output&)> handler)
{
    m_responderplanning_cooperatecommands_intersectionocclusion = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_nostoppingarea(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_nostoppingarea::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_nostoppingarea)
            {
                m_responderplanning_cooperatecommands_nostoppingarea(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_nostoppingarea::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_nostoppingarea::Output&)> handler)
{
    m_responderplanning_cooperatecommands_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Requestplanning_cooperatecommands_trafficlight(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_cooperatecommands_trafficlight(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_trafficlight::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_cooperatecommands_trafficlight)
            {
                m_responderplanning_cooperatecommands_trafficlight(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_cooperatecommands_trafficlight::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_cooperatecommands_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_cooperatecommands_trafficlight::Output&)> handler)
{
    m_responderplanning_cooperatecommands_trafficlight = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_blindspot(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_blindspot(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_blindspot::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_blindspot)
            {
                m_responderplanning_enableautomode_blindspot(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_blindspot::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_blindspot(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_blindspot::Output&)> handler)
{
    m_responderplanning_enableautomode_blindspot = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_crosswalk(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_crosswalk(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_crosswalk::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_crosswalk)
            {
                m_responderplanning_enableautomode_crosswalk(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_crosswalk::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_crosswalk(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_crosswalk::Output&)> handler)
{
    m_responderplanning_enableautomode_crosswalk = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_intersection(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_intersection(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_intersection::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_intersection)
            {
                m_responderplanning_enableautomode_intersection(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_intersection::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_intersection(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_intersection::Output&)> handler)
{
    m_responderplanning_enableautomode_intersection = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_intersectionocclusion(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_intersectionocclusion::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_intersectionocclusion)
            {
                m_responderplanning_enableautomode_intersectionocclusion(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_intersectionocclusion::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_intersectionocclusion(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_intersectionocclusion::Output&)> handler)
{
    m_responderplanning_enableautomode_intersectionocclusion = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_nostoppingarea(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_nostoppingarea::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_nostoppingarea)
            {
                m_responderplanning_enableautomode_nostoppingarea(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_nostoppingarea::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_nostoppingarea(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_nostoppingarea::Output&)> handler)
{
    m_responderplanning_enableautomode_nostoppingarea = handler;
}
 
void RPort_BVP2EBS::Requestplanning_enableautomode_trafficlight(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_enableautomode_trafficlight(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_enableautomode_trafficlight::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_enableautomode_trafficlight)
            {
                m_responderplanning_enableautomode_trafficlight(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_enableautomode_trafficlight::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_enableautomode_trafficlight(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_enableautomode_trafficlight::Output&)> handler)
{
    m_responderplanning_enableautomode_trafficlight = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters = handler;
}
 
void RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
{
    if (m_found)
    {
        auto request = m_interface->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(req);
        request.wait();
        auto response = request.GetResult();
        if (response.HasValue())
        {
            m_logger.LogVerbose() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Responded";
            
            auto result = response.Value();
            if (m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically)
            {
                m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(result);
            }
        }
        else
        {
            m_logger.LogError() << "RPort_BVP2EBS::Requestplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::" << response.Error().Message();
        }
    }
}
 
void RPort_BVP2EBS::RegistResponseHandlerplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(std::function<void(const oss::srv::BVP2EBS::proxy::methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output&)> handler)
{
    m_responderplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically = handler;
}
 
} /// namespace port
} /// namespace aa
} /// namespace exe_elasticbandsmoother
 
/// EOF