///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : ebs_si_behaviorvelocityplanner_proxy.h
/// SERVICE INTERFACE NAME            : EBS_SI_behaviorvelocityplanner
/// GENERATED DATE                    : 2025-12-05 12:02:21
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_OSS_SRV_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_PROXY_H
#define PARA_COM_GEN_OSS_SRV_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_PROXY_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "ebs_si_behaviorvelocityplanner_common.h"
#include "para/com/proxy/proxy_interface.h"
/// @uptrace{SWS_CM_01005}
namespace oss
{
namespace srv
{
namespace BVP2EBS
{
/// @uptrace{SWS_CM_01007}
namespace proxy
{
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_blindspot() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_blindspot(const planning_automodestatus_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_blindspot& operator=(const planning_automodestatus_blindspot& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_blindspot(planning_automodestatus_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_blindspot& operator=(planning_automodestatus_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_crosswalk(const planning_automodestatus_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_crosswalk& operator=(const planning_automodestatus_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_crosswalk(planning_automodestatus_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_crosswalk& operator=(planning_automodestatus_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_intersection() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_intersection(const planning_automodestatus_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_intersection& operator=(const planning_automodestatus_intersection& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_intersection(planning_automodestatus_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_intersection& operator=(planning_automodestatus_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_intersectionocclusion
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_intersectionocclusion(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_intersectionocclusion() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_intersectionocclusion(const planning_automodestatus_intersectionocclusion& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_intersectionocclusion& operator=(const planning_automodestatus_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_intersectionocclusion(planning_automodestatus_intersectionocclusion&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_intersectionocclusion& operator=(planning_automodestatus_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_nostoppingarea(const planning_automodestatus_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_nostoppingarea& operator=(const planning_automodestatus_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_nostoppingarea(planning_automodestatus_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_nostoppingarea& operator=(planning_automodestatus_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_trafficlight(const planning_automodestatus_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_trafficlight& operator=(const planning_automodestatus_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_trafficlight(planning_automodestatus_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_automodestatus_trafficlight& operator=(planning_automodestatus_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_automodestatus_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_blindspot() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_blindspot(const planning_cooperatestatus_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_blindspot& operator=(const planning_cooperatestatus_blindspot& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_blindspot(planning_cooperatestatus_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_blindspot& operator=(planning_cooperatestatus_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_crosswalk(const planning_cooperatestatus_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_crosswalk& operator=(const planning_cooperatestatus_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_crosswalk(planning_cooperatestatus_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_crosswalk& operator=(planning_cooperatestatus_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_intersection() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_intersection(const planning_cooperatestatus_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_intersection& operator=(const planning_cooperatestatus_intersection& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_intersection(planning_cooperatestatus_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_intersection& operator=(planning_cooperatestatus_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_intersectionocclusion
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_intersectionocclusion(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_intersectionocclusion() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_intersectionocclusion(const planning_cooperatestatus_intersectionocclusion& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_intersectionocclusion& operator=(const planning_cooperatestatus_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_intersectionocclusion(planning_cooperatestatus_intersectionocclusion&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_intersectionocclusion& operator=(planning_cooperatestatus_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_nostoppingarea(const planning_cooperatestatus_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_nostoppingarea& operator=(const planning_cooperatestatus_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_nostoppingarea(planning_cooperatestatus_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_nostoppingarea& operator=(planning_cooperatestatus_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_trafficlight(const planning_cooperatestatus_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_trafficlight& operator=(const planning_cooperatestatus_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_trafficlight(planning_cooperatestatus_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatestatus_trafficlight& operator=(planning_cooperatestatus_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_cooperatestatus_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_blindspot() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_blindspot(const planning_debug_objectsofinterest_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_blindspot& operator=(const planning_debug_objectsofinterest_blindspot& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_blindspot(planning_debug_objectsofinterest_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_blindspot& operator=(planning_debug_objectsofinterest_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_crosswalk(const planning_debug_objectsofinterest_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_crosswalk& operator=(const planning_debug_objectsofinterest_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_crosswalk(planning_debug_objectsofinterest_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_crosswalk& operator=(planning_debug_objectsofinterest_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_intersection() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_intersection(const planning_debug_objectsofinterest_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_intersection& operator=(const planning_debug_objectsofinterest_intersection& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_intersection(planning_debug_objectsofinterest_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_intersection& operator=(planning_debug_objectsofinterest_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_nostoppingarea(const planning_debug_objectsofinterest_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_nostoppingarea& operator=(const planning_debug_objectsofinterest_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_nostoppingarea(planning_debug_objectsofinterest_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_nostoppingarea& operator=(planning_debug_objectsofinterest_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_trafficlight(const planning_debug_objectsofinterest_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_trafficlight& operator=(const planning_debug_objectsofinterest_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_trafficlight(planning_debug_objectsofinterest_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_trafficlight& operator=(planning_debug_objectsofinterest_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_debug_objectsofinterest_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_blindspot() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_blindspot(const planning_planningfactors_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_blindspot& operator=(const planning_planningfactors_blindspot& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_blindspot(planning_planningfactors_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_blindspot& operator=(planning_planningfactors_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_crosswalk(const planning_planningfactors_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_crosswalk& operator=(const planning_planningfactors_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_crosswalk(planning_planningfactors_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_crosswalk& operator=(planning_planningfactors_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_detectionarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_detectionarea(const planning_planningfactors_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_detectionarea& operator=(const planning_planningfactors_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_detectionarea(planning_planningfactors_detectionarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_detectionarea& operator=(planning_planningfactors_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_intersection() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_intersection(const planning_planningfactors_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_intersection& operator=(const planning_planningfactors_intersection& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_intersection(planning_planningfactors_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_intersection& operator=(planning_planningfactors_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_mergefromprivate(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_mergefromprivate(const planning_planningfactors_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_mergefromprivate& operator=(const planning_planningfactors_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_mergefromprivate(planning_planningfactors_mergefromprivate&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_mergefromprivate& operator=(planning_planningfactors_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_nostoppingarea(const planning_planningfactors_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_nostoppingarea& operator=(const planning_planningfactors_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_nostoppingarea(planning_planningfactors_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_nostoppingarea& operator=(planning_planningfactors_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_runout(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_runout() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_runout(const planning_planningfactors_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_runout& operator=(const planning_planningfactors_runout& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_runout(planning_planningfactors_runout&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_runout& operator=(planning_planningfactors_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_stopline(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_stopline() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_stopline(const planning_planningfactors_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_stopline& operator=(const planning_planningfactors_stopline& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_stopline(planning_planningfactors_stopline&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_stopline& operator=(planning_planningfactors_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_trafficlight(const planning_planningfactors_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_trafficlight& operator=(const planning_planningfactors_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_trafficlight(planning_planningfactors_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_trafficlight& operator=(planning_planningfactors_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_walkway(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_walkway() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_walkway(const planning_planningfactors_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_walkway& operator=(const planning_planningfactors_walkway& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_walkway(planning_planningfactors_walkway&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_planningfactors_walkway& operator=(planning_planningfactors_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_planningfactors_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::string;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::stringEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::stringEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::string_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Int32Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::Int32StampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::Int32StampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Int32Stamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float32MultiArrayStamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::Float32MultiArrayStampedEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::Float32MultiArrayStampedEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_internal_debug_msgs::msg::Float32MultiArrayStamped_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::sensor_msgs::msg::PointCloud2;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PointCloud2EventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PointCloud2EventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::sensor_msgs::msg::PointCloud2_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::visualization_msgs::msg::MarkerArray_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(const planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_path
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_path(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_path() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_path(const planning_scenarioplanning_lanedriving_behaviorplanning_path& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_path& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_path& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_path(planning_scenarioplanning_lanedriving_behaviorplanning_path&& other) noexcept 
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_path& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_path&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        mMaxSampleCount = other.mMaxSampleCount;
        mEventReceiveHandler = other.mEventReceiveHandler;
        mSubscriptionStateChangeHandler = other.mSubscriptionStateChangeHandler;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
                mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Requests "Subscribe" message to Communication Management
    /// @uptrace{SWS_CM_00141}
    ara::core::Result<void> Subscribe(size_t maxSampleCount)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                if (mInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mInterface->SubscribeEvent(kCallSign, mMaxSampleCount);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                if (mDdsInterface->GetSubscriptionState(kCallSign) == ara::com::SubscriptionState::kSubscribed)
                {
                    if ((maxSampleCount != 0) && (maxSampleCount != mMaxSampleCount))
                    {
                        return ara::core::Result<void>(ara::com::ComErrc::kMaxSampleCountNotRealizable);
                    }
                }
                mMaxSampleCount = maxSampleCount;
                return mDdsInterface->SubscribeEvent<dds::oss::srv::BVP2EBS::PathEventType>(kCallSign, mMaxSampleCount);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Requests "StopSubscribe" message to Communication Management
    /// @uptrace{SWS_CM_00151}
    void Unsubscribe()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsubscribeEvent(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return state for current subscription
    /// @uptrace{SWS_CM_00316}
    ara::com::SubscriptionState GetSubscriptionState() const
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetSubscriptionState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->GetSubscriptionState(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::SubscriptionState::kNotSubscribed;
        }
    }
    /// @brief Register callback to catch changes of subscription state
    /// @uptrace{SWS_CM_00333}
    ara::core::Result<void> SetSubscriptionStateChangeHandler(ara::com::SubscriptionStateChangeHandler handler)
    {
        mSubscriptionStateChangeHandler = std::move(handler);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetSubscriptionStateChangeHandler(kCallSign, mSubscriptionStateChangeHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetSubscriptionStateChangeHandler
    /// @uptrace{SWS_CM_00334}
    void UnsetSubscriptionStateChangeHandler()
    {
        mSubscriptionStateChangeHandler = nullptr;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->UnsetSubscriptionStateChangeHandler(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Get received event data from cache
    /// @uptrace{SWS_CM_00701}
    template<typename F>
    ara::core::Result<size_t> GetNewSamples(F&& f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max())
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    auto samplePtr = ara::com::make_sample_ptr<const SampleType>(data);
                    samplePtr.SetProfileCheckStatus(mInterface->GetProfileCheckStatus(kCallSign));
                    f(std::move(samplePtr));
                }
                return samples.size();
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                auto samples = mInterface->GetNewSamples(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    para::serializer::Deserializer deserializer{sample};
                    SampleType data;
                    deserializer.read(props, data);
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto samples = mDdsInterface->GetNewSamples<dds::oss::srv::BVP2EBS::PathEventType>(kCallSign, maxNumberOfSamples);
                for (const auto& sample : samples)
                {
                    SampleType data = oss::type::autoware_planning_msgs::msg::Path_ConvertFromDdsType(sample.data());
                    f(ara::com::make_sample_ptr<const SampleType>(data));
                }
                return samples.size();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Register callback to catch that event data is received
    /// @uptrace{SWS_CM_00181}
    ara::core::Result<void> SetReceiveHandler(ara::com::EventReceiveHandler handler)
    {
        mEventReceiveHandler = std::move(handler);
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->SetEventReceiveHandler(kCallSign, mEventReceiveHandler);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Unset bound callback by SetReceiveHandler
    /// @uptrace{SWS_CM_00183}
    ara::core::Result<void> UnsetReceiveHandler()
    {
        mEventReceiveHandler = nullptr;
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return mDdsInterface->UnsetEventReceiveHandler(kCallSign);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief Returns the count of free event cache
    /// @uptrace{SWS_CM_00705}
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto ret = mInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto ret = mDdsInterface->GetFreeSampleCount(kCallSign);
                if (ret < 0)
                {
                    return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
                }
                return ret;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<size_t>(ara::core::CoreErrc::kInvalidArgument);
        }
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_10475}
    /// @uptrace{SWS_CM_90431}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch(mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    
private:
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    size_t mMaxSampleCount{0};
    ara::com::EventReceiveHandler mEventReceiveHandler{nullptr};
    ara::com::SubscriptionStateChangeHandler mSubscriptionStateChangeHandler{nullptr};
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_path"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_01015}
namespace methods
{
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_blindspot
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_blindspot() = default;
    /// @brief
    planning_cooperatecommands_blindspot(const planning_cooperatecommands_blindspot& other) = delete;
    planning_cooperatecommands_blindspot& operator=(const planning_cooperatecommands_blindspot& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_blindspot(planning_cooperatecommands_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_blindspot& operator=(planning_cooperatecommands_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_blindspot(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_blindspot::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Out _response_ = data.result();
            methods::planning_cooperatecommands_blindspot::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_blindspot::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_blindspot::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_blindspot::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_blindspot::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_blindspot"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_crosswalk
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_crosswalk() = default;
    /// @brief
    planning_cooperatecommands_crosswalk(const planning_cooperatecommands_crosswalk& other) = delete;
    planning_cooperatecommands_crosswalk& operator=(const planning_cooperatecommands_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_crosswalk(planning_cooperatecommands_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_crosswalk& operator=(planning_cooperatecommands_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_crosswalk(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_crosswalk::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Out _response_ = data.result();
            methods::planning_cooperatecommands_crosswalk::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_crosswalk::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_crosswalk::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_crosswalk::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_crosswalk::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_crosswalk"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_intersection
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_intersection() = default;
    /// @brief
    planning_cooperatecommands_intersection(const planning_cooperatecommands_intersection& other) = delete;
    planning_cooperatecommands_intersection& operator=(const planning_cooperatecommands_intersection& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_intersection(planning_cooperatecommands_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_intersection& operator=(planning_cooperatecommands_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_intersection(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_intersection::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Out _response_ = data.result();
            methods::planning_cooperatecommands_intersection::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_intersection::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_intersection::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_intersection::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_intersection::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_intersection"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_intersectionocclusion
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_intersectionocclusion(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_intersectionocclusion() = default;
    /// @brief
    planning_cooperatecommands_intersectionocclusion(const planning_cooperatecommands_intersectionocclusion& other) = delete;
    planning_cooperatecommands_intersectionocclusion& operator=(const planning_cooperatecommands_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_intersectionocclusion(planning_cooperatecommands_intersectionocclusion&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_intersectionocclusion& operator=(planning_cooperatecommands_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_intersectionocclusion(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_intersectionocclusion::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Out _response_ = data.result();
            methods::planning_cooperatecommands_intersectionocclusion::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_intersectionocclusion::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_intersectionocclusion::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_intersectionocclusion::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_intersectionocclusion::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_nostoppingarea
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_nostoppingarea() = default;
    /// @brief
    planning_cooperatecommands_nostoppingarea(const planning_cooperatecommands_nostoppingarea& other) = delete;
    planning_cooperatecommands_nostoppingarea& operator=(const planning_cooperatecommands_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_nostoppingarea(planning_cooperatecommands_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_nostoppingarea& operator=(planning_cooperatecommands_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_nostoppingarea(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_nostoppingarea::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Out _response_ = data.result();
            methods::planning_cooperatecommands_nostoppingarea::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_nostoppingarea::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_nostoppingarea::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_nostoppingarea::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_nostoppingarea::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_nostoppingarea"};
};
/// @uptrace{SWS_CM_00006}
class planning_cooperatecommands_trafficlight
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    /// @brief Constructor
    explicit planning_cooperatecommands_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatecommands_trafficlight() = default;
    /// @brief
    planning_cooperatecommands_trafficlight(const planning_cooperatecommands_trafficlight& other) = delete;
    planning_cooperatecommands_trafficlight& operator=(const planning_cooperatecommands_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_cooperatecommands_trafficlight(planning_cooperatecommands_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_cooperatecommands_trafficlight& operator=(planning_cooperatecommands_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_cooperatecommands_trafficlight(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_trafficlight::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Out _response_ = data.result();
            methods::planning_cooperatecommands_trafficlight::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_trafficlight::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_cooperatecommands_trafficlight::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_cooperatecommands_trafficlight::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_cooperatecommands_trafficlight::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_cooperatecommands_trafficlight"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_blindspot
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_blindspot(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_blindspot() = default;
    /// @brief
    planning_enableautomode_blindspot(const planning_enableautomode_blindspot& other) = delete;
    planning_enableautomode_blindspot& operator=(const planning_enableautomode_blindspot& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_blindspot(planning_enableautomode_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_blindspot& operator=(planning_enableautomode_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_blindspot(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_blindspot::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Out _response_ = data.result();
            methods::planning_enableautomode_blindspot::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_blindspot::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_blindspot::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_blindspot::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_blindspot::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_blindspot"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_crosswalk
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_crosswalk(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_crosswalk() = default;
    /// @brief
    planning_enableautomode_crosswalk(const planning_enableautomode_crosswalk& other) = delete;
    planning_enableautomode_crosswalk& operator=(const planning_enableautomode_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_crosswalk(planning_enableautomode_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_crosswalk& operator=(planning_enableautomode_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_crosswalk(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_crosswalk::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Out _response_ = data.result();
            methods::planning_enableautomode_crosswalk::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_crosswalk::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_crosswalk::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_crosswalk::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_crosswalk::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_crosswalk"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_intersection
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_intersection(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_intersection() = default;
    /// @brief
    planning_enableautomode_intersection(const planning_enableautomode_intersection& other) = delete;
    planning_enableautomode_intersection& operator=(const planning_enableautomode_intersection& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_intersection(planning_enableautomode_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_intersection& operator=(planning_enableautomode_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_intersection(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_intersection::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Out _response_ = data.result();
            methods::planning_enableautomode_intersection::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_intersection::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_intersection::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_intersection::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_intersection::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_intersection"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_intersectionocclusion
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_intersectionocclusion(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_intersectionocclusion() = default;
    /// @brief
    planning_enableautomode_intersectionocclusion(const planning_enableautomode_intersectionocclusion& other) = delete;
    planning_enableautomode_intersectionocclusion& operator=(const planning_enableautomode_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_intersectionocclusion(planning_enableautomode_intersectionocclusion&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_intersectionocclusion& operator=(planning_enableautomode_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_intersectionocclusion(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_intersectionocclusion::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Out _response_ = data.result();
            methods::planning_enableautomode_intersectionocclusion::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_intersectionocclusion::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_intersectionocclusion::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_intersectionocclusion::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_intersectionocclusion::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_nostoppingarea
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_nostoppingarea(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_nostoppingarea() = default;
    /// @brief
    planning_enableautomode_nostoppingarea(const planning_enableautomode_nostoppingarea& other) = delete;
    planning_enableautomode_nostoppingarea& operator=(const planning_enableautomode_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_nostoppingarea(planning_enableautomode_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_nostoppingarea& operator=(planning_enableautomode_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_nostoppingarea(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_nostoppingarea::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Out _response_ = data.result();
            methods::planning_enableautomode_nostoppingarea::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_nostoppingarea::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_nostoppingarea::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_nostoppingarea::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_nostoppingarea::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_nostoppingarea"};
};
/// @uptrace{SWS_CM_00006}
class planning_enableautomode_trafficlight
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    /// @brief Constructor
    explicit planning_enableautomode_trafficlight(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_enableautomode_trafficlight() = default;
    /// @brief
    planning_enableautomode_trafficlight(const planning_enableautomode_trafficlight& other) = delete;
    planning_enableautomode_trafficlight& operator=(const planning_enableautomode_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_enableautomode_trafficlight(planning_enableautomode_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_enableautomode_trafficlight& operator=(planning_enableautomode_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_In _in_args_;
                _in_args_.req() = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_enableautomode_trafficlight(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_trafficlight::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Out _response_ = data.result();
            methods::planning_enableautomode_trafficlight::Output _out_args_;
            _out_args_.res = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_trafficlight::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_enableautomode_trafficlight::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_enableautomode_trafficlight::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_enableautomode_trafficlight::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_enableautomode_trafficlight"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::logging_demo::srv::ConfigLogger_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::logging_demo::srv::ConfigLogger_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_In _in_args_;
                _in_args_.req() = oss::type::logging_demo::srv::ConfigLogger_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output _out_args_;
            _out_args_.res = oss::type::logging_demo::srv::ConfigLogger_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::DescribeParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::DescribeParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::DescribeParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::GetParameterTypes_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::GetParameterTypes_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::GetParameterTypes_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::ListParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::ListParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::ListParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::ListParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::autoware_internal_debug_msgs::srv::String_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_In _in_args_;
                _in_args_.req() = oss::type::autoware_internal_debug_msgs::srv::String_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output _out_args_;
            _out_args_.res = oss::type::autoware_internal_debug_msgs::srv::String_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::autoware_internal_debug_msgs::srv::String_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_In _in_args_;
                _in_args_.req() = oss::type::autoware_internal_debug_msgs::srv::String_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output _out_args_;
            _out_args_.res = oss::type::autoware_internal_debug_msgs::srv::String_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParameters_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParameters_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParameters_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParameters_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters"};
};
/// @uptrace{SWS_CM_00006}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically
{
public:
    /// @brief Container for OUT arguments
    /// @uptrace{SWS_CM_00196}
    struct Output
    {
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Response res;
    };
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(para::com::ProxyInterface* interface, para::com::ProxyDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically() = default;
    /// @brief
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically& other) = delete;
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodReturnHandler(kCallSign, [](std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData) {
                    HandleMethodReturn(result, data, userData);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        return *this;
    }
    /// @brief Function call operator
    /// @uptrace{SWS_CM_00196}
    ara::core::Future<Output> operator()(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req)
    {
        auto* __promise__ = new ara::core::Promise<Output>();
        auto __future__ = __promise__->get_future();
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer __serializer__{};
                __serializer__.write(props, req);
                auto __data__ = __serializer__.ensure();
                mInterface->CallMethod(kCallSign, __data__, __promise__);
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_In _in_args_;
                _in_args_.req() = oss::type::rcl_interfaces::srv::SetParametersAtomically_Request_ConvertToDdsType(req);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Call _call_{};
                _call_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(_in_args_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Hash);
                dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request _request_{};
                _request_.header() = mDdsInterface->GetMethodRequestHeader();
                _request_.data() = _call_;
                mDdsInterface->CallMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request>(_request_.header(), _request_, __promise__);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default :
                __promise__->SetError(ara::com::ComErrc::kNetworkBindingFailure);
                break;
        }
        return __future__;
    }
    /// @brief This method provides access to the global SMState of the this Method class,
    ///        which was determined by the last run of E2E_check function invoked during the last reception of the method response.
    /// @uptrace{SWS_CM_90483}
    /// @uptrace{SWS_CM_90484}
    ara::com::e2e::SMState GetSMState() const noexcept
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                return mInterface->GetE2EStateMachineState(kCallSign);;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                return ara::com::e2e::SMState::kStateMDisabled;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::com::e2e::SMState::kStateMDisabled;
        }
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    /// @brief Function call operator for DDS
    void HandleMethodReturn(dds::ReturnCode_t result, const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Result& data, void* userData)
    {
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output>*>(userData);
        if (result == dds::RETCODE_OK)
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Out _response_ = data.result();
            methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output _out_args_;
            _out_args_.res = oss::type::rcl_interfaces::srv::SetParametersAtomically_Response_ConvertFromDdsType(_response_.res());
            
            promise->set_value(_out_args_);
        }
        else
        {
            dds::ara::core::ErrorCode errorData = data.error();
            ara::core::ErrorDomain::IdType domainId = errorData.error_domain_value();
            ara::core::ErrorDomain::CodeType errorCode = errorData.error_code();
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output>*>(userData);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    
private:
    static void HandleMethodReturn(std::uint8_t result, const std::vector<std::uint8_t>& data, void* userData)
    {
        const para::serializer::TransformationProps props{};
        auto* promise = static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output>*>(userData);
        if (result == 0)
        {
            para::serializer::Deserializer deserializer{data};
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output output;
            deserializer.read(props, output.res);
            promise->set_value(output);
        }
        else
        {
            para::serializer::Deserializer deserializer{data};
            para::serializer::ApplicationMethodError applicationMethodError;
            deserializer.read(para::serializer::Serializer::getApplicationMethodErrorProps(), applicationMethodError);
            para::serializer::ApplicationMethodErrorData errorData = std::get<para::serializer::ApplicationMethodErrorData>(applicationMethodError);
            ara::core::ErrorDomain::IdType domainId = errorData.domainId;
            ara::core::ErrorDomain::CodeType errorCode = errorData.errorCode;
            switch (domainId)
            {
                default:
                {
                    promise->SetError(ara::com::ComErrc::kUnsetFailure);
                    break;
                }
            }
        }
        delete static_cast<ara::core::Promise<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically::Output>*>(userData);
    }
    para::com::ProxyInterface* mInterface;
    para::com::ProxyDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically"};
};
} /// namespace methods
/// @uptrace{SWS_CM_00004}
class EBS_SI_behaviorvelocityplannerProxy
{
public: 
    /// @uptrace{SWS_CM_00312}
    class HandleType
    {
    public:
        HandleType() = default;
        HandleType(ara::core::InstanceSpecifier instanceSpecifier, para::com::ServiceHandle service)
            : mInstanceSpecifier(std::move(instanceSpecifier))
            , mServiceHandle(service)
        {
        }
        ~HandleType() = default;
        /// @uptrace{SWS_CM_00317}
        HandleType(const HandleType& other) = default;
        HandleType& operator=(const HandleType& other) = default;
        /// @uptrace{SWS_CM_00318}
        HandleType(HandleType&& other) = default;
        HandleType& operator=(HandleType&& other) = default;
        /// @brief Return instance specifier
        ara::core::InstanceSpecifier GetInstanceSpecifier()
        {
            return mInstanceSpecifier;
        }
        /// @brief Return handle for bound service
        para::com::ServiceHandle GetServiceHandle()
        {
            return mServiceHandle;
        }
        /// @brief Is equal to operator
        inline bool operator==(const HandleType& other) const
        {
            return mInstanceSpecifier == other.mInstanceSpecifier && mServiceHandle == other.mServiceHandle;
        }
        /// @brief Less than operator
        inline bool operator<(const HandleType& other) const
        {
            return mServiceHandle.version < other.mServiceHandle.version;
        }
        
    private:
        ara::core::InstanceSpecifier mInstanceSpecifier{"undefined"};
        para::com::ServiceHandle mServiceHandle;
    };
    /// @brief Requests "FindService" message to Communication Management with callback
    /// @uptrace{SWS_CM_00623}
    static ara::core::Result<ara::com::FindServiceHandle> StartFindService(ara::com::FindServiceHandler<EBS_SI_behaviorvelocityplannerProxy::HandleType> handler, ara::core::InstanceSpecifier instanceSpec)
    {
        switch (para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyInterface::StartFindService(instanceSpec, findCallback);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                ara::com::FindServiceHandle findHandle = para::com::ProxyDdsInterface::GetFindServiceHandle(instanceSpec);
                auto findCallback = [&, handler, findHandle, instanceSpec](std::vector<para::com::ServiceHandle> services) {
                    ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                    for (auto& service : services)
                    {
                        handleContainer.emplace_back(instanceSpec, service);
                    }
                    handler(handleContainer, findHandle);
                };
                return para::com::ProxyDdsInterface::StartFindService(instanceSpec, findCallback);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::FindServiceHandle>::FromError(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Send "FindService" message to Communication Management at once
    /// @uptrace{SWS_CM_00622}
    static ara::core::Result<ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType>> FindService(ara::core::InstanceSpecifier instanceSpec)
    {
        switch(para::com::GetServiceProtocol(instanceSpec))
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                auto result = para::com::ProxyInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                auto result = para::com::ProxyDdsInterface::FindService(instanceSpec);
                if (!result.HasValue())
                {
                    return ara::core::Result<ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType>>::FromError(result.Error());
                }
                ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType> handleContainer;
                const auto& services = result.Value();
                for (auto& service : services)
                {
                    handleContainer.emplace_back(instanceSpec, service);
                }
                return handleContainer;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<ara::com::ServiceHandleContainer<EBS_SI_behaviorvelocityplannerProxy::HandleType>>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Constructor
    /// @note This function shall be called after processing of FindService/StartFindService was completed
    /// @uptrace{SWS_CM_00004, SWS_CM_00131}
    explicit EBS_SI_behaviorvelocityplannerProxy(HandleType& handle)
        : mHandle(handle)
        , mInterface(std::make_unique<para::com::ProxyInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , mDdsInterface(std::make_unique<para::com::ProxyDdsInterface>(handle.GetInstanceSpecifier(), handle.GetServiceHandle()))
        , planning_automodestatus_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_automodestatus_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatestatus_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_debug_objectsofinterest_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_detectionarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_mergefromprivate(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_runout(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_stopline(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_planningfactors_walkway(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_path(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_cooperatecommands_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_blindspot(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_crosswalk(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_intersection(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_nostoppingarea(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_enableautomode_trafficlight(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(mInterface.get(), mDdsInterface.get(), mHandle.GetServiceHandle().protocol)
    {
        #ifdef PARA_DDS_IMPLEMENTATION
        if (mHandle.GetServiceHandle().protocol == para::com::ServiceProtocol::kDds)
        {
            mDdsInterface->CreateMethods<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>();
            auto methodReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetMethodPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_blindspot();
                                planning_cooperatecommands_blindspot.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_crosswalk();
                                planning_cooperatecommands_crosswalk.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_intersection();
                                planning_cooperatecommands_intersection.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_intersectionocclusion();
                                planning_cooperatecommands_intersectionocclusion.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_nostoppingarea();
                                planning_cooperatecommands_nostoppingarea.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Hash :
                            {
                                auto _result_ = _return_.planning_cooperatecommands_trafficlight();
                                planning_cooperatecommands_trafficlight.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_blindspot();
                                planning_enableautomode_blindspot.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_crosswalk();
                                planning_enableautomode_crosswalk.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_intersection();
                                planning_enableautomode_intersection.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_intersectionocclusion();
                                planning_enableautomode_intersectionocclusion.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_nostoppingarea();
                                planning_enableautomode_nostoppingarea.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Hash :
                            {
                                auto _result_ = _return_.planning_enableautomode_trafficlight();
                                planning_enableautomode_trafficlight.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Hash :
                            {
                                auto _result_ = _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically();
                                planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically.HandleMethodReturn(_result_._d(), _result_, _userData_.Value());
                                break;
                            }
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetMethodReturnHandler(methodReplyHandler);
            mDdsInterface->CreateFields<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerField_Request, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerField_Reply>();
            auto fieldReplyHandler = [this] (dds::sub::AnyDataReader& dataReader) {
                dds::sub::DataReader<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerField_Reply> _reader_ = dataReader;
                dds::sub::LoanedSamples<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerField_Reply> _samples_;
                _samples_ = _reader_.take();
                for (auto& _sample_ : _samples_)
                {
                    if (_sample_.info().valid())
                    {
                        auto _reply_ = _sample_.data();
                        auto _userData_ = mDdsInterface->GetFieldPromise(_reply_.header());
                        if (!_userData_.HasValue())
                        {
                            return;
                        }
                        auto _return_ = _reply_.data();
                        switch (_return_._d())
                        {
                            default : break;
                        }
                    }
                }
            };
            mDdsInterface->SetFieldReturnHandler(fieldReplyHandler);
        }
        #endif /// PARA_DDS_IMPLEMENTATION
    }
    /// @brief Destructor
    /// @uptrace{SWS_CM_10446}
    ~EBS_SI_behaviorvelocityplannerProxy() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00136}
    EBS_SI_behaviorvelocityplannerProxy(EBS_SI_behaviorvelocityplannerProxy& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00136}
    EBS_SI_behaviorvelocityplannerProxy& operator=(const EBS_SI_behaviorvelocityplannerProxy& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00137}
    EBS_SI_behaviorvelocityplannerProxy(EBS_SI_behaviorvelocityplannerProxy&& other) noexcept
        : mHandle(std::move(other.mHandle))
        , mInterface(std::move(other.mInterface))
        , mDdsInterface(std::move(other.mDdsInterface))
        , planning_automodestatus_blindspot(std::move(other.planning_automodestatus_blindspot))
        , planning_automodestatus_crosswalk(std::move(other.planning_automodestatus_crosswalk))
        , planning_automodestatus_intersection(std::move(other.planning_automodestatus_intersection))
        , planning_automodestatus_intersectionocclusion(std::move(other.planning_automodestatus_intersectionocclusion))
        , planning_automodestatus_nostoppingarea(std::move(other.planning_automodestatus_nostoppingarea))
        , planning_automodestatus_trafficlight(std::move(other.planning_automodestatus_trafficlight))
        , planning_cooperatestatus_blindspot(std::move(other.planning_cooperatestatus_blindspot))
        , planning_cooperatestatus_crosswalk(std::move(other.planning_cooperatestatus_crosswalk))
        , planning_cooperatestatus_intersection(std::move(other.planning_cooperatestatus_intersection))
        , planning_cooperatestatus_intersectionocclusion(std::move(other.planning_cooperatestatus_intersectionocclusion))
        , planning_cooperatestatus_nostoppingarea(std::move(other.planning_cooperatestatus_nostoppingarea))
        , planning_cooperatestatus_trafficlight(std::move(other.planning_cooperatestatus_trafficlight))
        , planning_debug_objectsofinterest_blindspot(std::move(other.planning_debug_objectsofinterest_blindspot))
        , planning_debug_objectsofinterest_crosswalk(std::move(other.planning_debug_objectsofinterest_crosswalk))
        , planning_debug_objectsofinterest_intersection(std::move(other.planning_debug_objectsofinterest_intersection))
        , planning_debug_objectsofinterest_nostoppingarea(std::move(other.planning_debug_objectsofinterest_nostoppingarea))
        , planning_debug_objectsofinterest_trafficlight(std::move(other.planning_debug_objectsofinterest_trafficlight))
        , planning_planningfactors_blindspot(std::move(other.planning_planningfactors_blindspot))
        , planning_planningfactors_crosswalk(std::move(other.planning_planningfactors_crosswalk))
        , planning_planningfactors_detectionarea(std::move(other.planning_planningfactors_detectionarea))
        , planning_planningfactors_intersection(std::move(other.planning_planningfactors_intersection))
        , planning_planningfactors_mergefromprivate(std::move(other.planning_planningfactors_mergefromprivate))
        , planning_planningfactors_nostoppingarea(std::move(other.planning_planningfactors_nostoppingarea))
        , planning_planningfactors_runout(std::move(other.planning_planningfactors_runout))
        , planning_planningfactors_stopline(std::move(other.planning_planningfactors_stopline))
        , planning_planningfactors_trafficlight(std::move(other.planning_planningfactors_trafficlight))
        , planning_planningfactors_walkway(std::move(other.planning_planningfactors_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal))
        , planning_scenarioplanning_lanedriving_behaviorplanning_path(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_path))
        , planning_cooperatecommands_blindspot(std::move(other.planning_cooperatecommands_blindspot))
        , planning_cooperatecommands_crosswalk(std::move(other.planning_cooperatecommands_crosswalk))
        , planning_cooperatecommands_intersection(std::move(other.planning_cooperatecommands_intersection))
        , planning_cooperatecommands_intersectionocclusion(std::move(other.planning_cooperatecommands_intersectionocclusion))
        , planning_cooperatecommands_nostoppingarea(std::move(other.planning_cooperatecommands_nostoppingarea))
        , planning_cooperatecommands_trafficlight(std::move(other.planning_cooperatecommands_trafficlight))
        , planning_enableautomode_blindspot(std::move(other.planning_enableautomode_blindspot))
        , planning_enableautomode_crosswalk(std::move(other.planning_enableautomode_crosswalk))
        , planning_enableautomode_intersection(std::move(other.planning_enableautomode_intersection))
        , planning_enableautomode_intersectionocclusion(std::move(other.planning_enableautomode_intersectionocclusion))
        , planning_enableautomode_nostoppingarea(std::move(other.planning_enableautomode_nostoppingarea))
        , planning_enableautomode_trafficlight(std::move(other.planning_enableautomode_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically))
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00137}
    EBS_SI_behaviorvelocityplannerProxy& operator=(EBS_SI_behaviorvelocityplannerProxy&& other) noexcept
    {
        mHandle = std::move(other.mHandle);
        mInterface = std::move(other.mInterface);
        mDdsInterface = std::move(other.mDdsInterface);
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        planning_automodestatus_blindspot = std::move(other.planning_automodestatus_blindspot);
        planning_automodestatus_crosswalk = std::move(other.planning_automodestatus_crosswalk);
        planning_automodestatus_intersection = std::move(other.planning_automodestatus_intersection);
        planning_automodestatus_intersectionocclusion = std::move(other.planning_automodestatus_intersectionocclusion);
        planning_automodestatus_nostoppingarea = std::move(other.planning_automodestatus_nostoppingarea);
        planning_automodestatus_trafficlight = std::move(other.planning_automodestatus_trafficlight);
        planning_cooperatestatus_blindspot = std::move(other.planning_cooperatestatus_blindspot);
        planning_cooperatestatus_crosswalk = std::move(other.planning_cooperatestatus_crosswalk);
        planning_cooperatestatus_intersection = std::move(other.planning_cooperatestatus_intersection);
        planning_cooperatestatus_intersectionocclusion = std::move(other.planning_cooperatestatus_intersectionocclusion);
        planning_cooperatestatus_nostoppingarea = std::move(other.planning_cooperatestatus_nostoppingarea);
        planning_cooperatestatus_trafficlight = std::move(other.planning_cooperatestatus_trafficlight);
        planning_debug_objectsofinterest_blindspot = std::move(other.planning_debug_objectsofinterest_blindspot);
        planning_debug_objectsofinterest_crosswalk = std::move(other.planning_debug_objectsofinterest_crosswalk);
        planning_debug_objectsofinterest_intersection = std::move(other.planning_debug_objectsofinterest_intersection);
        planning_debug_objectsofinterest_nostoppingarea = std::move(other.planning_debug_objectsofinterest_nostoppingarea);
        planning_debug_objectsofinterest_trafficlight = std::move(other.planning_debug_objectsofinterest_trafficlight);
        planning_planningfactors_blindspot = std::move(other.planning_planningfactors_blindspot);
        planning_planningfactors_crosswalk = std::move(other.planning_planningfactors_crosswalk);
        planning_planningfactors_detectionarea = std::move(other.planning_planningfactors_detectionarea);
        planning_planningfactors_intersection = std::move(other.planning_planningfactors_intersection);
        planning_planningfactors_mergefromprivate = std::move(other.planning_planningfactors_mergefromprivate);
        planning_planningfactors_nostoppingarea = std::move(other.planning_planningfactors_nostoppingarea);
        planning_planningfactors_runout = std::move(other.planning_planningfactors_runout);
        planning_planningfactors_stopline = std::move(other.planning_planningfactors_stopline);
        planning_planningfactors_trafficlight = std::move(other.planning_planningfactors_trafficlight);
        planning_planningfactors_walkway = std::move(other.planning_planningfactors_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal);
        planning_scenarioplanning_lanedriving_behaviorplanning_path = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_path);
        planning_cooperatecommands_blindspot = std::move(other.planning_cooperatecommands_blindspot);
        planning_cooperatecommands_crosswalk = std::move(other.planning_cooperatecommands_crosswalk);
        planning_cooperatecommands_intersection = std::move(other.planning_cooperatecommands_intersection);
        planning_cooperatecommands_intersectionocclusion = std::move(other.planning_cooperatecommands_intersectionocclusion);
        planning_cooperatecommands_nostoppingarea = std::move(other.planning_cooperatecommands_nostoppingarea);
        planning_cooperatecommands_trafficlight = std::move(other.planning_cooperatecommands_trafficlight);
        planning_enableautomode_blindspot = std::move(other.planning_enableautomode_blindspot);
        planning_enableautomode_crosswalk = std::move(other.planning_enableautomode_crosswalk);
        planning_enableautomode_intersection = std::move(other.planning_enableautomode_intersection);
        planning_enableautomode_intersectionocclusion = std::move(other.planning_enableautomode_intersectionocclusion);
        planning_enableautomode_nostoppingarea = std::move(other.planning_enableautomode_nostoppingarea);
        planning_enableautomode_trafficlight = std::move(other.planning_enableautomode_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically);
        other.mInterface.reset();
        other.mDdsInterface.reset();
        return *this;
    }
    /// @brief Stop the running StartFindService
    /// @uptrace{SWS_CM_00125}
    void StopFindService(ara::com::FindServiceHandle /*handle*/)
    {
        switch (mHandle.GetServiceHandle().protocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopFindService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopFindService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopFindService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Return handle that is connected with service provider currently
    /// @uptrace{SWS_CM_10383}
    HandleType GetHandle() const
    {
        return mHandle;
    }
    
private:
    HandleType mHandle;
    std::unique_ptr<para::com::ProxyInterface> mInterface;
    std::unique_ptr<para::com::ProxyDdsInterface> mDdsInterface;
    
public:
    /// @brief - event, planning_automodestatus_blindspot
    events::planning_automodestatus_blindspot planning_automodestatus_blindspot;
    /// @brief - event, planning_automodestatus_crosswalk
    events::planning_automodestatus_crosswalk planning_automodestatus_crosswalk;
    /// @brief - event, planning_automodestatus_intersection
    events::planning_automodestatus_intersection planning_automodestatus_intersection;
    /// @brief - event, planning_automodestatus_intersectionocclusion
    events::planning_automodestatus_intersectionocclusion planning_automodestatus_intersectionocclusion;
    /// @brief - event, planning_automodestatus_nostoppingarea
    events::planning_automodestatus_nostoppingarea planning_automodestatus_nostoppingarea;
    /// @brief - event, planning_automodestatus_trafficlight
    events::planning_automodestatus_trafficlight planning_automodestatus_trafficlight;
    /// @brief - event, planning_cooperatestatus_blindspot
    events::planning_cooperatestatus_blindspot planning_cooperatestatus_blindspot;
    /// @brief - event, planning_cooperatestatus_crosswalk
    events::planning_cooperatestatus_crosswalk planning_cooperatestatus_crosswalk;
    /// @brief - event, planning_cooperatestatus_intersection
    events::planning_cooperatestatus_intersection planning_cooperatestatus_intersection;
    /// @brief - event, planning_cooperatestatus_intersectionocclusion
    events::planning_cooperatestatus_intersectionocclusion planning_cooperatestatus_intersectionocclusion;
    /// @brief - event, planning_cooperatestatus_nostoppingarea
    events::planning_cooperatestatus_nostoppingarea planning_cooperatestatus_nostoppingarea;
    /// @brief - event, planning_cooperatestatus_trafficlight
    events::planning_cooperatestatus_trafficlight planning_cooperatestatus_trafficlight;
    /// @brief - event, planning_debug_objectsofinterest_blindspot
    events::planning_debug_objectsofinterest_blindspot planning_debug_objectsofinterest_blindspot;
    /// @brief - event, planning_debug_objectsofinterest_crosswalk
    events::planning_debug_objectsofinterest_crosswalk planning_debug_objectsofinterest_crosswalk;
    /// @brief - event, planning_debug_objectsofinterest_intersection
    events::planning_debug_objectsofinterest_intersection planning_debug_objectsofinterest_intersection;
    /// @brief - event, planning_debug_objectsofinterest_nostoppingarea
    events::planning_debug_objectsofinterest_nostoppingarea planning_debug_objectsofinterest_nostoppingarea;
    /// @brief - event, planning_debug_objectsofinterest_trafficlight
    events::planning_debug_objectsofinterest_trafficlight planning_debug_objectsofinterest_trafficlight;
    /// @brief - event, planning_planningfactors_blindspot
    events::planning_planningfactors_blindspot planning_planningfactors_blindspot;
    /// @brief - event, planning_planningfactors_crosswalk
    events::planning_planningfactors_crosswalk planning_planningfactors_crosswalk;
    /// @brief - event, planning_planningfactors_detectionarea
    events::planning_planningfactors_detectionarea planning_planningfactors_detectionarea;
    /// @brief - event, planning_planningfactors_intersection
    events::planning_planningfactors_intersection planning_planningfactors_intersection;
    /// @brief - event, planning_planningfactors_mergefromprivate
    events::planning_planningfactors_mergefromprivate planning_planningfactors_mergefromprivate;
    /// @brief - event, planning_planningfactors_nostoppingarea
    events::planning_planningfactors_nostoppingarea planning_planningfactors_nostoppingarea;
    /// @brief - event, planning_planningfactors_runout
    events::planning_planningfactors_runout planning_planningfactors_runout;
    /// @brief - event, planning_planningfactors_stopline
    events::planning_planningfactors_stopline planning_planningfactors_stopline;
    /// @brief - event, planning_planningfactors_trafficlight
    events::planning_planningfactors_trafficlight planning_planningfactors_trafficlight;
    /// @brief - event, planning_planningfactors_walkway
    events::planning_planningfactors_walkway planning_planningfactors_walkway;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal
    events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal;
    /// @brief - event, planning_scenarioplanning_lanedriving_behaviorplanning_path
    events::planning_scenarioplanning_lanedriving_behaviorplanning_path planning_scenarioplanning_lanedriving_behaviorplanning_path;
    /// @brief - method, planning_cooperatecommands_blindspot
    methods::planning_cooperatecommands_blindspot planning_cooperatecommands_blindspot;
    /// @brief - method, planning_cooperatecommands_crosswalk
    methods::planning_cooperatecommands_crosswalk planning_cooperatecommands_crosswalk;
    /// @brief - method, planning_cooperatecommands_intersection
    methods::planning_cooperatecommands_intersection planning_cooperatecommands_intersection;
    /// @brief - method, planning_cooperatecommands_intersectionocclusion
    methods::planning_cooperatecommands_intersectionocclusion planning_cooperatecommands_intersectionocclusion;
    /// @brief - method, planning_cooperatecommands_nostoppingarea
    methods::planning_cooperatecommands_nostoppingarea planning_cooperatecommands_nostoppingarea;
    /// @brief - method, planning_cooperatecommands_trafficlight
    methods::planning_cooperatecommands_trafficlight planning_cooperatecommands_trafficlight;
    /// @brief - method, planning_enableautomode_blindspot
    methods::planning_enableautomode_blindspot planning_enableautomode_blindspot;
    /// @brief - method, planning_enableautomode_crosswalk
    methods::planning_enableautomode_crosswalk planning_enableautomode_crosswalk;
    /// @brief - method, planning_enableautomode_intersection
    methods::planning_enableautomode_intersection planning_enableautomode_intersection;
    /// @brief - method, planning_enableautomode_intersectionocclusion
    methods::planning_enableautomode_intersectionocclusion planning_enableautomode_intersectionocclusion;
    /// @brief - method, planning_enableautomode_nostoppingarea
    methods::planning_enableautomode_nostoppingarea planning_enableautomode_nostoppingarea;
    /// @brief - method, planning_enableautomode_trafficlight
    methods::planning_enableautomode_trafficlight planning_enableautomode_trafficlight;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters;
    /// @brief - method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically
    methods::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically;
};
} /// namespace proxy
} /// namespace BVP2EBS
} /// namespace srv
} /// namespace oss
#endif /// PARA_COM_GEN_oss_srv_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_PROXY_H