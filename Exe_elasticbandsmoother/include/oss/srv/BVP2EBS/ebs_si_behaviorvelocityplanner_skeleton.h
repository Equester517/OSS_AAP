///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : ebs_si_behaviorvelocityplanner_skeleton.h
/// SERVICE INTERFACE NAME            : EBS_SI_behaviorvelocityplanner
/// GENERATED DATE                    : 2025-12-05 12:02:20
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_OSS_SRV_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_SKELETON_H
#define PARA_COM_GEN_OSS_SRV_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_SKELETON_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "ebs_si_behaviorvelocityplanner_common.h"
#include "para/com/skeleton/skeleton_interface.h"
/// @uptrace{SWS_CM_01005}
namespace oss
{
namespace srv
{
namespace BVP2EBS
{
/// @uptrace{SWS_CM_01006}
namespace skeleton
{
class EBS_SI_behaviorvelocityplannerSkeleton;
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_blindspot() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_blindspot(const planning_automodestatus_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_blindspot& operator=(const planning_automodestatus_blindspot& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_blindspot(planning_automodestatus_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_blindspot& operator=(planning_automodestatus_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_crosswalk(const planning_automodestatus_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_crosswalk& operator=(const planning_automodestatus_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_crosswalk(planning_automodestatus_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_crosswalk& operator=(planning_automodestatus_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_intersection() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_intersection(const planning_automodestatus_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_intersection& operator=(const planning_automodestatus_intersection& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_intersection(planning_automodestatus_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_intersection& operator=(planning_automodestatus_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_intersectionocclusion
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_intersectionocclusion(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_intersectionocclusion() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_intersectionocclusion(const planning_automodestatus_intersectionocclusion& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_intersectionocclusion& operator=(const planning_automodestatus_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_intersectionocclusion(planning_automodestatus_intersectionocclusion&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_intersectionocclusion& operator=(planning_automodestatus_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_nostoppingarea(const planning_automodestatus_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_nostoppingarea& operator=(const planning_automodestatus_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_nostoppingarea(planning_automodestatus_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_nostoppingarea& operator=(planning_automodestatus_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_automodestatus_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::AutoModeStatus;
    /// @brief Constructor
    explicit planning_automodestatus_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_automodestatus_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_automodestatus_trafficlight(const planning_automodestatus_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_automodestatus_trafficlight& operator=(const planning_automodestatus_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_automodestatus_trafficlight(planning_automodestatus_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_automodestatus_trafficlight& operator=(planning_automodestatus_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::AutoModeStatusEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::AutoModeStatus_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::AutoModeStatusEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_automodestatus_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_blindspot() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_blindspot(const planning_cooperatestatus_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_blindspot& operator=(const planning_cooperatestatus_blindspot& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_blindspot(planning_cooperatestatus_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_blindspot& operator=(planning_cooperatestatus_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_crosswalk(const planning_cooperatestatus_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_crosswalk& operator=(const planning_cooperatestatus_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_crosswalk(planning_cooperatestatus_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_crosswalk& operator=(planning_cooperatestatus_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_intersection() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_intersection(const planning_cooperatestatus_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_intersection& operator=(const planning_cooperatestatus_intersection& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_intersection(planning_cooperatestatus_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_intersection& operator=(planning_cooperatestatus_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_intersectionocclusion
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_intersectionocclusion(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_intersectionocclusion() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_intersectionocclusion(const planning_cooperatestatus_intersectionocclusion& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_intersectionocclusion& operator=(const planning_cooperatestatus_intersectionocclusion& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_intersectionocclusion(planning_cooperatestatus_intersectionocclusion&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_intersectionocclusion& operator=(planning_cooperatestatus_intersectionocclusion&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_intersectionocclusion"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_nostoppingarea(const planning_cooperatestatus_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_nostoppingarea& operator=(const planning_cooperatestatus_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_nostoppingarea(planning_cooperatestatus_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_nostoppingarea& operator=(planning_cooperatestatus_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_cooperatestatus_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray;
    /// @brief Constructor
    explicit planning_cooperatestatus_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_cooperatestatus_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_cooperatestatus_trafficlight(const planning_cooperatestatus_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_cooperatestatus_trafficlight& operator=(const planning_cooperatestatus_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_cooperatestatus_trafficlight(planning_cooperatestatus_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_cooperatestatus_trafficlight& operator=(planning_cooperatestatus_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_rtc_msgs::msg::CooperateStatusArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::CooperateStatusArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_cooperatestatus_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_blindspot() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_blindspot(const planning_debug_objectsofinterest_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_blindspot& operator=(const planning_debug_objectsofinterest_blindspot& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_blindspot(planning_debug_objectsofinterest_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_blindspot& operator=(planning_debug_objectsofinterest_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_crosswalk(const planning_debug_objectsofinterest_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_crosswalk& operator=(const planning_debug_objectsofinterest_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_crosswalk(planning_debug_objectsofinterest_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_crosswalk& operator=(planning_debug_objectsofinterest_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_intersection() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_intersection(const planning_debug_objectsofinterest_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_intersection& operator=(const planning_debug_objectsofinterest_intersection& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_intersection(planning_debug_objectsofinterest_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_intersection& operator=(planning_debug_objectsofinterest_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_nostoppingarea(const planning_debug_objectsofinterest_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_nostoppingarea& operator=(const planning_debug_objectsofinterest_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_nostoppingarea(planning_debug_objectsofinterest_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_nostoppingarea& operator=(planning_debug_objectsofinterest_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_debug_objectsofinterest_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_debug_objectsofinterest_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_debug_objectsofinterest_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_debug_objectsofinterest_trafficlight(const planning_debug_objectsofinterest_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_debug_objectsofinterest_trafficlight& operator=(const planning_debug_objectsofinterest_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_debug_objectsofinterest_trafficlight(planning_debug_objectsofinterest_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_debug_objectsofinterest_trafficlight& operator=(planning_debug_objectsofinterest_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_debug_objectsofinterest_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_blindspot() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_blindspot(const planning_planningfactors_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_blindspot& operator=(const planning_planningfactors_blindspot& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_blindspot(planning_planningfactors_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_blindspot& operator=(planning_planningfactors_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_crosswalk(const planning_planningfactors_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_crosswalk& operator=(const planning_planningfactors_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_crosswalk(planning_planningfactors_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_crosswalk& operator=(planning_planningfactors_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_detectionarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_detectionarea(const planning_planningfactors_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_detectionarea& operator=(const planning_planningfactors_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_detectionarea(planning_planningfactors_detectionarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_detectionarea& operator=(planning_planningfactors_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_intersection() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_intersection(const planning_planningfactors_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_intersection& operator=(const planning_planningfactors_intersection& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_intersection(planning_planningfactors_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_intersection& operator=(planning_planningfactors_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_mergefromprivate(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_mergefromprivate(const planning_planningfactors_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_mergefromprivate& operator=(const planning_planningfactors_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_mergefromprivate(planning_planningfactors_mergefromprivate&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_mergefromprivate& operator=(planning_planningfactors_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_nostoppingarea(const planning_planningfactors_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_nostoppingarea& operator=(const planning_planningfactors_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_nostoppingarea(planning_planningfactors_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_nostoppingarea& operator=(planning_planningfactors_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_runout(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_runout() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_runout(const planning_planningfactors_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_runout& operator=(const planning_planningfactors_runout& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_runout(planning_planningfactors_runout&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_runout& operator=(planning_planningfactors_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_stopline(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_stopline() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_stopline(const planning_planningfactors_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_stopline& operator=(const planning_planningfactors_stopline& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_stopline(planning_planningfactors_stopline&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_stopline& operator=(planning_planningfactors_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_trafficlight(const planning_planningfactors_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_trafficlight& operator=(const planning_planningfactors_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_trafficlight(planning_planningfactors_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_trafficlight& operator=(planning_planningfactors_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_planningfactors_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_planning_msgs::msg::PlanningFactorArray;
    /// @brief Constructor
    explicit planning_planningfactors_walkway(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_planningfactors_walkway() = default;
    /// @brief Delete copy constructor
    planning_planningfactors_walkway(const planning_planningfactors_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_planningfactors_walkway& operator=(const planning_planningfactors_walkway& other) = delete;
    /// @brief Move constructor
    planning_planningfactors_walkway(planning_planningfactors_walkway&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_planningfactors_walkway& operator=(planning_planningfactors_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_planning_msgs::msg::PlanningFactorArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PlanningFactorArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_planningfactors_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::string;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::stringEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::stringEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::string_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::stringEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::TrafficLightGroupEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::tier4_debug_msgs::msg::ProcessingTimeTree_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::ProcessingTimeTreeEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Int32Stamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::Int32StampedEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::Int32StampedEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_internal_debug_msgs::msg::Int32Stamped_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::Int32StampedEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_internal_debug_msgs::msg::Float32MultiArrayStamped;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::Float32MultiArrayStampedEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::Float32MultiArrayStampedEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_internal_debug_msgs::msg::Float32MultiArrayStamped_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::Float32MultiArrayStampedEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::sensor_msgs::msg::PointCloud2;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PointCloud2EventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PointCloud2EventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::sensor_msgs::msg::PointCloud2_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PointCloud2EventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::visualization_msgs::msg::MarkerArray;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::MarkerArrayEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::visualization_msgs::msg::MarkerArray_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::MarkerArrayEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(const planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::TrafficLightGroupEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_msgs::autoware_perception_msgs::msg::TrafficLightGroup_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::TrafficLightGroupEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal"};
};
/// @uptrace{SWS_CM_00003}
class planning_scenarioplanning_lanedriving_behaviorplanning_path
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = oss::type::autoware_planning_msgs::msg::Path;
    /// @brief Constructor
    explicit planning_scenarioplanning_lanedriving_behaviorplanning_path(para::com::SkeletonInterface* interface, para::com::SkeletonDdsInterface* ddsInterface, para::com::ServiceProtocol protocol)
        : mInterface(interface)
        , mDdsInterface(ddsInterface)
        , mProtocol(protocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateEvent<dds::oss::srv::BVP2EBS::PathEventType>(kCallSign);
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~planning_scenarioplanning_lanedriving_behaviorplanning_path() = default;
    /// @brief Delete copy constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_path(const planning_scenarioplanning_lanedriving_behaviorplanning_path& other) = delete;
    /// @brief Delete copy assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_path& operator=(const planning_scenarioplanning_lanedriving_behaviorplanning_path& other) = delete;
    /// @brief Move constructor
    planning_scenarioplanning_lanedriving_behaviorplanning_path(planning_scenarioplanning_lanedriving_behaviorplanning_path&& other) noexcept
        : mInterface(other.mInterface)
        , mDdsInterface(other.mDdsInterface)
        , mProtocol(other.mProtocol)
    {
    }
    /// @brief Move assignment
    planning_scenarioplanning_lanedriving_behaviorplanning_path& operator=(planning_scenarioplanning_lanedriving_behaviorplanning_path&& other) noexcept
    {
        mInterface = other.mInterface;
        mDdsInterface = other.mDdsInterface;
        mProtocol = other.mProtocol;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            case para::com::ServiceProtocol::kIpc :
            {
                const para::serializer::TransformationProps props{};
                para::serializer::Serializer serializer{};
                serializer.write(props, data);
                auto payload = serializer.ensure();
                return mInterface->SendEvent(kCallSign, payload);
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                dds::oss::srv::BVP2EBS::PathEventType _event_;
                _event_.instance_id() = mDdsInterface->GetInstanceId();
                _event_.data() = oss::type::autoware_planning_msgs::msg::Path_ConvertToDdsType(data);
                return mDdsInterface->SendEvent<dds::oss::srv::BVP2EBS::PathEventType>(kCallSign, _event_);
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    para::com::SkeletonDdsInterface* mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    const std::string kCallSign = {"planning_scenarioplanning_lanedriving_behaviorplanning_path"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_00002}
class EBS_SI_behaviorvelocityplannerSkeleton
{
public:
    /// @uptrace{SWS_CM_00191}
    struct planning_cooperatecommands_blindspotOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_crosswalkOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_intersectionOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_intersectionocclusionOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_nostoppingareaOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_cooperatecommands_trafficlightOutput
    {
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response res;
    };
    struct planning_enableautomode_blindspotOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_crosswalkOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_intersectionOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_intersectionocclusionOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_nostoppingareaOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_enableautomode_trafficlightOutput
    {
        oss::type::tier4_rtc_msgs::srv::AutoMode_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput
    {
        oss::type::logging_demo::srv::ConfigLogger_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput
    {
        oss::type::rcl_interfaces::srv::DescribeParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput
    {
        oss::type::rcl_interfaces::srv::GetParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput
    {
        oss::type::rcl_interfaces::srv::GetParameterTypes_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput
    {
        oss::type::rcl_interfaces::srv::ListParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput
    {
        oss::type::autoware_internal_debug_msgs::srv::String_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput
    {
        oss::type::autoware_internal_debug_msgs::srv::String_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput
    {
        oss::type::rcl_interfaces::srv::SetParameters_Response res;
    };
    struct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput
    {
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Response res;
    };
    /// @brief Constructor
    /// @uptrace{SWS_CM_00002, SWS_CM_00152}
    EBS_SI_behaviorvelocityplannerSkeleton(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent)
        : mInterface(std::make_unique<para::com::SkeletonInterface>(instanceSpec, mode))
        , mDdsInterface(std::make_unique<para::com::SkeletonDdsInterface>(instanceSpec, mode))
        , mProtocol(para::com::GetServiceProtocol(instanceSpec))
        , planning_automodestatus_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_automodestatus_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_intersectionocclusion(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_cooperatestatus_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_debug_objectsofinterest_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_detectionarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_mergefromprivate(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_runout(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_stopline(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_planningfactors_walkway(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(mInterface.get(), mDdsInterface.get(), mProtocol)
        , planning_scenarioplanning_lanedriving_behaviorplanning_path(mInterface.get(), mDdsInterface.get(), mProtocol)
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Destructor
    virtual ~EBS_SI_behaviorvelocityplannerSkeleton() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00134}
    EBS_SI_behaviorvelocityplannerSkeleton(const EBS_SI_behaviorvelocityplannerSkeleton& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00134}
    EBS_SI_behaviorvelocityplannerSkeleton& operator=(const EBS_SI_behaviorvelocityplannerSkeleton& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00135}
    EBS_SI_behaviorvelocityplannerSkeleton(EBS_SI_behaviorvelocityplannerSkeleton&& other) noexcept
        : mInterface(std::move(other.mInterface))
        , mDdsInterface(std::move(other.mDdsInterface))
        , mProtocol(std::move(other.mProtocol))
        , planning_automodestatus_blindspot(std::move(other.planning_automodestatus_blindspot))
        , planning_automodestatus_crosswalk(std::move(other.planning_automodestatus_crosswalk))
        , planning_automodestatus_intersection(std::move(other.planning_automodestatus_intersection))
        , planning_automodestatus_intersectionocclusion(std::move(other.planning_automodestatus_intersectionocclusion))
        , planning_automodestatus_nostoppingarea(std::move(other.planning_automodestatus_nostoppingarea))
        , planning_automodestatus_trafficlight(std::move(other.planning_automodestatus_trafficlight))
        , planning_cooperatestatus_blindspot(std::move(other.planning_cooperatestatus_blindspot))
        , planning_cooperatestatus_crosswalk(std::move(other.planning_cooperatestatus_crosswalk))
        , planning_cooperatestatus_intersection(std::move(other.planning_cooperatestatus_intersection))
        , planning_cooperatestatus_intersectionocclusion(std::move(other.planning_cooperatestatus_intersectionocclusion))
        , planning_cooperatestatus_nostoppingarea(std::move(other.planning_cooperatestatus_nostoppingarea))
        , planning_cooperatestatus_trafficlight(std::move(other.planning_cooperatestatus_trafficlight))
        , planning_debug_objectsofinterest_blindspot(std::move(other.planning_debug_objectsofinterest_blindspot))
        , planning_debug_objectsofinterest_crosswalk(std::move(other.planning_debug_objectsofinterest_crosswalk))
        , planning_debug_objectsofinterest_intersection(std::move(other.planning_debug_objectsofinterest_intersection))
        , planning_debug_objectsofinterest_nostoppingarea(std::move(other.planning_debug_objectsofinterest_nostoppingarea))
        , planning_debug_objectsofinterest_trafficlight(std::move(other.planning_debug_objectsofinterest_trafficlight))
        , planning_planningfactors_blindspot(std::move(other.planning_planningfactors_blindspot))
        , planning_planningfactors_crosswalk(std::move(other.planning_planningfactors_crosswalk))
        , planning_planningfactors_detectionarea(std::move(other.planning_planningfactors_detectionarea))
        , planning_planningfactors_intersection(std::move(other.planning_planningfactors_intersection))
        , planning_planningfactors_mergefromprivate(std::move(other.planning_planningfactors_mergefromprivate))
        , planning_planningfactors_nostoppingarea(std::move(other.planning_planningfactors_nostoppingarea))
        , planning_planningfactors_runout(std::move(other.planning_planningfactors_runout))
        , planning_planningfactors_stopline(std::move(other.planning_planningfactors_stopline))
        , planning_planningfactors_trafficlight(std::move(other.planning_planningfactors_trafficlight))
        , planning_planningfactors_walkway(std::move(other.planning_planningfactors_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight))
        , planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway))
        , planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal))
        , planning_scenarioplanning_lanedriving_behaviorplanning_path(std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_path))
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00135}
    EBS_SI_behaviorvelocityplannerSkeleton& operator=(EBS_SI_behaviorvelocityplannerSkeleton&& other) noexcept
    {
        mInterface = std::move(other.mInterface);
        mDdsInterface = std::move(other.mDdsInterface);
        mProtocol = std::move(other.mProtocol);
        planning_automodestatus_blindspot = std::move(other.planning_automodestatus_blindspot);
        planning_automodestatus_crosswalk = std::move(other.planning_automodestatus_crosswalk);
        planning_automodestatus_intersection = std::move(other.planning_automodestatus_intersection);
        planning_automodestatus_intersectionocclusion = std::move(other.planning_automodestatus_intersectionocclusion);
        planning_automodestatus_nostoppingarea = std::move(other.planning_automodestatus_nostoppingarea);
        planning_automodestatus_trafficlight = std::move(other.planning_automodestatus_trafficlight);
        planning_cooperatestatus_blindspot = std::move(other.planning_cooperatestatus_blindspot);
        planning_cooperatestatus_crosswalk = std::move(other.planning_cooperatestatus_crosswalk);
        planning_cooperatestatus_intersection = std::move(other.planning_cooperatestatus_intersection);
        planning_cooperatestatus_intersectionocclusion = std::move(other.planning_cooperatestatus_intersectionocclusion);
        planning_cooperatestatus_nostoppingarea = std::move(other.planning_cooperatestatus_nostoppingarea);
        planning_cooperatestatus_trafficlight = std::move(other.planning_cooperatestatus_trafficlight);
        planning_debug_objectsofinterest_blindspot = std::move(other.planning_debug_objectsofinterest_blindspot);
        planning_debug_objectsofinterest_crosswalk = std::move(other.planning_debug_objectsofinterest_crosswalk);
        planning_debug_objectsofinterest_intersection = std::move(other.planning_debug_objectsofinterest_intersection);
        planning_debug_objectsofinterest_nostoppingarea = std::move(other.planning_debug_objectsofinterest_nostoppingarea);
        planning_debug_objectsofinterest_trafficlight = std::move(other.planning_debug_objectsofinterest_trafficlight);
        planning_planningfactors_blindspot = std::move(other.planning_planningfactors_blindspot);
        planning_planningfactors_crosswalk = std::move(other.planning_planningfactors_crosswalk);
        planning_planningfactors_detectionarea = std::move(other.planning_planningfactors_detectionarea);
        planning_planningfactors_intersection = std::move(other.planning_planningfactors_intersection);
        planning_planningfactors_mergefromprivate = std::move(other.planning_planningfactors_mergefromprivate);
        planning_planningfactors_nostoppingarea = std::move(other.planning_planningfactors_nostoppingarea);
        planning_planningfactors_runout = std::move(other.planning_planningfactors_runout);
        planning_planningfactors_stopline = std::move(other.planning_planningfactors_stopline);
        planning_planningfactors_trafficlight = std::move(other.planning_planningfactors_trafficlight);
        planning_planningfactors_walkway = std::move(other.planning_planningfactors_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight);
        planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway);
        planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal);
        planning_scenarioplanning_lanedriving_behaviorplanning_path = std::move(other.planning_scenarioplanning_lanedriving_behaviorplanning_path);
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_cooperatecommands_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_cooperatecommands_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_blindspotCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_blindspot(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_crosswalkCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_crosswalk(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersection(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_intersectionocclusionCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_intersectionocclusion(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_nostoppingareaCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_nostoppingarea(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_enableautomode_trafficlightCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_enableautomode_trafficlight(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(data, token);
                });
                mInterface->SetMethodCallHandler(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
                    Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(data, token);
                });
                mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
                    E2EErrorHandler(errorCode, dataID, messageCounter);
                });
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->CreateMethods<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>();
                mDdsInterface->SetMethodCallHandler([this](dds::sub::AnyDataReader& reader) {
                    HandleDdsMethod(reader);
                });
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        other.mInterface.reset();
        other.mDdsInterface.reset();
        return *this;
    }
    /// @brief Send "OfferService" message to Communication Management
    /// @uptrace{SWS_CM_00101}
    ara::core::Result<void> OfferService()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                return mInterface->OfferService();
            }
            case para::com::ServiceProtocol::kIpc :
            {
            	return mInterface->OfferService();
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
            	return mDdsInterface->OfferService();
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : return ara::core::Result<void>(ara::com::ComErrc::kNetworkBindingFailure);
        }
    }
    /// @brief Send "StopOfferService" message to Communication Management
    /// @uptrace{SWS_CM_00111}
    void StopOfferService()
    {
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                mInterface->StopOfferService();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                mInterface->StopOfferService();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                mDdsInterface->StopOfferService();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
    }
    /// @brief Allows the implementation providing the service method to trigger the execution of the next service consumer method call at a specific point of time
    ///        if the processing mode is set to kPoll.
    /// @note This function requires that ara::com::MethodCallProcessingMode is configured as kPoll by constructor
    /// @uptrace{SWS_CM_00199}
    ara::core::Future<bool> ProcessNextMethodCall()
    {
        ara::core::Promise<bool> promise{};
        ara::core::Result<bool> ret{false};
        switch (mProtocol)
        {
            case para::com::ServiceProtocol::kSomeIp :
            {
                ret = mInterface->ProcessNextMethodCall();
                break;
            }
            case para::com::ServiceProtocol::kIpc :
            {
                ret = mInterface->ProcessNextMethodCall();
                break;
            }
            #ifdef PARA_DDS_IMPLEMENTATION
            case para::com::ServiceProtocol::kDds :
            {
                ret = mDdsInterface->ProcessNextMethodCall();
                break;
            }
            #endif /// PARA_DDS_IMPLEMENTATION
            default : break;
        }
        if (ret.HasValue())
        {
            promise.set_value(ret.Value());
        }
        else
        {
            promise.SetError(ret.Error());
        }
        return promise.get_future();
    }
    /// @brief In case the call to E2E_check indicated a failed E2E check of the request message, the server application can get notified via an E2E error handler.
    /// @uptrace{SWS_CM_10470}
    virtual void E2EErrorHandler(const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter)
    {
    }
    
private:
    std::unique_ptr<para::com::SkeletonInterface> mInterface;
    std::unique_ptr<para::com::SkeletonDdsInterface> mDdsInterface;
    para::com::ServiceProtocol mProtocol;
    
public:
    /// @brief Event, planning_automodestatus_blindspot
    events::planning_automodestatus_blindspot planning_automodestatus_blindspot;
    /// @brief Event, planning_automodestatus_crosswalk
    events::planning_automodestatus_crosswalk planning_automodestatus_crosswalk;
    /// @brief Event, planning_automodestatus_intersection
    events::planning_automodestatus_intersection planning_automodestatus_intersection;
    /// @brief Event, planning_automodestatus_intersectionocclusion
    events::planning_automodestatus_intersectionocclusion planning_automodestatus_intersectionocclusion;
    /// @brief Event, planning_automodestatus_nostoppingarea
    events::planning_automodestatus_nostoppingarea planning_automodestatus_nostoppingarea;
    /// @brief Event, planning_automodestatus_trafficlight
    events::planning_automodestatus_trafficlight planning_automodestatus_trafficlight;
    /// @brief Event, planning_cooperatestatus_blindspot
    events::planning_cooperatestatus_blindspot planning_cooperatestatus_blindspot;
    /// @brief Event, planning_cooperatestatus_crosswalk
    events::planning_cooperatestatus_crosswalk planning_cooperatestatus_crosswalk;
    /// @brief Event, planning_cooperatestatus_intersection
    events::planning_cooperatestatus_intersection planning_cooperatestatus_intersection;
    /// @brief Event, planning_cooperatestatus_intersectionocclusion
    events::planning_cooperatestatus_intersectionocclusion planning_cooperatestatus_intersectionocclusion;
    /// @brief Event, planning_cooperatestatus_nostoppingarea
    events::planning_cooperatestatus_nostoppingarea planning_cooperatestatus_nostoppingarea;
    /// @brief Event, planning_cooperatestatus_trafficlight
    events::planning_cooperatestatus_trafficlight planning_cooperatestatus_trafficlight;
    /// @brief Event, planning_debug_objectsofinterest_blindspot
    events::planning_debug_objectsofinterest_blindspot planning_debug_objectsofinterest_blindspot;
    /// @brief Event, planning_debug_objectsofinterest_crosswalk
    events::planning_debug_objectsofinterest_crosswalk planning_debug_objectsofinterest_crosswalk;
    /// @brief Event, planning_debug_objectsofinterest_intersection
    events::planning_debug_objectsofinterest_intersection planning_debug_objectsofinterest_intersection;
    /// @brief Event, planning_debug_objectsofinterest_nostoppingarea
    events::planning_debug_objectsofinterest_nostoppingarea planning_debug_objectsofinterest_nostoppingarea;
    /// @brief Event, planning_debug_objectsofinterest_trafficlight
    events::planning_debug_objectsofinterest_trafficlight planning_debug_objectsofinterest_trafficlight;
    /// @brief Event, planning_planningfactors_blindspot
    events::planning_planningfactors_blindspot planning_planningfactors_blindspot;
    /// @brief Event, planning_planningfactors_crosswalk
    events::planning_planningfactors_crosswalk planning_planningfactors_crosswalk;
    /// @brief Event, planning_planningfactors_detectionarea
    events::planning_planningfactors_detectionarea planning_planningfactors_detectionarea;
    /// @brief Event, planning_planningfactors_intersection
    events::planning_planningfactors_intersection planning_planningfactors_intersection;
    /// @brief Event, planning_planningfactors_mergefromprivate
    events::planning_planningfactors_mergefromprivate planning_planningfactors_mergefromprivate;
    /// @brief Event, planning_planningfactors_nostoppingarea
    events::planning_planningfactors_nostoppingarea planning_planningfactors_nostoppingarea;
    /// @brief Event, planning_planningfactors_runout
    events::planning_planningfactors_runout planning_planningfactors_runout;
    /// @brief Event, planning_planningfactors_stopline
    events::planning_planningfactors_stopline planning_planningfactors_stopline;
    /// @brief Event, planning_planningfactors_trafficlight
    events::planning_planningfactors_trafficlight planning_planningfactors_trafficlight;
    /// @brief Event, planning_planningfactors_walkway
    events::planning_planningfactors_walkway planning_planningfactors_walkway;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_blindspot;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_crosswalk;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_detectionarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersection_decisionstate;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_intersectiontrafficsignal;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_mergefromprivate;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_nostoppingarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_path;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_blindspot;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_crosswalk;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_runout;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_stopline;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_processingtimedetailms_walkway;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_detectionarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_intrsct;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_mergefromprivate;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_nostoppingarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_pstdtlms_trafficlight;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_accelreason;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_debugvalues;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_runout_filteredpointcloud;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_stopline;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_trafficlight;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_debug_walkway;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_blindspot;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_crosswalk;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_detectionarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_intersection;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_mergefromprivate;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_nostoppingarea;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_runout;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_stopline;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_trafficlight;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway
    events::planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_virtualwall_walkway;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal
    events::planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal planning_scenarioplanning_lanedriving_behaviorplanning_debug_trafficsignal;
    /// @brief Event, planning_scenarioplanning_lanedriving_behaviorplanning_path
    events::planning_scenarioplanning_lanedriving_behaviorplanning_path planning_scenarioplanning_lanedriving_behaviorplanning_path;
    /// @brief Method, planning_cooperatecommands_blindspot
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_blindspotOutput> planning_cooperatecommands_blindspot(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_crosswalk
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_crosswalkOutput> planning_cooperatecommands_crosswalk(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_intersection
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_intersectionOutput> planning_cooperatecommands_intersection(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_intersectionocclusion
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_intersectionocclusionOutput> planning_cooperatecommands_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_nostoppingarea
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_nostoppingareaOutput> planning_cooperatecommands_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_cooperatecommands_trafficlight
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_cooperatecommands_trafficlightOutput> planning_cooperatecommands_trafficlight(const oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request& req) = 0;
    /// @brief Method, planning_enableautomode_blindspot
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_blindspotOutput> planning_enableautomode_blindspot(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_crosswalk
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_crosswalkOutput> planning_enableautomode_crosswalk(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_intersection
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_intersectionOutput> planning_enableautomode_intersection(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_intersectionocclusion
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_intersectionocclusionOutput> planning_enableautomode_intersectionocclusion(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_nostoppingarea
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_nostoppingareaOutput> planning_enableautomode_nostoppingarea(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_enableautomode_trafficlight
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_enableautomode_trafficlightOutput> planning_enableautomode_trafficlight(const oss::type::tier4_rtc_msgs::srv::AutoMode_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const oss::type::logging_demo::srv::ConfigLogger_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const oss::type::rcl_interfaces::srv::DescribeParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const oss::type::rcl_interfaces::srv::GetParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const oss::type::rcl_interfaces::srv::GetParameterTypes_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const oss::type::rcl_interfaces::srv::ListParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const oss::type::autoware_internal_debug_msgs::srv::String_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const oss::type::rcl_interfaces::srv::SetParameters_Request& req) = 0;
    /// @brief Method, planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput> planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const oss::type::rcl_interfaces::srv::SetParametersAtomically_Request& req) = 0;
    
private:
    void Handleplanning_cooperatecommands_blindspot(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_blindspot(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_blindspotOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_blindspotCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_crosswalk(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_crosswalk(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_crosswalkOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_crosswalkCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_intersection(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_intersection(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_intersectionOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_intersectionCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_intersectionocclusion(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_intersectionocclusion(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_intersectionocclusionOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_intersectionocclusionCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_nostoppingarea(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_nostoppingarea(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_nostoppingareaOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_nostoppingareaCallSign, retResult, retData, token);
    }
    void Handleplanning_cooperatecommands_trafficlight(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_cooperatecommands_trafficlight(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_cooperatecommands_trafficlightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_cooperatecommands_trafficlightCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_blindspot(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_blindspot(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_blindspotOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_blindspotCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_crosswalk(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_crosswalk(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_crosswalkOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_crosswalkCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_intersection(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_intersection(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_intersectionOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_intersectionCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_intersectionocclusion(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_intersectionocclusion(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_intersectionocclusionOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_intersectionocclusionCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_nostoppingarea(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_nostoppingarea(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_nostoppingareaOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_nostoppingareaCallSign, retResult, retData, token);
    }
    void Handleplanning_enableautomode_trafficlight(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_enableautomode_trafficlight(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_enableautomode_trafficlightOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_enableautomode_trafficlightCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::logging_demo::srv::ConfigLogger_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::DescribeParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::GetParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::GetParameterTypes_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::ListParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::autoware_internal_debug_msgs::srv::String_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::autoware_internal_debug_msgs::srv::String_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::SetParameters_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign, retResult, retData, token);
    }
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        const para::serializer::TransformationProps props{};
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Request _req_;
        deserializer.read(props, _req_);
        auto future = planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(_req_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(props, output.res);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            para::serializer::ApplicationMethodErrorData errorData{result.Error().Domain().Id(), result.Error().Value()};
            para::serializer::ApplicationMethodError error;
            error = errorData;
            para::serializer::Serializer serializer{};
            serializer.write(para::serializer::Serializer::getApplicationMethodErrorProps(), error);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign, retResult, retData, token);
    }
    #ifdef PARA_DDS_IMPLEMENTATION
    void HandleDdsMethod(const dds::sub::AnyDataReader& reader)
    {
        dds::sub::DataReader<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request> _reader_ = reader;
        dds::sub::LoanedSamples<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Request> _requests_;
        _requests_ = _reader_.take();
        for (auto& _request_ : _requests_)
        {
            if (_request_->info().valid())
            {
                auto _data_ = _request_.data().data();
                switch (_data_._d())
                {
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Hash :
                    {
                        Handleplanning_cooperatecommands_blindspot(_data_.planning_cooperatecommands_blindspot(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Hash :
                    {
                        Handleplanning_cooperatecommands_crosswalk(_data_.planning_cooperatecommands_crosswalk(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Hash :
                    {
                        Handleplanning_cooperatecommands_intersection(_data_.planning_cooperatecommands_intersection(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Hash :
                    {
                        Handleplanning_cooperatecommands_intersectionocclusion(_data_.planning_cooperatecommands_intersectionocclusion(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Hash :
                    {
                        Handleplanning_cooperatecommands_nostoppingarea(_data_.planning_cooperatecommands_nostoppingarea(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Hash :
                    {
                        Handleplanning_cooperatecommands_trafficlight(_data_.planning_cooperatecommands_trafficlight(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Hash :
                    {
                        Handleplanning_enableautomode_blindspot(_data_.planning_enableautomode_blindspot(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Hash :
                    {
                        Handleplanning_enableautomode_crosswalk(_data_.planning_enableautomode_crosswalk(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Hash :
                    {
                        Handleplanning_enableautomode_intersection(_data_.planning_enableautomode_intersection(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Hash :
                    {
                        Handleplanning_enableautomode_intersectionocclusion(_data_.planning_enableautomode_intersectionocclusion(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Hash :
                    {
                        Handleplanning_enableautomode_nostoppingarea(_data_.planning_enableautomode_nostoppingarea(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Hash :
                    {
                        Handleplanning_enableautomode_trafficlight(_data_.planning_enableautomode_trafficlight(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(), _request_.data().header());
                        break;
                    }
                    case dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Hash :
                    {
                        Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(_data_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(), _request_.data().header());
                        break;
                    }
                    default : break;
                }
            }
        }
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_blindspot(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_blindspot(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_blindspot(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_blindspot_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_crosswalk(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_crosswalk(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_crosswalk(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_crosswalk_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_intersection(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_intersection(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_intersection(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersection_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_intersectionocclusion(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_intersectionocclusion(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_intersectionocclusion(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_intersectionocclusion_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_nostoppingarea(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_nostoppingarea(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_nostoppingarea(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_nostoppingarea_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_cooperatecommands_trafficlight(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request _req = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_cooperatecommands_trafficlight(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::CooperateCommands_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_cooperatecommands_trafficlight(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_cooperatecommands_trafficlight_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_blindspot(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_blindspot(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_blindspot(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_blindspot_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_crosswalk(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_crosswalk(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_crosswalk(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_crosswalk_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_intersection(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_intersection(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_intersection(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersection_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_intersectionocclusion(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_intersectionocclusion(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_intersectionocclusion(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_intersectionocclusion_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_nostoppingarea(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_nostoppingarea(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_nostoppingarea(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_nostoppingarea_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_enableautomode_trafficlight(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Result _result_{};
        oss::type::tier4_rtc_msgs::srv::AutoMode_Request _req = oss::type::tier4_rtc_msgs::srv::AutoMode_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_enableautomode_trafficlight(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Out _out_args_;
            _out_args_.res() = oss::type::tier4_rtc_msgs::srv::AutoMode_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_enableautomode_trafficlight(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_enableautomode_trafficlight_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Result _result_{};
        oss::type::logging_demo::srv::ConfigLogger_Request _req = oss::type::logging_demo::srv::ConfigLogger_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Out _out_args_;
            _out_args_.res() = oss::type::logging_demo::srv::ConfigLogger_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::DescribeParameters_Request _req = oss::type::rcl_interfaces::srv::DescribeParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::DescribeParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::GetParameters_Request _req = oss::type::rcl_interfaces::srv::GetParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::GetParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Result _result_{};
        oss::type::rcl_interfaces::srv::GetParameterTypes_Request _req = oss::type::rcl_interfaces::srv::GetParameterTypes_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::GetParameterTypes_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::ListParameters_Request _req = oss::type::rcl_interfaces::srv::ListParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::ListParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Result _result_{};
        oss::type::autoware_internal_debug_msgs::srv::String_Request _req = oss::type::autoware_internal_debug_msgs::srv::String_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Out _out_args_;
            _out_args_.res() = oss::type::autoware_internal_debug_msgs::srv::String_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Result _result_{};
        oss::type::autoware_internal_debug_msgs::srv::String_Request _req = oss::type::autoware_internal_debug_msgs::srv::String_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Out _out_args_;
            _out_args_.res() = oss::type::autoware_internal_debug_msgs::srv::String_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Result _result_{};
        oss::type::rcl_interfaces::srv::SetParameters_Request _req = oss::type::rcl_interfaces::srv::SetParameters_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::SetParameters_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    #ifdef PARA_DDS_IMPLEMENTATION
    void Handleplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(const dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_In& data, const dds::rpc::RequestHeader token)
    {
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Result _result_{};
        oss::type::rcl_interfaces::srv::SetParametersAtomically_Request _req = oss::type::rcl_interfaces::srv::SetParametersAtomically_Request_ConvertFromDdsType(data.req());
        auto future = this->planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(_req);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Out _out_args_;
            _out_args_.res() = oss::type::rcl_interfaces::srv::SetParametersAtomically_Response_ConvertToDdsType(result.Value().res);
            _result_.result(_out_args_, dds::RETCODE_OK);
        }
        else
        {
            dds::ara::core::ErrorCode _error_;
            _error_.error_code() = result.Error().Value();
            _error_.error_domain_value() = result.Error().Domain().Id();
            _result_.error(_error_, dds::RETCODE_ERROR);
        }
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Return _return_;
        _return_.planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically(_result_, dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically_Hash);
        dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply _reply_;
        _reply_.data() = _return_;
        _reply_.header() = mDdsInterface->GetReplyHeader(token);
        mDdsInterface->ReturnMethod<dds::oss::srv::BVP2EBS::EBS_SI_behaviorvelocityplannerMethod_Reply>(_reply_);
    }
    #endif /// PARA_DDS_IMPLEMENTATION
    const std::string kplanning_cooperatecommands_blindspotCallSign{"planning_cooperatecommands_blindspot"};
    const std::string kplanning_cooperatecommands_crosswalkCallSign{"planning_cooperatecommands_crosswalk"};
    const std::string kplanning_cooperatecommands_intersectionCallSign{"planning_cooperatecommands_intersection"};
    const std::string kplanning_cooperatecommands_intersectionocclusionCallSign{"planning_cooperatecommands_intersectionocclusion"};
    const std::string kplanning_cooperatecommands_nostoppingareaCallSign{"planning_cooperatecommands_nostoppingarea"};
    const std::string kplanning_cooperatecommands_trafficlightCallSign{"planning_cooperatecommands_trafficlight"};
    const std::string kplanning_enableautomode_blindspotCallSign{"planning_enableautomode_blindspot"};
    const std::string kplanning_enableautomode_crosswalkCallSign{"planning_enableautomode_crosswalk"};
    const std::string kplanning_enableautomode_intersectionCallSign{"planning_enableautomode_intersection"};
    const std::string kplanning_enableautomode_intersectionocclusionCallSign{"planning_enableautomode_intersectionocclusion"};
    const std::string kplanning_enableautomode_nostoppingareaCallSign{"planning_enableautomode_nostoppingarea"};
    const std::string kplanning_enableautomode_trafficlightCallSign{"planning_enableautomode_trafficlight"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configloggerCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_configlogger"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_describeparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypesCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_getparametertypes"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_listparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadpluginCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_loadplugin"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadpluginCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_service_unloadplugin"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparameters"};
    const std::string kplanning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomicallyCallSign{"planning_scenarioplanning_lanedriving_behaviorplanning_behaviorvelocityplanner_setparametersatomically"};
};
} /// namespace skeleton
} /// namespace BVP2EBS
} /// namespace srv
} /// namespace oss
#endif /// PARA_COM_GEN_OSS_SRV_BVP2EBS_SERVICE_INTERFACE_EBS_SI_BEHAVIORVELOCITYPLANNER_SKELETON_H